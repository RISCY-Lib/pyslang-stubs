import os
import typing
from _typeshed import Incomplete
from typing import Callable, ClassVar, Iterator, overload

__version__: str

class ASTContext:
    def __init__(self, scope, lookupLocation, flags: ASTFlags = ...) -> None: ...
    def addAssertionBacktrace(self, diag) -> None: ...
    def addDiag(self, *args, **kwargs): ...
    def eval(self, *args, **kwargs): ...
    def evalDimension(self, syntax, requireRange: bool, isPacked: bool) -> EvaluatedDimension: ...
    @overload
    def evalInteger(self, syntax, extraFlags: ASTFlags = ...) -> int | None: ...
    @overload
    def evalInteger(self, expr, extraFlags: EvalFlags = ...) -> int | None: ...
    @overload
    def evalPackedDimension(self, syntax) -> EvaluatedDimension: ...
    @overload
    def evalPackedDimension(self, syntax) -> EvaluatedDimension: ...
    def evalUnpackedDimension(self, syntax) -> EvaluatedDimension: ...
    def getRandMode(self, *args, **kwargs): ...
    def requireBooleanConvertible(self, expr) -> bool: ...
    def requireGtZero(self, value: int | None, range) -> bool: ...
    @overload
    def requireIntegral(self, expr) -> bool: ...
    @overload
    def requireIntegral(self, cv, range) -> bool: ...
    def requireNoUnknowns(self, value, range) -> bool: ...
    @overload
    def requirePositive(self, value, range) -> bool: ...
    @overload
    def requirePositive(self, value: int | None, range) -> bool: ...
    def requireSimpleExpr(self, *args, **kwargs): ...
    @overload
    def requireValidBitWidth(self, width: int, range) -> bool: ...
    @overload
    def requireValidBitWidth(self, value, range) -> int | None: ...
    def resetFlags(self, addedFlags: ASTFlags) -> ASTContext: ...
    def tryEval(self, *args, **kwargs): ...
    @property
    def flags(self) -> ASTFlags: ...
    @property
    def getCompilation(self): ...
    @property
    def getInstance(self): ...
    @property
    def getLocation(self): ...
    @property
    def getProceduralBlock(self): ...
    @property
    def inAlwaysCombLatch(self) -> bool: ...
    @property
    def inUnevaluatedBranch(self) -> bool: ...
    @property
    def lookupIndex(self): ...
    @property
    def scope(self): ...

class ASTFlags:
    __members__: ClassVar[dict] = ...  # read-only
    AllowClockingBlock: ClassVar[ASTFlags] = ...
    AllowCoverageSampleFormal: ClassVar[ASTFlags] = ...
    AllowCoverpoint: ClassVar[ASTFlags] = ...
    AllowDataType: ClassVar[ASTFlags] = ...
    AllowInterconnect: ClassVar[ASTFlags] = ...
    AllowNetType: ClassVar[ASTFlags] = ...
    AllowTypeReferences: ClassVar[ASTFlags] = ...
    AllowUnboundedLiteral: ClassVar[ASTFlags] = ...
    AllowUnboundedLiteralArithmetic: ClassVar[ASTFlags] = ...
    AssertionDefaultArg: ClassVar[ASTFlags] = ...
    AssertionDelayOrRepetition: ClassVar[ASTFlags] = ...
    AssertionExpr: ClassVar[ASTFlags] = ...
    AssertionInstanceArgCheck: ClassVar[ASTFlags] = ...
    AssignmentAllowed: ClassVar[ASTFlags] = ...
    AssignmentDisallowed: ClassVar[ASTFlags] = ...
    BindInstantiation: ClassVar[ASTFlags] = ...
    ConcurrentAssertActionBlock: ClassVar[ASTFlags] = ...
    ConfigParam: ClassVar[ASTFlags] = ...
    DPIArg: ClassVar[ASTFlags] = ...
    DisallowUDNT: ClassVar[ASTFlags] = ...
    EventExpression: ClassVar[ASTFlags] = ...
    Final: ClassVar[ASTFlags] = ...
    ForkJoinAnyNone: ClassVar[ASTFlags] = ...
    Function: ClassVar[ASTFlags] = ...
    InsideConcatenation: ClassVar[ASTFlags] = ...
    LAndRValue: ClassVar[ASTFlags] = ...
    LValue: ClassVar[ASTFlags] = ...
    NoReference: ClassVar[ASTFlags] = ...
    NonBlockingTimingControl: ClassVar[ASTFlags] = ...
    NonProcedural: ClassVar[ASTFlags] = ...
    None_: ClassVar[ASTFlags] = ...
    OutputArg: ClassVar[ASTFlags] = ...
    PropertyNegation: ClassVar[ASTFlags] = ...
    PropertyTimeAdvance: ClassVar[ASTFlags] = ...
    RecursivePropertyArg: ClassVar[ASTFlags] = ...
    SpecifyBlock: ClassVar[ASTFlags] = ...
    SpecparamInitializer: ClassVar[ASTFlags] = ...
    StaticInitializer: ClassVar[ASTFlags] = ...
    StreamingAllowed: ClassVar[ASTFlags] = ...
    StreamingWithRange: ClassVar[ASTFlags] = ...
    TopLevelStatement: ClassVar[ASTFlags] = ...
    TypeOperator: ClassVar[ASTFlags] = ...
    UnevaluatedBranch: ClassVar[ASTFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class AbortAssertionExpr(AssertionExpr):
    class Action:
        __members__: ClassVar[dict] = ...  # read-only
        Accept: ClassVar[AbortAssertionExpr.Action] = ...
        Reject: ClassVar[AbortAssertionExpr.Action] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Accept: ClassVar[AbortAssertionExpr.Action] = ...
    Reject: ClassVar[AbortAssertionExpr.Action] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def action(self): ...
    @property
    def condition(self): ...
    @property
    def expr(self) -> AssertionExpr: ...
    @property
    def isSync(self) -> bool: ...

class AcceptOnPropertyExprSyntax(PropertyExprSyntax):
    closeParen: Token
    condition: ExpressionSyntax
    expr: PropertyExprSyntax
    keyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ActionBlockSyntax(SyntaxNode):
    elseClause: ElseClauseSyntax
    statement: StatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class AnalysisFlags:
    __members__: ClassVar[dict] = ...  # read-only
    AllowDupInitialDrivers: ClassVar[AnalysisFlags] = ...
    AllowMultiDrivenLocals: ClassVar[AnalysisFlags] = ...
    CheckUnused: ClassVar[AnalysisFlags] = ...
    FullCaseFourState: ClassVar[AnalysisFlags] = ...
    FullCaseUniquePriority: ClassVar[AnalysisFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class AnalysisManager:
    def __init__(self, options: AnalysisOptions = ...) -> None: ...
    def analyze(self, compilation) -> AnalyzedDesign: ...
    def analyzeScopeBlocking(self, scope, parentProcedure=...) -> AnalyzedScope: ...
    def getAnalyzedScope(self, scope) -> AnalyzedScope: ...
    def getAnalyzedSubroutine(self, *args, **kwargs): ...
    def getDiagnostics(self, *args, **kwargs): ...
    def getDrivers(self, symbol) -> list[tuple[ValueDriver, tuple[int, int]]]: ...
    @property
    def options(self) -> AnalysisOptions: ...

class AnalysisOptions:
    flags: AnalysisFlags
    maxCaseAnalysisSteps: int
    maxLoopAnalysisSteps: int
    numThreads: int
    def __init__(self) -> None: ...

class AnalyzedDesign:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def compilation(self): ...
    @property
    def compilationUnits(self) -> list[AnalyzedScope]: ...
    @property
    def packages(self) -> list[AnalyzedScope]: ...
    @property
    def topInstances(self) -> list[PendingAnalysis]: ...

class AnalyzedProcedure:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def analyzedSymbol(self): ...
    @property
    def assertions(self): ...
    @property
    def callExpressions(self): ...
    @property
    def drivers(self): ...
    @property
    def inferredClock(self): ...
    @property
    def parentProcedure(self) -> AnalyzedProcedure: ...

class AnalyzedScope:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def childScopes(self): ...
    @property
    def procedures(self): ...
    @property
    def scope(self): ...

class AnonymousProgramSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...

class AnonymousProgramSyntax(MemberSyntax):
    endkeyword: Token
    keyword: Token
    members: Incomplete
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class AnsiPortListSyntax(PortListSyntax):
    closeParen: Token
    openParen: Token
    ports: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class AnsiUdpPortListSyntax(UdpPortListSyntax):
    closeParen: Token
    openParen: Token
    ports: Incomplete
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ArbitrarySymbolExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def symbol(self): ...

class ArgumentDirection:
    __members__: ClassVar[dict] = ...  # read-only
    In: ClassVar[ArgumentDirection] = ...
    InOut: ClassVar[ArgumentDirection] = ...
    Out: ClassVar[ArgumentDirection] = ...
    Ref: ClassVar[ArgumentDirection] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ArgumentListSyntax(SyntaxNode):
    closeParen: Token
    openParen: Token
    parameters: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ArgumentSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ArrayOrRandomizeMethodExpressionSyntax(ExpressionSyntax):
    args: ParenExpressionListSyntax
    constraints: ConstraintBlockSyntax
    method: ExpressionSyntax
    with_: Token
    def __init__(self, *args, **kwargs) -> None: ...

class AssertionExpr:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def bad(self) -> bool: ...
    @property
    def kind(self) -> AssertionExprKind: ...
    @property
    def syntax(self): ...

class AssertionExprKind:
    __members__: ClassVar[dict] = ...  # read-only
    Abort: ClassVar[AssertionExprKind] = ...
    Binary: ClassVar[AssertionExprKind] = ...
    Case: ClassVar[AssertionExprKind] = ...
    Clocking: ClassVar[AssertionExprKind] = ...
    Conditional: ClassVar[AssertionExprKind] = ...
    DisableIff: ClassVar[AssertionExprKind] = ...
    FirstMatch: ClassVar[AssertionExprKind] = ...
    Invalid: ClassVar[AssertionExprKind] = ...
    SequenceConcat: ClassVar[AssertionExprKind] = ...
    SequenceWithMatch: ClassVar[AssertionExprKind] = ...
    Simple: ClassVar[AssertionExprKind] = ...
    StrongWeak: ClassVar[AssertionExprKind] = ...
    Unary: ClassVar[AssertionExprKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class AssertionInstanceExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self): ...
    @property
    def body(self) -> AssertionExpr: ...
    @property
    def isRecursiveProperty(self) -> bool: ...
    @property
    def localVars(self): ...
    @property
    def symbol(self): ...

class AssertionItemPortListSyntax(SyntaxNode):
    closeParen: Token
    openParen: Token
    ports: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class AssertionItemPortSyntax(SyntaxNode):
    attributes: Incomplete
    defaultValue: EqualsAssertionArgClauseSyntax
    dimensions: Incomplete
    direction: Token
    local: Token
    name: Token
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class AssertionKind:
    __members__: ClassVar[dict] = ...  # read-only
    Assert: ClassVar[AssertionKind] = ...
    Assume: ClassVar[AssertionKind] = ...
    CoverProperty: ClassVar[AssertionKind] = ...
    CoverSequence: ClassVar[AssertionKind] = ...
    Expect: ClassVar[AssertionKind] = ...
    Restrict: ClassVar[AssertionKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class AssertionPortSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def direction(self) -> ArgumentDirection | None: ...
    @property
    def isLocalVar(self) -> bool: ...
    @property
    def type(self): ...

class AssignmentExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isCompound(self) -> bool: ...
    @property
    def isLValueArg(self) -> bool: ...
    @property
    def isNonBlocking(self) -> bool: ...
    @property
    def left(self) -> Expression: ...
    @property
    def op(self) -> BinaryOperator | None: ...
    @property
    def right(self) -> Expression: ...
    @property
    def timingControl(self) -> TimingControl: ...

class AssignmentPatternExpressionBase(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elements(self) -> span[Expression]: ...

class AssignmentPatternExpressionSyntax(PrimaryExpressionSyntax):
    pattern: AssignmentPatternSyntax
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class AssignmentPatternItemSyntax(SyntaxNode):
    colon: Token
    expr: ExpressionSyntax
    key: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class AssignmentPatternSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class AssociativeArrayType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elementType(self) -> Type: ...
    @property
    def indexType(self) -> Type: ...

class AttributeInstanceSyntax(SyntaxNode):
    closeParen: Token
    closeStar: Token
    openParen: Token
    openStar: Token
    specs: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class AttributeSpecSyntax(SyntaxNode):
    name: Token
    value: EqualsValueClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class AttributeSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def value(self) -> ConstantValue: ...

class BadExpressionSyntax(ExpressionSyntax):
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class Bag:
    compilationOptions: CompilationOptions
    lexerOptions: Incomplete
    parserOptions: Incomplete
    preprocessorOptions: Incomplete
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, list: list) -> None: ...

class BeginKeywordsDirectiveSyntax(DirectiveSyntax):
    versionSpecifier: Token
    def __init__(self, *args, **kwargs) -> None: ...

class BinSelectWithFilterExpr(BinsSelectExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> BinsSelectExpr: ...
    @property
    def filter(self): ...
    @property
    def matchesExpr(self): ...

class BinSelectWithFilterExprSyntax(BinsSelectExpressionSyntax):
    closeParen: Token
    expr: BinsSelectExpressionSyntax
    filter: ExpressionSyntax
    matchesClause: MatchesClauseSyntax
    openParen: Token
    with_: Token
    def __init__(self, *args, **kwargs) -> None: ...

class BinaryAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def left(self) -> AssertionExpr: ...
    @property
    def op(self) -> BinaryAssertionOperator: ...
    @property
    def right(self) -> AssertionExpr: ...

class BinaryAssertionOperator:
    __members__: ClassVar[dict] = ...  # read-only
    And: ClassVar[BinaryAssertionOperator] = ...
    Iff: ClassVar[BinaryAssertionOperator] = ...
    Implies: ClassVar[BinaryAssertionOperator] = ...
    Intersect: ClassVar[BinaryAssertionOperator] = ...
    NonOverlappedFollowedBy: ClassVar[BinaryAssertionOperator] = ...
    NonOverlappedImplication: ClassVar[BinaryAssertionOperator] = ...
    Or: ClassVar[BinaryAssertionOperator] = ...
    OverlappedFollowedBy: ClassVar[BinaryAssertionOperator] = ...
    OverlappedImplication: ClassVar[BinaryAssertionOperator] = ...
    SUntil: ClassVar[BinaryAssertionOperator] = ...
    SUntilWith: ClassVar[BinaryAssertionOperator] = ...
    Throughout: ClassVar[BinaryAssertionOperator] = ...
    Until: ClassVar[BinaryAssertionOperator] = ...
    UntilWith: ClassVar[BinaryAssertionOperator] = ...
    Within: ClassVar[BinaryAssertionOperator] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class BinaryBinsSelectExpr(BinsSelectExpr):
    class Op:
        __members__: ClassVar[dict] = ...  # read-only
        And: ClassVar[BinaryBinsSelectExpr.Op] = ...
        Or: ClassVar[BinaryBinsSelectExpr.Op] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    And: ClassVar[BinaryBinsSelectExpr.Op] = ...
    Or: ClassVar[BinaryBinsSelectExpr.Op] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def left(self) -> BinsSelectExpr: ...
    @property
    def op(self): ...
    @property
    def right(self) -> BinsSelectExpr: ...

class BinaryBinsSelectExprSyntax(BinsSelectExpressionSyntax):
    left: BinsSelectExpressionSyntax
    op: Token
    right: BinsSelectExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BinaryBlockEventExpressionSyntax(BlockEventExpressionSyntax):
    left: BlockEventExpressionSyntax
    orKeyword: Token
    right: BlockEventExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BinaryConditionalDirectiveExpressionSyntax(ConditionalDirectiveExpressionSyntax):
    left: ConditionalDirectiveExpressionSyntax
    op: Token
    right: ConditionalDirectiveExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BinaryEventExpressionSyntax(EventExpressionSyntax):
    left: EventExpressionSyntax
    operatorToken: Token
    right: EventExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BinaryExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def left(self) -> Expression: ...
    @property
    def op(self) -> BinaryOperator: ...
    @property
    def right(self) -> Expression: ...

class BinaryExpressionSyntax(ExpressionSyntax):
    attributes: Incomplete
    left: ExpressionSyntax
    operatorToken: Token
    right: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BinaryOperator:
    __members__: ClassVar[dict] = ...  # read-only
    Add: ClassVar[BinaryOperator] = ...
    ArithmeticShiftLeft: ClassVar[BinaryOperator] = ...
    ArithmeticShiftRight: ClassVar[BinaryOperator] = ...
    BinaryAnd: ClassVar[BinaryOperator] = ...
    BinaryOr: ClassVar[BinaryOperator] = ...
    BinaryXnor: ClassVar[BinaryOperator] = ...
    BinaryXor: ClassVar[BinaryOperator] = ...
    CaseEquality: ClassVar[BinaryOperator] = ...
    CaseInequality: ClassVar[BinaryOperator] = ...
    Divide: ClassVar[BinaryOperator] = ...
    Equality: ClassVar[BinaryOperator] = ...
    GreaterThan: ClassVar[BinaryOperator] = ...
    GreaterThanEqual: ClassVar[BinaryOperator] = ...
    Inequality: ClassVar[BinaryOperator] = ...
    LessThan: ClassVar[BinaryOperator] = ...
    LessThanEqual: ClassVar[BinaryOperator] = ...
    LogicalAnd: ClassVar[BinaryOperator] = ...
    LogicalEquivalence: ClassVar[BinaryOperator] = ...
    LogicalImplication: ClassVar[BinaryOperator] = ...
    LogicalOr: ClassVar[BinaryOperator] = ...
    LogicalShiftLeft: ClassVar[BinaryOperator] = ...
    LogicalShiftRight: ClassVar[BinaryOperator] = ...
    Mod: ClassVar[BinaryOperator] = ...
    Multiply: ClassVar[BinaryOperator] = ...
    Power: ClassVar[BinaryOperator] = ...
    Subtract: ClassVar[BinaryOperator] = ...
    WildcardEquality: ClassVar[BinaryOperator] = ...
    WildcardInequality: ClassVar[BinaryOperator] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class BinaryPropertyExprSyntax(PropertyExprSyntax):
    left: PropertyExprSyntax
    op: Token
    right: PropertyExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BinarySequenceExprSyntax(SequenceExprSyntax):
    left: SequenceExprSyntax
    op: Token
    right: SequenceExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BindDirectiveSyntax(MemberSyntax):
    bind: Token
    instantiation: MemberSyntax
    target: NameSyntax
    targetInstances: BindTargetListSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BindTargetListSyntax(SyntaxNode):
    colon: Token
    targets: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class BinsSelectConditionExprSyntax(BinsSelectExpressionSyntax):
    binsof: Token
    closeParen: Token
    intersects: IntersectClauseSyntax
    name: NameSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class BinsSelectExpr:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def bad(self) -> bool: ...
    @property
    def kind(self) -> BinsSelectExprKind: ...
    @property
    def syntax(self): ...

class BinsSelectExprKind:
    __members__: ClassVar[dict] = ...  # read-only
    Binary: ClassVar[BinsSelectExprKind] = ...
    Condition: ClassVar[BinsSelectExprKind] = ...
    CrossId: ClassVar[BinsSelectExprKind] = ...
    Invalid: ClassVar[BinsSelectExprKind] = ...
    SetExpr: ClassVar[BinsSelectExprKind] = ...
    Unary: ClassVar[BinsSelectExprKind] = ...
    WithFilter: ClassVar[BinsSelectExprKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class BinsSelectExpressionSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class BinsSelectionSyntax(MemberSyntax):
    equals: Token
    expr: BinsSelectExpressionSyntax
    iff: CoverageIffClauseSyntax
    keyword: Token
    name: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class BitSelectSyntax(SelectorSyntax):
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BlockCoverageEventSyntax(SyntaxNode):
    atat: Token
    closeParen: Token
    expr: BlockEventExpressionSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class BlockEventExpressionSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class BlockEventListControl(TimingControl):
    class Event:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def isBegin(self) -> bool: ...
        @property
        def target(self): ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def events(self): ...

class BlockStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def blockKind(self) -> StatementBlockKind: ...
    @property
    def blockSymbol(self): ...
    @property
    def body(self) -> Statement: ...

class BlockStatementSyntax(StatementSyntax):
    begin: Token
    blockName: NamedBlockClauseSyntax
    end: Token
    endBlockName: NamedBlockClauseSyntax
    items: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class BreakStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...

class BufferID:
    placeholder: ClassVar[BufferID] = ...  # read-only
    def __init__(self) -> None: ...
    @staticmethod
    def getPlaceholder() -> BufferID: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, arg0: BufferID) -> bool: ...
    def __ge__(self, arg0: BufferID) -> bool: ...
    def __gt__(self, arg0: BufferID) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, arg0: BufferID) -> bool: ...
    def __lt__(self, arg0: BufferID) -> bool: ...
    def __ne__(self, arg0: BufferID) -> bool: ...
    @property
    def id(self) -> int: ...

class BumpAllocator:
    def __init__(self) -> None: ...

class CHandleType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class CallExpression(Expression):
    class IteratorCallInfo:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def iterExpr(self) -> Expression: ...
        @property
        def iterVar(self): ...

    class RandomizeCallInfo:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def constraintRestrictions(self) -> span[str]: ...
        @property
        def inlineConstraints(self) -> Constraint: ...

    class SystemCallInfo:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def extraInfo(self) -> None | CallExpression.IteratorCallInfo | CallExpression.RandomizeCallInfo: ...
        @property
        def scope(self): ...
        @property
        def subroutine(self) -> SystemSubroutine: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self) -> span[Expression]: ...
    @property
    def isSystemCall(self) -> bool: ...
    @property
    def subroutine(self): ...
    @property
    def subroutineKind(self) -> SubroutineKind: ...
    @property
    def subroutineName(self) -> str: ...
    @property
    def thisClass(self) -> Expression: ...

class CaseAssertionExpr(AssertionExpr):
    class ItemGroup:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def body(self) -> AssertionExpr: ...
        @property
        def expressions(self): ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def defaultCase(self) -> AssertionExpr: ...
    @property
    def expr(self): ...
    @property
    def items(self): ...

class CaseGenerateSyntax(MemberSyntax):
    closeParen: Token
    condition: ExpressionSyntax
    endCase: Token
    items: Incomplete
    keyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CaseItemSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class CasePropertyExprSyntax(PropertyExprSyntax):
    caseKeyword: Token
    closeParen: Token
    endcase: Token
    expr: ExpressionSyntax
    items: Incomplete
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CaseStatement(Statement):
    class ItemGroup:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expressions(self) -> span[Expression]: ...
        @property
        def stmt(self) -> Statement: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def check(self) -> UniquePriorityCheck: ...
    @property
    def condition(self) -> CaseStatementCondition: ...
    @property
    def defaultCase(self) -> Statement: ...
    @property
    def expr(self) -> Expression: ...
    @property
    def items(self): ...

class CaseStatementCondition:
    __members__: ClassVar[dict] = ...  # read-only
    Inside: ClassVar[CaseStatementCondition] = ...
    Normal: ClassVar[CaseStatementCondition] = ...
    WildcardJustZ: ClassVar[CaseStatementCondition] = ...
    WildcardXOrZ: ClassVar[CaseStatementCondition] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CaseStatementSyntax(StatementSyntax):
    caseKeyword: Token
    closeParen: Token
    endcase: Token
    expr: ExpressionSyntax
    items: Incomplete
    matchesOrInside: Token
    openParen: Token
    uniqueOrPriority: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CastExpressionSyntax(ExpressionSyntax):
    apostrophe: Token
    left: ExpressionSyntax
    right: ParenthesizedExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class CellConfigRuleSyntax(ConfigRuleSyntax):
    cell: Token
    name: ConfigCellIdentifierSyntax
    ruleClause: ConfigRuleClauseSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ChargeStrengthSyntax(NetStrengthSyntax):
    closeParen: Token
    openParen: Token
    strength: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CheckerDataDeclarationSyntax(MemberSyntax):
    data: DataDeclarationSyntax
    rand: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CheckerDeclarationSyntax(MemberSyntax):
    end: Token
    endBlockName: NamedBlockClauseSyntax
    keyword: Token
    members: Incomplete
    name: Token
    portList: AssertionItemPortListSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CheckerInstanceBodySymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def checker(self): ...
    @property
    def parentInstance(self) -> CheckerInstanceSymbol: ...

class CheckerInstanceStatementSyntax(StatementSyntax):
    instance: CheckerInstantiationSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class CheckerInstanceSymbol(InstanceSymbolBase):
    class Connection:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def actual(self) -> Expression | AssertionExpr | TimingControl: ...
        @property
        def attributes(self) -> span[AttributeSymbol]: ...
        @property
        def formal(self) -> Symbol: ...
        @property
        def outputInitialExpr(self) -> Expression: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self): ...
    @property
    def portConnections(self): ...

class CheckerInstantiationSyntax(MemberSyntax):
    instances: Incomplete
    parameters: ParameterValueAssignmentSyntax
    semi: Token
    type: NameSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class CheckerSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def ports(self) -> span[AssertionPortSymbol]: ...

class ClassDeclarationSyntax(MemberSyntax):
    classKeyword: Token
    endBlockName: NamedBlockClauseSyntax
    endClass: Token
    extendsClause: ExtendsClauseSyntax
    finalSpecifier: ClassSpecifierSyntax
    implementsClause: ImplementsClauseSyntax
    items: Incomplete
    name: Token
    parameters: ParameterPortListSyntax
    semi: Token
    virtualOrInterface: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ClassMethodDeclarationSyntax(MemberSyntax):
    declaration: FunctionDeclarationSyntax
    qualifiers: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ClassMethodPrototypeSyntax(MemberSyntax):
    prototype: FunctionPrototypeSyntax
    qualifiers: Incomplete
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ClassNameSyntax(NameSyntax):
    identifier: Token
    parameters: ParameterValueAssignmentSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ClassPropertyDeclarationSyntax(MemberSyntax):
    declaration: MemberSyntax
    qualifiers: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ClassPropertySymbol(VariableSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def randMode(self) -> RandMode: ...
    @property
    def visibility(self) -> Visibility: ...

class ClassSpecifierSyntax(SyntaxNode):
    colon: Token
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ClassType(Type, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def baseClass(self) -> Type: ...
    @property
    def baseConstructorCall(self) -> Expression: ...
    @property
    def constructor(self) -> SubroutineSymbol: ...
    @property
    def firstForwardDecl(self) -> ForwardingTypedefSymbol: ...
    @property
    def genericClass(self): ...
    @property
    def implementedInterfaces(self) -> span[Type]: ...
    @property
    def isAbstract(self) -> bool: ...
    @property
    def isFinal(self) -> bool: ...
    @property
    def isInterface(self) -> bool: ...

class ClockVarSymbol(VariableSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def direction(self) -> ArgumentDirection: ...
    @property
    def inputSkew(self) -> ClockingSkew: ...
    @property
    def outputSkew(self) -> ClockingSkew: ...

class ClockingAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def clocking(self) -> TimingControl: ...
    @property
    def expr(self) -> AssertionExpr: ...

class ClockingBlockSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def defaultInputSkew(self) -> ClockingSkew: ...
    @property
    def defaultOutputSkew(self) -> ClockingSkew: ...
    @property
    def event(self) -> TimingControl: ...

class ClockingDeclarationSyntax(MemberSyntax):
    at: Token
    blockName: Token
    clocking: Token
    endBlockName: NamedBlockClauseSyntax
    endClocking: Token
    event: EventExpressionSyntax
    globalOrDefault: Token
    items: Incomplete
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ClockingDirectionSyntax(SyntaxNode):
    input: Token
    inputSkew: ClockingSkewSyntax
    output: Token
    outputSkew: ClockingSkewSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ClockingEventExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def timingControl(self) -> TimingControl: ...

class ClockingItemSyntax(MemberSyntax):
    decls: Incomplete
    direction: ClockingDirectionSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ClockingPropertyExprSyntax(PropertyExprSyntax):
    event: TimingControlSyntax
    expr: PropertyExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ClockingSequenceExprSyntax(SequenceExprSyntax):
    event: TimingControlSyntax
    expr: SequenceExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ClockingSkew:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def delay(self) -> TimingControl: ...
    @property
    def edge(self) -> EdgeKind: ...
    @property
    def hasValue(self) -> bool: ...

class ClockingSkewSyntax(SyntaxNode):
    delay: TimingControlSyntax
    edge: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ColonExpressionClauseSyntax(SyntaxNode):
    colon: Token
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class CommandLineOptions:
    expandEnvVars: bool
    ignoreDuplicates: bool
    ignoreProgramName: bool
    supportsComments: bool
    def __init__(self) -> None: ...

class Compilation:
    class DefinitionLookupResult:
        configRoot: Incomplete
        configRule: Incomplete
        definition: Incomplete
        def __init__(self) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, options) -> None: ...
    def addDiagnostics(self, diagnostics) -> None: ...
    def addSyntaxTree(self, tree) -> None: ...
    def addSystemMethod(self, typeKind, method) -> None: ...
    def addSystemSubroutine(self, subroutine) -> None: ...
    def createScriptScope(self, *args, **kwargs): ...
    def getAllDiagnostics(self, *args, **kwargs): ...
    def getAttributes(self, *args, **kwargs): ...
    def getCompilationUnit(self, *args, **kwargs): ...
    def getCompilationUnits(self, *args, **kwargs): ...
    def getDefinitions(self, *args, **kwargs): ...
    def getGateType(self, *args, **kwargs): ...
    def getNetType(self, *args, **kwargs): ...
    def getPackage(self, *args, **kwargs): ...
    def getPackages(self, *args, **kwargs): ...
    def getParseDiagnostics(self, *args, **kwargs): ...
    def getRoot(self, *args, **kwargs): ...
    def getSemanticDiagnostics(self, *args, **kwargs): ...
    def getSourceLibrary(self, *args, **kwargs): ...
    def getStdPackage(self, *args, **kwargs): ...
    def getSyntaxTrees(self, *args, **kwargs): ...
    def getSystemMethod(self, *args, **kwargs): ...
    def getSystemSubroutine(self, *args, **kwargs): ...
    def getType(self, *args, **kwargs): ...
    def parseName(self, *args, **kwargs): ...
    def tryGetDefinition(self, *args, **kwargs): ...
    def tryParseName(self, *args, **kwargs): ...
    @property
    def bitType(self): ...
    @property
    def byteType(self): ...
    @property
    def defaultLibrary(self): ...
    @property
    def defaultTimeScale(self): ...
    @property
    def errorType(self): ...
    @property
    def hasFatalErrors(self) -> bool: ...
    @property
    def hasIssuedErrors(self) -> bool: ...
    @property
    def intType(self): ...
    @property
    def integerType(self): ...
    @property
    def isElaborated(self) -> bool: ...
    @property
    def isFinalized(self) -> bool: ...
    @property
    def logicType(self): ...
    @property
    def nullType(self): ...
    @property
    def options(self) -> CompilationOptions: ...
    @property
    def realType(self): ...
    @property
    def shortRealType(self): ...
    @property
    def sourceManager(self): ...
    @property
    def stringType(self): ...
    @property
    def typeRefType(self): ...
    @property
    def unboundedType(self): ...
    @property
    def unsignedIntType(self): ...
    @property
    def voidType(self): ...
    @property
    def wireNetType(self): ...

class CompilationFlags:
    __members__: ClassVar[dict] = ...  # read-only
    AllowBareValParamAssignment: ClassVar[CompilationFlags] = ...
    AllowHierarchicalConst: ClassVar[CompilationFlags] = ...
    AllowMergingAnsiPorts: ClassVar[CompilationFlags] = ...
    AllowRecursiveImplicitCall: ClassVar[CompilationFlags] = ...
    AllowSelfDeterminedStreamConcat: ClassVar[CompilationFlags] = ...
    AllowTopLevelIfacePorts: ClassVar[CompilationFlags] = ...
    AllowUseBeforeDeclare: ClassVar[CompilationFlags] = ...
    DisableInstanceCaching: ClassVar[CompilationFlags] = ...
    DisallowRefsToUnknownInstances: ClassVar[CompilationFlags] = ...
    IgnoreUnknownModules: ClassVar[CompilationFlags] = ...
    LintMode: ClassVar[CompilationFlags] = ...
    None_: ClassVar[CompilationFlags] = ...
    RelaxEnumConversions: ClassVar[CompilationFlags] = ...
    RelaxStringConversions: ClassVar[CompilationFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CompilationOptions:
    defaultLiblist: list[str]
    defaultTimeScale: Incomplete
    errorLimit: int
    flags: CompilationFlags
    languageVersion: Incomplete
    maxConstexprBacktrace: int
    maxConstexprDepth: int
    maxConstexprSteps: int
    maxDefParamSteps: int
    maxGenerateSteps: int
    maxInstanceArray: int
    maxInstanceDepth: int
    minTypMax: MinTypMax
    paramOverrides: list[str]
    topModules: set[str]
    typoCorrectionLimit: int
    def __init__(self) -> None: ...

class CompilationUnitSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def timeScale(self) -> TimeScale | None: ...

class CompilationUnitSyntax(SyntaxNode):
    endOfFile: Token
    members: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ConcatenationExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def operands(self) -> span[Expression]: ...

class ConcatenationExpressionSyntax(PrimaryExpressionSyntax):
    closeBrace: Token
    expressions: Incomplete
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConcurrentAssertionMemberSyntax(MemberSyntax):
    statement: ConcurrentAssertionStatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ConcurrentAssertionStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def assertionKind(self) -> AssertionKind: ...
    @property
    def ifFalse(self) -> Statement: ...
    @property
    def ifTrue(self) -> Statement: ...
    @property
    def propertySpec(self) -> AssertionExpr: ...

class ConcurrentAssertionStatementSyntax(StatementSyntax):
    action: ActionBlockSyntax
    closeParen: Token
    keyword: Token
    openParen: Token
    propertyOrSequence: Token
    propertySpec: PropertySpecSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionBinsSelectExpr(BinsSelectExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def intersects(self): ...
    @property
    def target(self): ...

class ConditionalAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def condition(self): ...
    @property
    def elseExpr(self) -> AssertionExpr: ...
    @property
    def ifExpr(self) -> AssertionExpr: ...

class ConditionalBranchDirectiveSyntax(DirectiveSyntax):
    disabledTokens: Incomplete
    expr: ConditionalDirectiveExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elseBody(self) -> Constraint: ...
    @property
    def ifBody(self) -> Constraint: ...
    @property
    def predicate(self): ...

class ConditionalConstraintSyntax(ConstraintItemSyntax):
    closeParen: Token
    condition: ExpressionSyntax
    constraints: ConstraintItemSyntax
    elseClause: ElseConstraintClauseSyntax
    ifKeyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalDirectiveExpressionSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalExpression(Expression):
    class Condition:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def pattern(self) -> Pattern: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def conditions(self): ...
    @property
    def left(self) -> Expression: ...
    @property
    def right(self) -> Expression: ...

class ConditionalExpressionSyntax(ExpressionSyntax):
    attributes: Incomplete
    colon: Token
    left: ExpressionSyntax
    predicate: ConditionalPredicateSyntax
    question: Token
    right: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalPathDeclarationSyntax(MemberSyntax):
    closeParen: Token
    keyword: Token
    openParen: Token
    path: PathDeclarationSyntax
    predicate: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalPatternSyntax(SyntaxNode):
    expr: ExpressionSyntax
    matchesClause: MatchesClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalPredicateSyntax(SyntaxNode):
    conditions: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalPropertyExprSyntax(PropertyExprSyntax):
    closeParen: Token
    condition: ExpressionSyntax
    elseClause: ElsePropertyClauseSyntax
    expr: PropertyExprSyntax
    ifKeyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalStatement(Statement):
    class Condition:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def pattern(self) -> Pattern: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def check(self) -> UniquePriorityCheck: ...
    @property
    def conditions(self): ...
    @property
    def ifFalse(self) -> Statement: ...
    @property
    def ifTrue(self) -> Statement: ...

class ConditionalStatementSyntax(StatementSyntax):
    closeParen: Token
    elseClause: ElseClauseSyntax
    ifKeyword: Token
    openParen: Token
    predicate: ConditionalPredicateSyntax
    statement: StatementSyntax
    uniqueOrPriority: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigBlockSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigCellIdentifierSyntax(SyntaxNode):
    cell: Token
    dot: Token
    library: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigDeclarationSyntax(MemberSyntax):
    blockName: NamedBlockClauseSyntax
    config: Token
    design: Token
    endconfig: Token
    localparams: Incomplete
    name: Token
    rules: Incomplete
    semi1: Token
    semi2: Token
    topCells: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigInstanceIdentifierSyntax(SyntaxNode):
    dot: Token
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigLiblistSyntax(ConfigRuleClauseSyntax):
    liblist: Token
    libraries: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigRuleClauseSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigRuleSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigUseClauseSyntax(ConfigRuleClauseSyntax):
    colon: Token
    config: Token
    name: ConfigCellIdentifierSyntax
    paramAssignments: ParameterValueAssignmentSyntax
    use: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConstantPattern(Pattern):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self): ...

class ConstantRange:
    left: int
    right: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, left: int, right: int) -> None: ...
    def containsPoint(self, arg0: int) -> bool: ...
    def getIndexedRange(self, arg0: int, arg1: bool, arg2: bool) -> ConstantRange | None: ...
    def overlaps(self, arg0: ConstantRange) -> bool: ...
    def reverse(self) -> ConstantRange: ...
    def subrange(self, arg0: ConstantRange) -> ConstantRange: ...
    def translateIndex(self, arg0: int) -> int: ...
    def __eq__(self, arg0: ConstantRange) -> bool: ...
    def __ne__(self, arg0: ConstantRange) -> bool: ...
    @property
    def isLittleEndian(self) -> bool: ...
    @property
    def lower(self) -> int: ...
    @property
    def upper(self) -> int: ...
    @property
    def width(self) -> int: ...

class ConstantValue:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, integer: SVInt) -> None: ...
    @overload
    def __init__(self, str: str) -> None: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, value: float) -> None: ...
    def bitstreamWidth(self) -> int: ...
    def convertToByteArray(self, size: int, isSigned: bool) -> ConstantValue: ...
    def convertToByteQueue(self, isSigned: bool) -> ConstantValue: ...
    @overload
    def convertToInt(self) -> ConstantValue: ...
    @overload
    def convertToInt(self, width: int, isSigned: bool, isFourState: bool) -> ConstantValue: ...
    def convertToReal(self) -> ConstantValue: ...
    def convertToShortReal(self) -> ConstantValue: ...
    def convertToStr(self) -> ConstantValue: ...
    def empty(self) -> bool: ...
    def getSlice(self, upper: int, lower: int, defaultValue: ConstantValue) -> ConstantValue: ...
    def hasUnknown(self) -> bool: ...
    def isContainer(self) -> bool: ...
    def isFalse(self) -> bool: ...
    def isTrue(self) -> bool: ...
    def size(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, arg0: ConstantValue) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: ConstantValue) -> bool: ...
    @property
    def value(self) -> object: ...

class Constraint:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def bad(self) -> bool: ...
    @property
    def kind(self) -> ConstraintKind: ...
    @property
    def syntax(self): ...

class ConstraintBlockFlags:
    __members__: ClassVar[dict] = ...  # read-only
    ExplicitExtern: ClassVar[ConstraintBlockFlags] = ...
    Extends: ClassVar[ConstraintBlockFlags] = ...
    Extern: ClassVar[ConstraintBlockFlags] = ...
    Final: ClassVar[ConstraintBlockFlags] = ...
    Initial: ClassVar[ConstraintBlockFlags] = ...
    None_: ClassVar[ConstraintBlockFlags] = ...
    Pure: ClassVar[ConstraintBlockFlags] = ...
    Static: ClassVar[ConstraintBlockFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ConstraintBlockSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def constraints(self) -> Constraint: ...
    @property
    def flags(self) -> ConstraintBlockFlags: ...
    @property
    def thisVar(self) -> VariableSymbol: ...

class ConstraintBlockSyntax(ConstraintItemSyntax):
    closeBrace: Token
    items: Incomplete
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConstraintDeclarationSyntax(MemberSyntax):
    block: ConstraintBlockSyntax
    keyword: Token
    name: NameSyntax
    qualifiers: Incomplete
    specifiers: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ConstraintItemSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ConstraintKind:
    __members__: ClassVar[dict] = ...  # read-only
    Conditional: ClassVar[ConstraintKind] = ...
    DisableSoft: ClassVar[ConstraintKind] = ...
    Expression: ClassVar[ConstraintKind] = ...
    Foreach: ClassVar[ConstraintKind] = ...
    Implication: ClassVar[ConstraintKind] = ...
    Invalid: ClassVar[ConstraintKind] = ...
    List: ClassVar[ConstraintKind] = ...
    SolveBefore: ClassVar[ConstraintKind] = ...
    Uniqueness: ClassVar[ConstraintKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ConstraintList(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def list(self) -> span[Constraint]: ...

class ConstraintPrototypeSyntax(MemberSyntax):
    keyword: Token
    name: NameSyntax
    qualifiers: Incomplete
    semi: Token
    specifiers: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ContinueStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...

class ContinuousAssignSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def assignment(self) -> Expression: ...
    @property
    def delay(self) -> TimingControl: ...
    @property
    def driveStrength(self): ...

class ContinuousAssignSyntax(MemberSyntax):
    assign: Token
    assignments: Incomplete
    delay: TimingControlSyntax
    semi: Token
    strength: DriveStrengthSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ConversionExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def conversionKind(self) -> ConversionKind: ...
    @property
    def isImplicit(self) -> bool: ...
    @property
    def operand(self) -> Expression: ...

class ConversionKind:
    __members__: ClassVar[dict] = ...  # read-only
    BitstreamCast: ClassVar[ConversionKind] = ...
    Explicit: ClassVar[ConversionKind] = ...
    Implicit: ClassVar[ConversionKind] = ...
    Propagated: ClassVar[ConversionKind] = ...
    StreamingConcat: ClassVar[ConversionKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CopyClassExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def sourceExpr(self) -> Expression: ...

class CopyClassExpressionSyntax(ExpressionSyntax):
    expr: ExpressionSyntax
    scopedNew: NameSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class CoverCrossBodySymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def crossQueueType(self): ...

class CoverCrossSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def iffExpr(self) -> Expression: ...
    @property
    def options(self) -> span[CoverageOptionSetter]: ...
    @property
    def targets(self) -> span[CoverpointSymbol]: ...

class CoverCrossSyntax(MemberSyntax):
    closeBrace: Token
    cross: Token
    emptySemi: Token
    iff: CoverageIffClauseSyntax
    items: Incomplete
    label: NamedLabelSyntax
    members: Incomplete
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CoverageBinInitializerSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class CoverageBinSymbol(Symbol):
    class BinKind:
        __members__: ClassVar[dict] = ...  # read-only
        Bins: ClassVar[CoverageBinSymbol.BinKind] = ...
        IgnoreBins: ClassVar[CoverageBinSymbol.BinKind] = ...
        IllegalBins: ClassVar[CoverageBinSymbol.BinKind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class TransRangeList:
        class RepeatKind:
            __members__: ClassVar[dict] = ...  # read-only
            Consecutive: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
            GoTo: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
            Nonconsecutive: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
            None_: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        Consecutive: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
        GoTo: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
        Nonconsecutive: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
        None_: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def items(self) -> span[Expression]: ...
        @property
        def repeatFrom(self) -> Expression: ...
        @property
        def repeatKind(self): ...
        @property
        def repeatTo(self) -> Expression: ...
    Bins: ClassVar[CoverageBinSymbol.BinKind] = ...
    IgnoreBins: ClassVar[CoverageBinSymbol.BinKind] = ...
    IllegalBins: ClassVar[CoverageBinSymbol.BinKind] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def binsKind(self): ...
    @property
    def crossSelectExpr(self) -> BinsSelectExpr: ...
    @property
    def iffExpr(self) -> Expression: ...
    @property
    def isArray(self) -> bool: ...
    @property
    def isDefault(self) -> bool: ...
    @property
    def isDefaultSequence(self) -> bool: ...
    @property
    def isWildcard(self) -> bool: ...
    @property
    def numberOfBinsExpr(self) -> Expression: ...
    @property
    def setCoverageExpr(self) -> Expression: ...
    @property
    def values(self) -> span[Expression]: ...
    @property
    def withExpr(self) -> Expression: ...

class CoverageBinsArraySizeSyntax(SyntaxNode):
    closeBracket: Token
    expr: ExpressionSyntax
    openBracket: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CoverageBinsSyntax(MemberSyntax):
    equals: Token
    iff: CoverageIffClauseSyntax
    initializer: CoverageBinInitializerSyntax
    keyword: Token
    name: Token
    semi: Token
    size: CoverageBinsArraySizeSyntax
    wildcard: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CoverageIffClauseSyntax(SyntaxNode):
    closeParen: Token
    expr: ExpressionSyntax
    iff: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CoverageOptionSetter:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expression(self) -> Expression: ...
    @property
    def isTypeOption(self) -> bool: ...
    @property
    def name(self) -> str: ...

class CoverageOptionSyntax(MemberSyntax):
    expr: ExpressionSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CovergroupBodySymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def options(self) -> span[CoverageOptionSetter]: ...

class CovergroupDeclarationSyntax(MemberSyntax):
    covergroup: Token
    endBlockName: NamedBlockClauseSyntax
    endgroup: Token
    event: SyntaxNode
    extends: Token
    members: Incomplete
    name: Token
    portList: FunctionPortListSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CovergroupType(Type, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self) -> span[FormalArgumentSymbol]: ...
    @property
    def baseGroup(self) -> Type: ...
    @property
    def body(self) -> CovergroupBodySymbol: ...
    @property
    def coverageEvent(self) -> TimingControl: ...

class CoverpointSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def coverageExpr(self) -> Expression: ...
    @property
    def iffExpr(self) -> Expression: ...
    @property
    def options(self) -> span[CoverageOptionSetter]: ...
    @property
    def type(self): ...

class CoverpointSyntax(MemberSyntax):
    closeBrace: Token
    coverpoint: Token
    emptySemi: Token
    expr: ExpressionSyntax
    iff: CoverageIffClauseSyntax
    label: NamedLabelSyntax
    members: Incomplete
    openBrace: Token
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class CrossIdBinsSelectExpr(BinsSelectExpr):
    def __init__(self, *args, **kwargs) -> None: ...

class CycleDelayControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self): ...

class DPIExportSyntax(MemberSyntax):
    c_identifier: Token
    equals: Token
    functionOrTask: Token
    keyword: Token
    name: Token
    semi: Token
    specString: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DPIImportSyntax(MemberSyntax):
    c_identifier: Token
    equals: Token
    keyword: Token
    method: FunctionPrototypeSyntax
    property: Token
    semi: Token
    specString: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DPIOpenArrayType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elementType(self) -> Type: ...
    @property
    def isPacked(self) -> bool: ...

class DataDeclarationSyntax(MemberSyntax):
    declarators: Incomplete
    modifiers: Incomplete
    semi: Token
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class DataTypeExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...

class DataTypeSyntax(ExpressionSyntax):
    def __init__(self, *args, **kwargs) -> None: ...

class DeclaratorSyntax(SyntaxNode):
    dimensions: Incomplete
    initializer: EqualsValueClauseSyntax
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DeclaredType:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def initializer(self) -> Expression: ...
    @property
    def initializerLocation(self) -> SourceLocation: ...
    @property
    def initializerSyntax(self) -> ExpressionSyntax: ...
    @property
    def isEvaluating(self) -> bool: ...
    @property
    def type(self) -> Type: ...
    @property
    def typeSyntax(self) -> DataTypeSyntax: ...

class DefParamAssignmentSyntax(SyntaxNode):
    name: NameSyntax
    setter: EqualsValueClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class DefParamSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def initializer(self) -> Expression: ...
    @property
    def target(self) -> Symbol: ...
    @property
    def value(self) -> ConstantValue: ...

class DefParamSyntax(MemberSyntax):
    assignments: Incomplete
    defparam: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultCaseItemSyntax(CaseItemSyntax):
    clause: SyntaxNode
    colon: Token
    defaultKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultClockingReferenceSyntax(MemberSyntax):
    clocking: Token
    defaultKeyword: Token
    name: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultConfigRuleSyntax(ConfigRuleSyntax):
    defaultKeyword: Token
    liblist: ConfigLiblistSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultCoverageBinInitializerSyntax(CoverageBinInitializerSyntax):
    defaultKeyword: Token
    sequenceKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultDecayTimeDirectiveSyntax(DirectiveSyntax):
    time: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultDisableDeclarationSyntax(MemberSyntax):
    defaultKeyword: Token
    disableKeyword: Token
    expr: ExpressionSyntax
    iffKeyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultDistItemSyntax(DistItemBaseSyntax):
    defaultKeyword: Token
    weight: DistWeightSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultExtendsClauseArgSyntax(SyntaxNode):
    closeParen: Token
    defaultKeyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultFunctionPortSyntax(FunctionPortBaseSyntax):
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultNetTypeDirectiveSyntax(DirectiveSyntax):
    netType: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultPropertyCaseItemSyntax(PropertyCaseItemSyntax):
    colon: Token
    defaultKeyword: Token
    expr: PropertyExprSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultRsCaseItemSyntax(RsCaseItemSyntax):
    colon: Token
    defaultKeyword: Token
    item: RsProdItemSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultSkewItemSyntax(MemberSyntax):
    direction: ClockingDirectionSyntax
    keyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultTriregStrengthDirectiveSyntax(DirectiveSyntax):
    strength: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DeferredAssertionSyntax(SyntaxNode):
    finalKeyword: Token
    hash: Token
    zero: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefineDirectiveSyntax(DirectiveSyntax):
    body: Incomplete
    formalArguments: MacroFormalArgumentListSyntax
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefinitionKind:
    __members__: ClassVar[dict] = ...  # read-only
    Interface: ClassVar[DefinitionKind] = ...
    Module: ClassVar[DefinitionKind] = ...
    Program: ClassVar[DefinitionKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class DefinitionSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    def getArticleKindString(self) -> str: ...
    def getKindString(self) -> str: ...
    @property
    def cellDefine(self) -> bool: ...
    @property
    def defaultLifetime(self) -> VariableLifetime: ...
    @property
    def defaultNetType(self): ...
    @property
    def definitionKind(self) -> DefinitionKind: ...
    @property
    def instanceCount(self) -> int: ...
    @property
    def timeScale(self) -> TimeScale | None: ...
    @property
    def unconnectedDrive(self) -> UnconnectedDrive: ...

class Delay3Control(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr1(self): ...
    @property
    def expr2(self): ...
    @property
    def expr3(self): ...

class Delay3Syntax(TimingControlSyntax):
    closeParen: Token
    comma1: Token
    comma2: Token
    delay1: ExpressionSyntax
    delay2: ExpressionSyntax
    delay3: ExpressionSyntax
    hash: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DelayControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self): ...

class DelaySyntax(TimingControlSyntax):
    delayValue: ExpressionSyntax
    hash: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DelayedSequenceElementSyntax(SyntaxNode):
    closeBracket: Token
    delayVal: ExpressionSyntax
    doubleHash: Token
    expr: SequenceExprSyntax
    op: Token
    openBracket: Token
    range: SelectorSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class DelayedSequenceExprSyntax(SequenceExprSyntax):
    elements: Incomplete
    first: SequenceExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class DiagCode:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, subsystem: DiagSubsystem, code: int) -> None: ...
    def getCode(self) -> int: ...
    def getSubsystem(self) -> DiagSubsystem: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, arg0: DiagCode) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: DiagCode) -> bool: ...

class DiagGroup:
    def __init__(self, name: str, diags: list[DiagCode]) -> None: ...
    def getDiags(self) -> span[DiagCode]: ...
    def getName(self) -> str: ...

class DiagSubsystem:
    __members__: ClassVar[dict] = ...  # read-only
    Analysis: ClassVar[DiagSubsystem] = ...
    Compilation: ClassVar[DiagSubsystem] = ...
    ConstEval: ClassVar[DiagSubsystem] = ...
    Declarations: ClassVar[DiagSubsystem] = ...
    Expressions: ClassVar[DiagSubsystem] = ...
    General: ClassVar[DiagSubsystem] = ...
    Invalid: ClassVar[DiagSubsystem] = ...
    Lexer: ClassVar[DiagSubsystem] = ...
    Lookup: ClassVar[DiagSubsystem] = ...
    Meta: ClassVar[DiagSubsystem] = ...
    Netlist: ClassVar[DiagSubsystem] = ...
    Numeric: ClassVar[DiagSubsystem] = ...
    Parser: ClassVar[DiagSubsystem] = ...
    Preprocessor: ClassVar[DiagSubsystem] = ...
    Statements: ClassVar[DiagSubsystem] = ...
    SysFuncs: ClassVar[DiagSubsystem] = ...
    Tidy: ClassVar[DiagSubsystem] = ...
    Types: ClassVar[DiagSubsystem] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Diagnostic:
    def __init__(self, code: DiagCode, location: SourceLocation) -> None: ...
    def isError(self) -> bool: ...
    def __eq__(self, arg0: Diagnostic) -> bool: ...
    def __ne__(self, arg0: Diagnostic) -> bool: ...
    @property
    def args(self): ...
    @property
    def code(self) -> DiagCode: ...
    @property
    def location(self) -> SourceLocation: ...
    @property
    def ranges(self) -> list[SourceRange]: ...
    @property
    def symbol(self): ...

class DiagnosticClient:
    def __init__(self, *args, **kwargs) -> None: ...
    def report(self, diagnostic: ReportedDiagnostic) -> None: ...
    def setEngine(self, engine: DiagnosticEngine) -> None: ...
    def showAbsPaths(self, show: bool) -> None: ...

class DiagnosticEngine:
    def __init__(self, sourceManager: SourceManager) -> None: ...
    def addClient(self, client) -> None: ...
    def clearClients(self) -> None: ...
    def clearCounts(self) -> None: ...
    @overload
    def clearMappings(self) -> None: ...
    @overload
    def clearMappings(self, severity: DiagnosticSeverity) -> None: ...
    def findDiagGroup(self, name: str) -> DiagGroup: ...
    def findFromOptionName(self, optionName: str) -> span[DiagCode]: ...
    def formatMessage(self, diag: Diagnostic) -> str: ...
    def getMessage(self, code: DiagCode) -> str: ...
    def getOptionName(self, code: DiagCode) -> str: ...
    def getSeverity(self, code: DiagCode, location: SourceLocation) -> DiagnosticSeverity: ...
    def issue(self, diagnostic: Diagnostic) -> None: ...
    @staticmethod
    def reportAll(sourceManager: SourceManager, diag: span[Diagnostic]) -> str: ...
    def setErrorLimit(self, limit: int) -> None: ...
    def setErrorsAsFatal(self, set: bool) -> None: ...
    def setFatalsAsErrors(self, set: bool) -> None: ...
    def setIgnoreAllNotes(self, set: bool) -> None: ...
    def setIgnoreAllWarnings(self, set: bool) -> None: ...
    @overload
    def setMappingsFromPragmas(self) -> Diagnostics: ...
    @overload
    def setMappingsFromPragmas(self, buffer: BufferID) -> Diagnostics: ...
    def setMessage(self, code: DiagCode, message: str) -> None: ...
    def setSeverity(self, code: DiagCode, severity: DiagnosticSeverity) -> None: ...
    def setWarningOptions(self, options: span[str]) -> Diagnostics: ...
    def setWarningsAsErrors(self, set: bool) -> None: ...
    @property
    def numErrors(self) -> int: ...
    @property
    def numWarnings(self) -> int: ...
    @property
    def sourceManager(self) -> SourceManager: ...

class DiagnosticSeverity:
    __members__: ClassVar[dict] = ...  # read-only
    Error: ClassVar[DiagnosticSeverity] = ...
    Fatal: ClassVar[DiagnosticSeverity] = ...
    Ignored: ClassVar[DiagnosticSeverity] = ...
    Note: ClassVar[DiagnosticSeverity] = ...
    Warning: ClassVar[DiagnosticSeverity] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Diagnostics:
    def __init__(self) -> None: ...
    @overload
    def add(self, code: DiagCode, location: SourceLocation) -> Diagnostic: ...
    @overload
    def add(self, code: DiagCode, range: SourceRange) -> Diagnostic: ...
    @overload
    def add(self, source, code: DiagCode, location: SourceLocation) -> Diagnostic: ...
    @overload
    def add(self, source, code: DiagCode, range: SourceRange) -> Diagnostic: ...
    def sort(self, sourceManager: SourceManager) -> None: ...
    def __getitem__(self, arg0: int) -> Diagnostic: ...
    def __iter__(self) -> Iterator[Diagnostic]: ...
    def __len__(self) -> int: ...

class Diags:
    AlwaysFFEventControl: ClassVar[DiagCode] = ...  # read-only
    AlwaysInChecker: ClassVar[DiagCode] = ...  # read-only
    AlwaysWithoutTimingControl: ClassVar[DiagCode] = ...  # read-only
    AmbiguousWildcardImport: ClassVar[DiagCode] = ...  # read-only
    AnsiIfacePortDefault: ClassVar[DiagCode] = ...  # read-only
    ArgCannotBeEmpty: ClassVar[DiagCode] = ...  # read-only
    ArgDoesNotExist: ClassVar[DiagCode] = ...  # read-only
    ArithInShift: ClassVar[DiagCode] = ...  # read-only
    ArithOpMismatch: ClassVar[DiagCode] = ...  # read-only
    ArrayDimTooLarge: ClassVar[DiagCode] = ...  # read-only
    ArrayLocatorWithClause: ClassVar[DiagCode] = ...  # read-only
    ArrayMethodComparable: ClassVar[DiagCode] = ...  # read-only
    ArrayMethodIntegral: ClassVar[DiagCode] = ...  # read-only
    AssertionArgNeedsRegExpr: ClassVar[DiagCode] = ...  # read-only
    AssertionArgTypeMismatch: ClassVar[DiagCode] = ...  # read-only
    AssertionArgTypeSequence: ClassVar[DiagCode] = ...  # read-only
    AssertionDelayFormalType: ClassVar[DiagCode] = ...  # read-only
    AssertionExprType: ClassVar[DiagCode] = ...  # read-only
    AssertionFuncArg: ClassVar[DiagCode] = ...  # read-only
    AssertionNoClock: ClassVar[DiagCode] = ...  # read-only
    AssertionOutputLocalVar: ClassVar[DiagCode] = ...  # read-only
    AssertionPortDirNoLocal: ClassVar[DiagCode] = ...  # read-only
    AssertionPortOutputDefault: ClassVar[DiagCode] = ...  # read-only
    AssertionPortPropOutput: ClassVar[DiagCode] = ...  # read-only
    AssertionPortRef: ClassVar[DiagCode] = ...  # read-only
    AssertionPortTypedLValue: ClassVar[DiagCode] = ...  # read-only
    AssignToCHandle: ClassVar[DiagCode] = ...  # read-only
    AssignToNet: ClassVar[DiagCode] = ...  # read-only
    AssignedToLocalBodyParam: ClassVar[DiagCode] = ...  # read-only
    AssignedToLocalPortParam: ClassVar[DiagCode] = ...  # read-only
    AssignmentNotAllowed: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternAssociativeType: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternDynamicDefault: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternDynamicType: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternKeyDupDefault: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternKeyDupName: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternKeyDupValue: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternKeyExpr: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternLValueDynamic: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternMissingElements: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternNoContext: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternNoMember: ClassVar[DiagCode] = ...  # read-only
    AssignmentRequiresParens: ClassVar[DiagCode] = ...  # read-only
    AssignmentToConstVar: ClassVar[DiagCode] = ...  # read-only
    AssociativeWildcardNotAllowed: ClassVar[DiagCode] = ...  # read-only
    AttributesNotAllowed: ClassVar[DiagCode] = ...  # read-only
    AutoFromNonBlockingTiming: ClassVar[DiagCode] = ...  # read-only
    AutoFromNonProcedural: ClassVar[DiagCode] = ...  # read-only
    AutoFromStaticInit: ClassVar[DiagCode] = ...  # read-only
    AutoVarToRefStatic: ClassVar[DiagCode] = ...  # read-only
    AutoVarTraced: ClassVar[DiagCode] = ...  # read-only
    AutoVariableHierarchical: ClassVar[DiagCode] = ...  # read-only
    AutomaticNotAllowed: ClassVar[DiagCode] = ...  # read-only
    BadAssignment: ClassVar[DiagCode] = ...  # read-only
    BadAssignmentPatternType: ClassVar[DiagCode] = ...  # read-only
    BadBinaryDigit: ClassVar[DiagCode] = ...  # read-only
    BadBinaryExpression: ClassVar[DiagCode] = ...  # read-only
    BadCastType: ClassVar[DiagCode] = ...  # read-only
    BadConcatExpression: ClassVar[DiagCode] = ...  # read-only
    BadConditionalExpression: ClassVar[DiagCode] = ...  # read-only
    BadConversion: ClassVar[DiagCode] = ...  # read-only
    BadDecimalDigit: ClassVar[DiagCode] = ...  # read-only
    BadDisableSoft: ClassVar[DiagCode] = ...  # read-only
    BadFinishNum: ClassVar[DiagCode] = ...  # read-only
    BadForceNetType: ClassVar[DiagCode] = ...  # read-only
    BadHexDigit: ClassVar[DiagCode] = ...  # read-only
    BadIndexExpression: ClassVar[DiagCode] = ...  # read-only
    BadInstanceArrayRange: ClassVar[DiagCode] = ...  # read-only
    BadIntegerCast: ClassVar[DiagCode] = ...  # read-only
    BadOctalDigit: ClassVar[DiagCode] = ...  # read-only
    BadProceduralAssign: ClassVar[DiagCode] = ...  # read-only
    BadProceduralForce: ClassVar[DiagCode] = ...  # read-only
    BadReplicationExpression: ClassVar[DiagCode] = ...  # read-only
    BadSetMembershipType: ClassVar[DiagCode] = ...  # read-only
    BadSliceType: ClassVar[DiagCode] = ...  # read-only
    BadSolveBefore: ClassVar[DiagCode] = ...  # read-only
    BadStreamCast: ClassVar[DiagCode] = ...  # read-only
    BadStreamContext: ClassVar[DiagCode] = ...  # read-only
    BadStreamExprType: ClassVar[DiagCode] = ...  # read-only
    BadStreamSize: ClassVar[DiagCode] = ...  # read-only
    BadStreamSlice: ClassVar[DiagCode] = ...  # read-only
    BadStreamSourceType: ClassVar[DiagCode] = ...  # read-only
    BadStreamTargetType: ClassVar[DiagCode] = ...  # read-only
    BadStreamWithOrder: ClassVar[DiagCode] = ...  # read-only
    BadStreamWithType: ClassVar[DiagCode] = ...  # read-only
    BadSystemSubroutineArg: ClassVar[DiagCode] = ...  # read-only
    BadTypeParamExpr: ClassVar[DiagCode] = ...  # read-only
    BadUnaryExpression: ClassVar[DiagCode] = ...  # read-only
    BadUniquenessType: ClassVar[DiagCode] = ...  # read-only
    BadValueRange: ClassVar[DiagCode] = ...  # read-only
    BaseConstructorDuplicate: ClassVar[DiagCode] = ...  # read-only
    BaseConstructorNotCalled: ClassVar[DiagCode] = ...  # read-only
    BiDiSwitchNetTypes: ClassVar[DiagCode] = ...  # read-only
    BindDirectiveInvalidName: ClassVar[DiagCode] = ...  # read-only
    BindTargetPrimitive: ClassVar[DiagCode] = ...  # read-only
    BindTypeParamMismatch: ClassVar[DiagCode] = ...  # read-only
    BindTypeParamNotFound: ClassVar[DiagCode] = ...  # read-only
    BindUnderBind: ClassVar[DiagCode] = ...  # read-only
    BitwiseOpMismatch: ClassVar[DiagCode] = ...  # read-only
    BitwiseOpParentheses: ClassVar[DiagCode] = ...  # read-only
    BitwiseRelPrecedence: ClassVar[DiagCode] = ...  # read-only
    BlockingAssignToFreeVar: ClassVar[DiagCode] = ...  # read-only
    BlockingInAlwaysFF: ClassVar[DiagCode] = ...  # read-only
    BodyForPure: ClassVar[DiagCode] = ...  # read-only
    BodyForPureConstraint: ClassVar[DiagCode] = ...  # read-only
    BodyParamNoInitializer: ClassVar[DiagCode] = ...  # read-only
    CHandleInAssertion: ClassVar[DiagCode] = ...  # read-only
    CannotCompareTwoInstances: ClassVar[DiagCode] = ...  # read-only
    CannotDeclareType: ClassVar[DiagCode] = ...  # read-only
    CannotIndexScalar: ClassVar[DiagCode] = ...  # read-only
    CantDeclarePortSigned: ClassVar[DiagCode] = ...  # read-only
    CantModifyConst: ClassVar[DiagCode] = ...  # read-only
    CaseComplex: ClassVar[DiagCode] = ...  # read-only
    CaseDefault: ClassVar[DiagCode] = ...  # read-only
    CaseDup: ClassVar[DiagCode] = ...  # read-only
    CaseEnum: ClassVar[DiagCode] = ...  # read-only
    CaseEnumExplicit: ClassVar[DiagCode] = ...  # read-only
    CaseGenerateDup: ClassVar[DiagCode] = ...  # read-only
    CaseGenerateEmpty: ClassVar[DiagCode] = ...  # read-only
    CaseGenerateNoBlock: ClassVar[DiagCode] = ...  # read-only
    CaseIncomplete: ClassVar[DiagCode] = ...  # read-only
    CaseInsideKeyword: ClassVar[DiagCode] = ...  # read-only
    CaseNotWildcard: ClassVar[DiagCode] = ...  # read-only
    CaseOutsideRange: ClassVar[DiagCode] = ...  # read-only
    CaseOverlap: ClassVar[DiagCode] = ...  # read-only
    CaseRedundantDefault: ClassVar[DiagCode] = ...  # read-only
    CaseStatementEmpty: ClassVar[DiagCode] = ...  # read-only
    CaseTypeMismatch: ClassVar[DiagCode] = ...  # read-only
    CaseUnreachable: ClassVar[DiagCode] = ...  # read-only
    CaseWildcard2State: ClassVar[DiagCode] = ...  # read-only
    CaseZWithX: ClassVar[DiagCode] = ...  # read-only
    ChainedMethodParens: ClassVar[DiagCode] = ...  # read-only
    ChargeWithTriReg: ClassVar[DiagCode] = ...  # read-only
    CheckerArgCannotBeEmpty: ClassVar[DiagCode] = ...  # read-only
    CheckerBlockingAssign: ClassVar[DiagCode] = ...  # read-only
    CheckerClassBadInstantiation: ClassVar[DiagCode] = ...  # read-only
    CheckerForkJoinRef: ClassVar[DiagCode] = ...  # read-only
    CheckerFuncArg: ClassVar[DiagCode] = ...  # read-only
    CheckerFuncBadInstantiation: ClassVar[DiagCode] = ...  # read-only
    CheckerHierarchical: ClassVar[DiagCode] = ...  # read-only
    CheckerInCheckerProc: ClassVar[DiagCode] = ...  # read-only
    CheckerInForkJoin: ClassVar[DiagCode] = ...  # read-only
    CheckerNotInProc: ClassVar[DiagCode] = ...  # read-only
    CheckerOutputBadType: ClassVar[DiagCode] = ...  # read-only
    CheckerParameterAssign: ClassVar[DiagCode] = ...  # read-only
    CheckerPortDirectionType: ClassVar[DiagCode] = ...  # read-only
    CheckerPortInout: ClassVar[DiagCode] = ...  # read-only
    CheckerTimingControl: ClassVar[DiagCode] = ...  # read-only
    ClassInheritanceCycle: ClassVar[DiagCode] = ...  # read-only
    ClassMemberInAssertion: ClassVar[DiagCode] = ...  # read-only
    ClassPrivateMembersBitstream: ClassVar[DiagCode] = ...  # read-only
    ClassSpecifierConflict: ClassVar[DiagCode] = ...  # read-only
    ClockVarAssignConcat: ClassVar[DiagCode] = ...  # read-only
    ClockVarBadTiming: ClassVar[DiagCode] = ...  # read-only
    ClockVarOutputRead: ClassVar[DiagCode] = ...  # read-only
    ClockVarSyncDrive: ClassVar[DiagCode] = ...  # read-only
    ClockVarTargetAssign: ClassVar[DiagCode] = ...  # read-only
    ClockingBlockEventEdge: ClassVar[DiagCode] = ...  # read-only
    ClockingBlockEventIff: ClassVar[DiagCode] = ...  # read-only
    ClockingNameEmpty: ClassVar[DiagCode] = ...  # read-only
    ComparisonMismatch: ClassVar[DiagCode] = ...  # read-only
    CompilationUnitFromPackage: ClassVar[DiagCode] = ...  # read-only
    ConcatWithStringInt: ClassVar[DiagCode] = ...  # read-only
    ConcurrentAssertActionBlock: ClassVar[DiagCode] = ...  # read-only
    ConcurrentAssertNotInProc: ClassVar[DiagCode] = ...  # read-only
    ConditionalPrecedence: ClassVar[DiagCode] = ...  # read-only
    ConfigDupTop: ClassVar[DiagCode] = ...  # read-only
    ConfigInstanceUnderOtherConfig: ClassVar[DiagCode] = ...  # read-only
    ConfigInstanceWrongTop: ClassVar[DiagCode] = ...  # read-only
    ConfigMissingName: ClassVar[DiagCode] = ...  # read-only
    ConfigOverrideTop: ClassVar[DiagCode] = ...  # read-only
    ConfigParamLiteral: ClassVar[DiagCode] = ...  # read-only
    ConfigParamsForPrimitive: ClassVar[DiagCode] = ...  # read-only
    ConfigParamsIgnored: ClassVar[DiagCode] = ...  # read-only
    ConfigParamsOrdered: ClassVar[DiagCode] = ...  # read-only
    ConfigSpecificCellLiblist: ClassVar[DiagCode] = ...  # read-only
    ConsecutiveComparison: ClassVar[DiagCode] = ...  # read-only
    ConstEvalAssertionFailed: ClassVar[DiagCode] = ...  # read-only
    ConstEvalAssociativeElementNotFound: ClassVar[DiagCode] = ...  # read-only
    ConstEvalAssociativeIndexInvalid: ClassVar[DiagCode] = ...  # read-only
    ConstEvalBitstreamCastSize: ClassVar[DiagCode] = ...  # read-only
    ConstEvalCaseItemsNotUnique: ClassVar[DiagCode] = ...  # read-only
    ConstEvalCheckers: ClassVar[DiagCode] = ...  # read-only
    ConstEvalClassType: ClassVar[DiagCode] = ...  # read-only
    ConstEvalCovergroupType: ClassVar[DiagCode] = ...  # read-only
    ConstEvalDPINotConstant: ClassVar[DiagCode] = ...  # read-only
    ConstEvalDisableTarget: ClassVar[DiagCode] = ...  # read-only
    ConstEvalDynamicArrayIndex: ClassVar[DiagCode] = ...  # read-only
    ConstEvalDynamicArrayRange: ClassVar[DiagCode] = ...  # read-only
    ConstEvalDynamicToFixedSize: ClassVar[DiagCode] = ...  # read-only
    ConstEvalEmptyQueue: ClassVar[DiagCode] = ...  # read-only
    ConstEvalExceededMaxCallDepth: ClassVar[DiagCode] = ...  # read-only
    ConstEvalExceededMaxSteps: ClassVar[DiagCode] = ...  # read-only
    ConstEvalFunctionArgDirection: ClassVar[DiagCode] = ...  # read-only
    ConstEvalFunctionIdentifiersMustBeLocal: ClassVar[DiagCode] = ...  # read-only
    ConstEvalFunctionInsideGenerate: ClassVar[DiagCode] = ...  # read-only
    ConstEvalHierarchicalName: ClassVar[DiagCode] = ...  # read-only
    ConstEvalIdUsedInCEBeforeDecl: ClassVar[DiagCode] = ...  # read-only
    ConstEvalIfItemsNotUnique: ClassVar[DiagCode] = ...  # read-only
    ConstEvalMethodNotConstant: ClassVar[DiagCode] = ...  # read-only
    ConstEvalNoCaseItemsMatched: ClassVar[DiagCode] = ...  # read-only
    ConstEvalNoIfItemsMatched: ClassVar[DiagCode] = ...  # read-only
    ConstEvalNonConstVariable: ClassVar[DiagCode] = ...  # read-only
    ConstEvalParallelBlockNotConst: ClassVar[DiagCode] = ...  # read-only
    ConstEvalParamCycle: ClassVar[DiagCode] = ...  # read-only
    ConstEvalProceduralAssign: ClassVar[DiagCode] = ...  # read-only
    ConstEvalQueueRange: ClassVar[DiagCode] = ...  # read-only
    ConstEvalRandValue: ClassVar[DiagCode] = ...  # read-only
    ConstEvalReplicationCountInvalid: ClassVar[DiagCode] = ...  # read-only
    ConstEvalStaticSkipped: ClassVar[DiagCode] = ...  # read-only
    ConstEvalSubroutineNotConstant: ClassVar[DiagCode] = ...  # read-only
    ConstEvalTaggedUnion: ClassVar[DiagCode] = ...  # read-only
    ConstEvalTaskNotConstant: ClassVar[DiagCode] = ...  # read-only
    ConstEvalTimedStmtNotConst: ClassVar[DiagCode] = ...  # read-only
    ConstEvalVoidNotConstant: ClassVar[DiagCode] = ...  # read-only
    ConstFunctionPortRequiresRef: ClassVar[DiagCode] = ...  # read-only
    ConstPortNotAllowed: ClassVar[DiagCode] = ...  # read-only
    ConstSysTaskIgnored: ClassVar[DiagCode] = ...  # read-only
    ConstVarNoInitializer: ClassVar[DiagCode] = ...  # read-only
    ConstVarToRef: ClassVar[DiagCode] = ...  # read-only
    ConstantConversion: ClassVar[DiagCode] = ...  # read-only
    ConstraintNotInClass: ClassVar[DiagCode] = ...  # read-only
    ConstraintQualOutOfBlock: ClassVar[DiagCode] = ...  # read-only
    ConstructorOutsideClass: ClassVar[DiagCode] = ...  # read-only
    ConstructorReturnType: ClassVar[DiagCode] = ...  # read-only
    CopyClassTarget: ClassVar[DiagCode] = ...  # read-only
    CouldNotOpenIncludeFile: ClassVar[DiagCode] = ...  # read-only
    CouldNotResolveHierarchicalPath: ClassVar[DiagCode] = ...  # read-only
    CoverCrossItems: ClassVar[DiagCode] = ...  # read-only
    CoverOptionImmutable: ClassVar[DiagCode] = ...  # read-only
    CoverStmtNoFail: ClassVar[DiagCode] = ...  # read-only
    CoverageBinDefSeqSize: ClassVar[DiagCode] = ...  # read-only
    CoverageBinDefaultIgnore: ClassVar[DiagCode] = ...  # read-only
    CoverageBinDefaultWildcard: ClassVar[DiagCode] = ...  # read-only
    CoverageBinTargetName: ClassVar[DiagCode] = ...  # read-only
    CoverageBinTransSize: ClassVar[DiagCode] = ...  # read-only
    CoverageExprVar: ClassVar[DiagCode] = ...  # read-only
    CoverageOptionDup: ClassVar[DiagCode] = ...  # read-only
    CoverageSampleFormal: ClassVar[DiagCode] = ...  # read-only
    CoverageSetType: ClassVar[DiagCode] = ...  # read-only
    CovergroupOutArg: ClassVar[DiagCode] = ...  # read-only
    CycleDelayNonClock: ClassVar[DiagCode] = ...  # read-only
    DPIExportDifferentScope: ClassVar[DiagCode] = ...  # read-only
    DPIExportDuplicate: ClassVar[DiagCode] = ...  # read-only
    DPIExportDuplicateCId: ClassVar[DiagCode] = ...  # read-only
    DPIExportImportedFunc: ClassVar[DiagCode] = ...  # read-only
    DPIExportKindMismatch: ClassVar[DiagCode] = ...  # read-only
    DPIPureArg: ClassVar[DiagCode] = ...  # read-only
    DPIPureReturn: ClassVar[DiagCode] = ...  # read-only
    DPIPureTask: ClassVar[DiagCode] = ...  # read-only
    DPIRefArg: ClassVar[DiagCode] = ...  # read-only
    DPISignatureMismatch: ClassVar[DiagCode] = ...  # read-only
    DPISpecDisallowed: ClassVar[DiagCode] = ...  # read-only
    DecimalDigitMultipleUnknown: ClassVar[DiagCode] = ...  # read-only
    DeclModifierConflict: ClassVar[DiagCode] = ...  # read-only
    DeclModifierOrdering: ClassVar[DiagCode] = ...  # read-only
    DeclarationsAtStart: ClassVar[DiagCode] = ...  # read-only
    DefParamCycle: ClassVar[DiagCode] = ...  # read-only
    DefParamLocal: ClassVar[DiagCode] = ...  # read-only
    DefParamTarget: ClassVar[DiagCode] = ...  # read-only
    DefParamTargetChange: ClassVar[DiagCode] = ...  # read-only
    DefaultArgNotAllowed: ClassVar[DiagCode] = ...  # read-only
    DefaultSuperArgLocalReference: ClassVar[DiagCode] = ...  # read-only
    DeferredAssertAutoRefArg: ClassVar[DiagCode] = ...  # read-only
    DeferredAssertNonVoid: ClassVar[DiagCode] = ...  # read-only
    DeferredAssertOutArg: ClassVar[DiagCode] = ...  # read-only
    DeferredDelayMustBeZero: ClassVar[DiagCode] = ...  # read-only
    DefinitionUsedAsType: ClassVar[DiagCode] = ...  # read-only
    DefinitionUsedAsValue: ClassVar[DiagCode] = ...  # read-only
    DefparamBadHierarchy: ClassVar[DiagCode] = ...  # read-only
    Delay3NotAllowed: ClassVar[DiagCode] = ...  # read-only
    Delay3OnVar: ClassVar[DiagCode] = ...  # read-only
    Delay3UdpNotAllowed: ClassVar[DiagCode] = ...  # read-only
    DelayNotNumeric: ClassVar[DiagCode] = ...  # read-only
    DelaysNotAllowed: ClassVar[DiagCode] = ...  # read-only
    DerivedCovergroupNoBase: ClassVar[DiagCode] = ...  # read-only
    DerivedCovergroupNotInClass: ClassVar[DiagCode] = ...  # read-only
    DifferentClockInClockingBlock: ClassVar[DiagCode] = ...  # read-only
    DigitsLeadingUnderscore: ClassVar[DiagCode] = ...  # read-only
    DimensionIndexInvalid: ClassVar[DiagCode] = ...  # read-only
    DimensionRequiresConstRange: ClassVar[DiagCode] = ...  # read-only
    DirectionOnInterfacePort: ClassVar[DiagCode] = ...  # read-only
    DirectionWithInterfacePort: ClassVar[DiagCode] = ...  # read-only
    DirectiveInsideDesignElement: ClassVar[DiagCode] = ...  # read-only
    DisableIffLocalVar: ClassVar[DiagCode] = ...  # read-only
    DisableIffMatched: ClassVar[DiagCode] = ...  # read-only
    DisallowedPortDefault: ClassVar[DiagCode] = ...  # read-only
    DistRealRangeWeight: ClassVar[DiagCode] = ...  # read-only
    DotIntoInstArray: ClassVar[DiagCode] = ...  # read-only
    DotOnType: ClassVar[DiagCode] = ...  # read-only
    DriveStrengthHighZ: ClassVar[DiagCode] = ...  # read-only
    DriveStrengthInvalid: ClassVar[DiagCode] = ...  # read-only
    DriveStrengthNotAllowed: ClassVar[DiagCode] = ...  # read-only
    DupConfigRule: ClassVar[DiagCode] = ...  # read-only
    DupInterfaceExternMethod: ClassVar[DiagCode] = ...  # read-only
    DupTimingPath: ClassVar[DiagCode] = ...  # read-only
    DuplicateArgAssignment: ClassVar[DiagCode] = ...  # read-only
    DuplicateAttribute: ClassVar[DiagCode] = ...  # read-only
    DuplicateBind: ClassVar[DiagCode] = ...  # read-only
    DuplicateClassSpecifier: ClassVar[DiagCode] = ...  # read-only
    DuplicateDeclModifier: ClassVar[DiagCode] = ...  # read-only
    DuplicateDefinition: ClassVar[DiagCode] = ...  # read-only
    DuplicateDefparam: ClassVar[DiagCode] = ...  # read-only
    DuplicateImport: ClassVar[DiagCode] = ...  # read-only
    DuplicateParamAssignment: ClassVar[DiagCode] = ...  # read-only
    DuplicatePortConnection: ClassVar[DiagCode] = ...  # read-only
    DuplicateQualifier: ClassVar[DiagCode] = ...  # read-only
    DuplicateWildcardPortConnection: ClassVar[DiagCode] = ...  # read-only
    DynamicDimensionIndex: ClassVar[DiagCode] = ...  # read-only
    DynamicFromChecker: ClassVar[DiagCode] = ...  # read-only
    DynamicNotProcedural: ClassVar[DiagCode] = ...  # read-only
    EdgeDescWrongKeyword: ClassVar[DiagCode] = ...  # read-only
    EmbeddedNull: ClassVar[DiagCode] = ...  # read-only
    EmptyArgNotAllowed: ClassVar[DiagCode] = ...  # read-only
    EmptyAssignmentPattern: ClassVar[DiagCode] = ...  # read-only
    EmptyBody: ClassVar[DiagCode] = ...  # read-only
    EmptyConcatNotAllowed: ClassVar[DiagCode] = ...  # read-only
    EmptyMember: ClassVar[DiagCode] = ...  # read-only
    EmptyStatement: ClassVar[DiagCode] = ...  # read-only
    EmptyUdpPort: ClassVar[DiagCode] = ...  # read-only
    EndNameMismatch: ClassVar[DiagCode] = ...  # read-only
    EndNameNotEmpty: ClassVar[DiagCode] = ...  # read-only
    EnumIncrementUnknown: ClassVar[DiagCode] = ...  # read-only
    EnumRangeLiteral: ClassVar[DiagCode] = ...  # read-only
    EnumRangeMultiDimensional: ClassVar[DiagCode] = ...  # read-only
    EnumValueDuplicate: ClassVar[DiagCode] = ...  # read-only
    EnumValueOutOfRange: ClassVar[DiagCode] = ...  # read-only
    EnumValueOverflow: ClassVar[DiagCode] = ...  # read-only
    EnumValueSizeMismatch: ClassVar[DiagCode] = ...  # read-only
    EnumValueUnknownBits: ClassVar[DiagCode] = ...  # read-only
    ErrorTask: ClassVar[DiagCode] = ...  # read-only
    EscapedWhitespace: ClassVar[DiagCode] = ...  # read-only
    EventExprAssertionArg: ClassVar[DiagCode] = ...  # read-only
    EventExpressionConstant: ClassVar[DiagCode] = ...  # read-only
    EventExpressionFuncArg: ClassVar[DiagCode] = ...  # read-only
    EventTriggerCycleDelay: ClassVar[DiagCode] = ...  # read-only
    ExceededMaxIncludeDepth: ClassVar[DiagCode] = ...  # read-only
    ExpectedAnsiPort: ClassVar[DiagCode] = ...  # read-only
    ExpectedArgument: ClassVar[DiagCode] = ...  # read-only
    ExpectedAssertionItemPort: ClassVar[DiagCode] = ...  # read-only
    ExpectedAssignmentKey: ClassVar[DiagCode] = ...  # read-only
    ExpectedAttribute: ClassVar[DiagCode] = ...  # read-only
    ExpectedCaseItem: ClassVar[DiagCode] = ...  # read-only
    ExpectedClassPropertyName: ClassVar[DiagCode] = ...  # read-only
    ExpectedClassSpecifier: ClassVar[DiagCode] = ...  # read-only
    ExpectedClockingSkew: ClassVar[DiagCode] = ...  # read-only
    ExpectedClosingQuote: ClassVar[DiagCode] = ...  # read-only
    ExpectedConditionalPattern: ClassVar[DiagCode] = ...  # read-only
    ExpectedConstraintName: ClassVar[DiagCode] = ...  # read-only
    ExpectedContinuousAssignment: ClassVar[DiagCode] = ...  # read-only
    ExpectedDPISpecString: ClassVar[DiagCode] = ...  # read-only
    ExpectedDeclarator: ClassVar[DiagCode] = ...  # read-only
    ExpectedDiagPragmaArg: ClassVar[DiagCode] = ...  # read-only
    ExpectedDiagPragmaLevel: ClassVar[DiagCode] = ...  # read-only
    ExpectedDistItem: ClassVar[DiagCode] = ...  # read-only
    ExpectedDriveStrength: ClassVar[DiagCode] = ...  # read-only
    ExpectedEdgeDescriptor: ClassVar[DiagCode] = ...  # read-only
    ExpectedEnumBase: ClassVar[DiagCode] = ...  # read-only
    ExpectedExpression: ClassVar[DiagCode] = ...  # read-only
    ExpectedForInitializer: ClassVar[DiagCode] = ...  # read-only
    ExpectedFunctionPort: ClassVar[DiagCode] = ...  # read-only
    ExpectedFunctionPortList: ClassVar[DiagCode] = ...  # read-only
    ExpectedGenvarIterVar: ClassVar[DiagCode] = ...  # read-only
    ExpectedHierarchicalInstantiation: ClassVar[DiagCode] = ...  # read-only
    ExpectedIdentifier: ClassVar[DiagCode] = ...  # read-only
    ExpectedIfOrCase: ClassVar[DiagCode] = ...  # read-only
    ExpectedImportExport: ClassVar[DiagCode] = ...  # read-only
    ExpectedIncludeFileName: ClassVar[DiagCode] = ...  # read-only
    ExpectedIntegerBaseAfterSigned: ClassVar[DiagCode] = ...  # read-only
    ExpectedIntegerLiteral: ClassVar[DiagCode] = ...  # read-only
    ExpectedInterfaceClassName: ClassVar[DiagCode] = ...  # read-only
    ExpectedIterationExpression: ClassVar[DiagCode] = ...  # read-only
    ExpectedIteratorName: ClassVar[DiagCode] = ...  # read-only
    ExpectedMacroArgs: ClassVar[DiagCode] = ...  # read-only
    ExpectedMacroStringifyEnd: ClassVar[DiagCode] = ...  # read-only
    ExpectedMember: ClassVar[DiagCode] = ...  # read-only
    ExpectedModOrVarName: ClassVar[DiagCode] = ...  # read-only
    ExpectedModportPort: ClassVar[DiagCode] = ...  # read-only
    ExpectedModuleInstance: ClassVar[DiagCode] = ...  # read-only
    ExpectedModuleName: ClassVar[DiagCode] = ...  # read-only
    ExpectedNetDelay: ClassVar[DiagCode] = ...  # read-only
    ExpectedNetRef: ClassVar[DiagCode] = ...  # read-only
    ExpectedNetStrength: ClassVar[DiagCode] = ...  # read-only
    ExpectedNetType: ClassVar[DiagCode] = ...  # read-only
    ExpectedNonAnsiPort: ClassVar[DiagCode] = ...  # read-only
    ExpectedPackageImport: ClassVar[DiagCode] = ...  # read-only
    ExpectedParameterPort: ClassVar[DiagCode] = ...  # read-only
    ExpectedPathOp: ClassVar[DiagCode] = ...  # read-only
    ExpectedPattern: ClassVar[DiagCode] = ...  # read-only
    ExpectedPortConnection: ClassVar[DiagCode] = ...  # read-only
    ExpectedPortList: ClassVar[DiagCode] = ...  # read-only
    ExpectedPragmaExpression: ClassVar[DiagCode] = ...  # read-only
    ExpectedPragmaName: ClassVar[DiagCode] = ...  # read-only
    ExpectedProtectArg: ClassVar[DiagCode] = ...  # read-only
    ExpectedProtectKeyword: ClassVar[DiagCode] = ...  # read-only
    ExpectedRsRule: ClassVar[DiagCode] = ...  # read-only
    ExpectedSampleKeyword: ClassVar[DiagCode] = ...  # read-only
    ExpectedScopeName: ClassVar[DiagCode] = ...  # read-only
    ExpectedScopeOrAssert: ClassVar[DiagCode] = ...  # read-only
    ExpectedStatement: ClassVar[DiagCode] = ...  # read-only
    ExpectedStreamExpression: ClassVar[DiagCode] = ...  # read-only
    ExpectedStringLiteral: ClassVar[DiagCode] = ...  # read-only
    ExpectedSubroutineName: ClassVar[DiagCode] = ...  # read-only
    ExpectedTimeLiteral: ClassVar[DiagCode] = ...  # read-only
    ExpectedToken: ClassVar[DiagCode] = ...  # read-only
    ExpectedUdpPort: ClassVar[DiagCode] = ...  # read-only
    ExpectedUdpSymbol: ClassVar[DiagCode] = ...  # read-only
    ExpectedValueRangeElement: ClassVar[DiagCode] = ...  # read-only
    ExpectedVariableAssignment: ClassVar[DiagCode] = ...  # read-only
    ExpectedVariableName: ClassVar[DiagCode] = ...  # read-only
    ExpectedVectorDigits: ClassVar[DiagCode] = ...  # read-only
    ExplicitClockInClockingBlock: ClassVar[DiagCode] = ...  # read-only
    ExprMustBeIntegral: ClassVar[DiagCode] = ...  # read-only
    ExprNotConstraint: ClassVar[DiagCode] = ...  # read-only
    ExprNotStatement: ClassVar[DiagCode] = ...  # read-only
    ExpressionNotAssignable: ClassVar[DiagCode] = ...  # read-only
    ExpressionNotCallable: ClassVar[DiagCode] = ...  # read-only
    ExtendClassFromIface: ClassVar[DiagCode] = ...  # read-only
    ExtendFromFinal: ClassVar[DiagCode] = ...  # read-only
    ExtendIfaceFromClass: ClassVar[DiagCode] = ...  # read-only
    ExternDeclMismatchImpl: ClassVar[DiagCode] = ...  # read-only
    ExternDeclMismatchPrev: ClassVar[DiagCode] = ...  # read-only
    ExternFuncForkJoin: ClassVar[DiagCode] = ...  # read-only
    ExternIfaceArrayMethod: ClassVar[DiagCode] = ...  # read-only
    ExternWildcardPortList: ClassVar[DiagCode] = ...  # read-only
    ExtraPragmaArgs: ClassVar[DiagCode] = ...  # read-only
    ExtraProtectEnd: ClassVar[DiagCode] = ...  # read-only
    FatalTask: ClassVar[DiagCode] = ...  # read-only
    FinalSpecifierLast: ClassVar[DiagCode] = ...  # read-only
    FinalWithPure: ClassVar[DiagCode] = ...  # read-only
    FloatBoolConv: ClassVar[DiagCode] = ...  # read-only
    FloatIntConv: ClassVar[DiagCode] = ...  # read-only
    FloatNarrow: ClassVar[DiagCode] = ...  # read-only
    FloatWiden: ClassVar[DiagCode] = ...  # read-only
    ForeachDynamicDimAfterSkipped: ClassVar[DiagCode] = ...  # read-only
    ForeachWildcardIndex: ClassVar[DiagCode] = ...  # read-only
    ForkJoinAlwaysComb: ClassVar[DiagCode] = ...  # read-only
    FormatEmptyArg: ClassVar[DiagCode] = ...  # read-only
    FormatMismatchedType: ClassVar[DiagCode] = ...  # read-only
    FormatMultibitStrength: ClassVar[DiagCode] = ...  # read-only
    FormatNoArgument: ClassVar[DiagCode] = ...  # read-only
    FormatRealInt: ClassVar[DiagCode] = ...  # read-only
    FormatSpecifierInvalidWidth: ClassVar[DiagCode] = ...  # read-only
    FormatSpecifierNotFloat: ClassVar[DiagCode] = ...  # read-only
    FormatSpecifierWidthNotAllowed: ClassVar[DiagCode] = ...  # read-only
    FormatTooManyArgs: ClassVar[DiagCode] = ...  # read-only
    FormatUnspecifiedType: ClassVar[DiagCode] = ...  # read-only
    ForwardTypedefDoesNotMatch: ClassVar[DiagCode] = ...  # read-only
    ForwardTypedefVisibility: ClassVar[DiagCode] = ...  # read-only
    GFSVMatchItems: ClassVar[DiagCode] = ...  # read-only
    GateUDNTConn: ClassVar[DiagCode] = ...  # read-only
    GenericClassScopeResolution: ClassVar[DiagCode] = ...  # read-only
    GenvarDuplicate: ClassVar[DiagCode] = ...  # read-only
    GenvarUnknownBits: ClassVar[DiagCode] = ...  # read-only
    GlobalClockEventExpr: ClassVar[DiagCode] = ...  # read-only
    GlobalClockingEmpty: ClassVar[DiagCode] = ...  # read-only
    GlobalClockingGenerate: ClassVar[DiagCode] = ...  # read-only
    GlobalSampledValueAssertionExpr: ClassVar[DiagCode] = ...  # read-only
    GlobalSampledValueNested: ClassVar[DiagCode] = ...  # read-only
    HierarchicalFromPackage: ClassVar[DiagCode] = ...  # read-only
    HierarchicalRefUnknownModule: ClassVar[DiagCode] = ...  # read-only
    IfNoneEdgeSensitive: ClassVar[DiagCode] = ...  # read-only
    IfaceExtendIncomplete: ClassVar[DiagCode] = ...  # read-only
    IfaceExtendTypeParam: ClassVar[DiagCode] = ...  # read-only
    IfaceImportExportTarget: ClassVar[DiagCode] = ...  # read-only
    IfaceMethodHidden: ClassVar[DiagCode] = ...  # read-only
    IfaceMethodNoImpl: ClassVar[DiagCode] = ...  # read-only
    IfaceMethodNotExtern: ClassVar[DiagCode] = ...  # read-only
    IfaceMethodNotVirtual: ClassVar[DiagCode] = ...  # read-only
    IfaceMethodPure: ClassVar[DiagCode] = ...  # read-only
    IfaceNameConflict: ClassVar[DiagCode] = ...  # read-only
    IfacePortInExpr: ClassVar[DiagCode] = ...  # read-only
    IgnoredMacroPaste: ClassVar[DiagCode] = ...  # read-only
    IgnoredSlice: ClassVar[DiagCode] = ...  # read-only
    IllegalReferenceToProgramItem: ClassVar[DiagCode] = ...  # read-only
    ImplementNonIface: ClassVar[DiagCode] = ...  # read-only
    ImplicitConnNetInconsistent: ClassVar[DiagCode] = ...  # read-only
    ImplicitConvert: ClassVar[DiagCode] = ...  # read-only
    ImplicitEventInAssertion: ClassVar[DiagCode] = ...  # read-only
    ImplicitNamedPortNotFound: ClassVar[DiagCode] = ...  # read-only
    ImplicitNamedPortTypeMismatch: ClassVar[DiagCode] = ...  # read-only
    ImplicitNetPortNoDefault: ClassVar[DiagCode] = ...  # read-only
    ImplicitNotAllowed: ClassVar[DiagCode] = ...  # read-only
    ImportNameCollision: ClassVar[DiagCode] = ...  # read-only
    InOutDefaultSkew: ClassVar[DiagCode] = ...  # read-only
    InOutPortCannotBeVariable: ClassVar[DiagCode] = ...  # read-only
    InOutUWireConn: ClassVar[DiagCode] = ...  # read-only
    InOutUWirePort: ClassVar[DiagCode] = ...  # read-only
    InOutVarPortConn: ClassVar[DiagCode] = ...  # read-only
    IncDecNotAllowed: ClassVar[DiagCode] = ...  # read-only
    IncompleteReturn: ClassVar[DiagCode] = ...  # read-only
    IndexOOB: ClassVar[DiagCode] = ...  # read-only
    IndexValueInvalid: ClassVar[DiagCode] = ...  # read-only
    InequivalentUniquenessTypes: ClassVar[DiagCode] = ...  # read-only
    InferredComb: ClassVar[DiagCode] = ...  # read-only
    InferredLatch: ClassVar[DiagCode] = ...  # read-only
    InferredValDefArg: ClassVar[DiagCode] = ...  # read-only
    InfinitelyRecursiveHierarchy: ClassVar[DiagCode] = ...  # read-only
    InfoTask: ClassVar[DiagCode] = ...  # read-only
    InheritFromAbstract: ClassVar[DiagCode] = ...  # read-only
    InheritFromAbstractConstraint: ClassVar[DiagCode] = ...  # read-only
    InitializerRequired: ClassVar[DiagCode] = ...  # read-only
    InputPortAssign: ClassVar[DiagCode] = ...  # read-only
    InputPortCoercion: ClassVar[DiagCode] = ...  # read-only
    InstanceArrayEndianMismatch: ClassVar[DiagCode] = ...  # read-only
    InstanceMissingParens: ClassVar[DiagCode] = ...  # read-only
    InstanceNameRequired: ClassVar[DiagCode] = ...  # read-only
    InstanceWithDelay: ClassVar[DiagCode] = ...  # read-only
    InstanceWithStrength: ClassVar[DiagCode] = ...  # read-only
    IntBoolConv: ClassVar[DiagCode] = ...  # read-only
    IntFloatConv: ClassVar[DiagCode] = ...  # read-only
    InterconnectDelaySyntax: ClassVar[DiagCode] = ...  # read-only
    InterconnectInitializer: ClassVar[DiagCode] = ...  # read-only
    InterconnectMultiPort: ClassVar[DiagCode] = ...  # read-only
    InterconnectPortVar: ClassVar[DiagCode] = ...  # read-only
    InterconnectReference: ClassVar[DiagCode] = ...  # read-only
    InterconnectTypeSyntax: ClassVar[DiagCode] = ...  # read-only
    InterfacePortInvalidExpression: ClassVar[DiagCode] = ...  # read-only
    InterfacePortNotConnected: ClassVar[DiagCode] = ...  # read-only
    InterfacePortTypeMismatch: ClassVar[DiagCode] = ...  # read-only
    InvalidAccessDotColon: ClassVar[DiagCode] = ...  # read-only
    InvalidArgumentExpr: ClassVar[DiagCode] = ...  # read-only
    InvalidArrayElemType: ClassVar[DiagCode] = ...  # read-only
    InvalidArraySize: ClassVar[DiagCode] = ...  # read-only
    InvalidAssociativeIndexType: ClassVar[DiagCode] = ...  # read-only
    InvalidBindTarget: ClassVar[DiagCode] = ...  # read-only
    InvalidBinsMatches: ClassVar[DiagCode] = ...  # read-only
    InvalidBinsTarget: ClassVar[DiagCode] = ...  # read-only
    InvalidBlockEventTarget: ClassVar[DiagCode] = ...  # read-only
    InvalidClassAccess: ClassVar[DiagCode] = ...  # read-only
    InvalidClockingSignal: ClassVar[DiagCode] = ...  # read-only
    InvalidCommaInPropExpr: ClassVar[DiagCode] = ...  # read-only
    InvalidConstraintExpr: ClassVar[DiagCode] = ...  # read-only
    InvalidConstraintQualifier: ClassVar[DiagCode] = ...  # read-only
    InvalidConstructorAccess: ClassVar[DiagCode] = ...  # read-only
    InvalidCoverageExpr: ClassVar[DiagCode] = ...  # read-only
    InvalidCoverageOption: ClassVar[DiagCode] = ...  # read-only
    InvalidDPIArgType: ClassVar[DiagCode] = ...  # read-only
    InvalidDPICIdentifier: ClassVar[DiagCode] = ...  # read-only
    InvalidDPIReturnType: ClassVar[DiagCode] = ...  # read-only
    InvalidDeferredAssertAction: ClassVar[DiagCode] = ...  # read-only
    InvalidDelayValue: ClassVar[DiagCode] = ...  # read-only
    InvalidDimensionRange: ClassVar[DiagCode] = ...  # read-only
    InvalidDisableTarget: ClassVar[DiagCode] = ...  # read-only
    InvalidDistExpression: ClassVar[DiagCode] = ...  # read-only
    InvalidEdgeDescriptor: ClassVar[DiagCode] = ...  # read-only
    InvalidEncodingByte: ClassVar[DiagCode] = ...  # read-only
    InvalidEnumBase: ClassVar[DiagCode] = ...  # read-only
    InvalidEventExpression: ClassVar[DiagCode] = ...  # read-only
    InvalidExtendsDefault: ClassVar[DiagCode] = ...  # read-only
    InvalidForInitializer: ClassVar[DiagCode] = ...  # read-only
    InvalidForStepExpression: ClassVar[DiagCode] = ...  # read-only
    InvalidGenvarIterExpression: ClassVar[DiagCode] = ...  # read-only
    InvalidHexEscapeCode: ClassVar[DiagCode] = ...  # read-only
    InvalidHierarchicalIfacePortConn: ClassVar[DiagCode] = ...  # read-only
    InvalidInferredTimeScale: ClassVar[DiagCode] = ...  # read-only
    InvalidInstanceForParent: ClassVar[DiagCode] = ...  # read-only
    InvalidLineDirectiveLevel: ClassVar[DiagCode] = ...  # read-only
    InvalidMacroName: ClassVar[DiagCode] = ...  # read-only
    InvalidMatchItem: ClassVar[DiagCode] = ...  # read-only
    InvalidMemberAccess: ClassVar[DiagCode] = ...  # read-only
    InvalidMethodOverride: ClassVar[DiagCode] = ...  # read-only
    InvalidMethodQualifier: ClassVar[DiagCode] = ...  # read-only
    InvalidModportAccess: ClassVar[DiagCode] = ...  # read-only
    InvalidMulticlockedSeqOp: ClassVar[DiagCode] = ...  # read-only
    InvalidNGateCount: ClassVar[DiagCode] = ...  # read-only
    InvalidNetType: ClassVar[DiagCode] = ...  # read-only
    InvalidPackageDecl: ClassVar[DiagCode] = ...  # read-only
    InvalidParamOverrideOpt: ClassVar[DiagCode] = ...  # read-only
    InvalidPortSubType: ClassVar[DiagCode] = ...  # read-only
    InvalidPortType: ClassVar[DiagCode] = ...  # read-only
    InvalidPragmaNumber: ClassVar[DiagCode] = ...  # read-only
    InvalidPragmaViewport: ClassVar[DiagCode] = ...  # read-only
    InvalidPrimInstanceForParent: ClassVar[DiagCode] = ...  # read-only
    InvalidPrimitivePortConn: ClassVar[DiagCode] = ...  # read-only
    InvalidPropertyIndex: ClassVar[DiagCode] = ...  # read-only
    InvalidPropertyQualifier: ClassVar[DiagCode] = ...  # read-only
    InvalidPropertyRange: ClassVar[DiagCode] = ...  # read-only
    InvalidPullStrength: ClassVar[DiagCode] = ...  # read-only
    InvalidPulseStyle: ClassVar[DiagCode] = ...  # read-only
    InvalidQualifierForConstructor: ClassVar[DiagCode] = ...  # read-only
    InvalidQualifierForIfaceMember: ClassVar[DiagCode] = ...  # read-only
    InvalidQualifierForMember: ClassVar[DiagCode] = ...  # read-only
    InvalidRandType: ClassVar[DiagCode] = ...  # read-only
    InvalidRandomizeOverride: ClassVar[DiagCode] = ...  # read-only
    InvalidRefArg: ClassVar[DiagCode] = ...  # read-only
    InvalidRepeatRange: ClassVar[DiagCode] = ...  # read-only
    InvalidScopeIndexExpression: ClassVar[DiagCode] = ...  # read-only
    InvalidSelectExpression: ClassVar[DiagCode] = ...  # read-only
    InvalidSignalEventInSeq: ClassVar[DiagCode] = ...  # read-only
    InvalidSpecifyDest: ClassVar[DiagCode] = ...  # read-only
    InvalidSpecifyPath: ClassVar[DiagCode] = ...  # read-only
    InvalidSpecifySource: ClassVar[DiagCode] = ...  # read-only
    InvalidSpecifyType: ClassVar[DiagCode] = ...  # read-only
    InvalidStmtInChecker: ClassVar[DiagCode] = ...  # read-only
    InvalidStringArg: ClassVar[DiagCode] = ...  # read-only
    InvalidSuperNew: ClassVar[DiagCode] = ...  # read-only
    InvalidSuperNewDefault: ClassVar[DiagCode] = ...  # read-only
    InvalidSyntaxInEventExpr: ClassVar[DiagCode] = ...  # read-only
    InvalidThisHandle: ClassVar[DiagCode] = ...  # read-only
    InvalidTimeScalePrecision: ClassVar[DiagCode] = ...  # read-only
    InvalidTimeScaleSpecifier: ClassVar[DiagCode] = ...  # read-only
    InvalidTimingCheckNotifierArg: ClassVar[DiagCode] = ...  # read-only
    InvalidTopModule: ClassVar[DiagCode] = ...  # read-only
    InvalidUTF8Seq: ClassVar[DiagCode] = ...  # read-only
    InvalidUnionMember: ClassVar[DiagCode] = ...  # read-only
    InvalidUniquenessExpr: ClassVar[DiagCode] = ...  # read-only
    InvalidUserDefinedNetType: ClassVar[DiagCode] = ...  # read-only
    IsUnboundedParamArg: ClassVar[DiagCode] = ...  # read-only
    IteratorArgsWithoutWithClause: ClassVar[DiagCode] = ...  # read-only
    LabelAndName: ClassVar[DiagCode] = ...  # read-only
    LetHierarchical: ClassVar[DiagCode] = ...  # read-only
    LifetimeForPrototype: ClassVar[DiagCode] = ...  # read-only
    LiteralSizeIsZero: ClassVar[DiagCode] = ...  # read-only
    LiteralSizeTooLarge: ClassVar[DiagCode] = ...  # read-only
    LocalFormalVarMultiAssign: ClassVar[DiagCode] = ...  # read-only
    LocalMemberAccess: ClassVar[DiagCode] = ...  # read-only
    LocalNotAllowed: ClassVar[DiagCode] = ...  # read-only
    LocalParamNoInitializer: ClassVar[DiagCode] = ...  # read-only
    LocalVarEventExpr: ClassVar[DiagCode] = ...  # read-only
    LocalVarMatchItem: ClassVar[DiagCode] = ...  # read-only
    LocalVarOutputEmptyMatch: ClassVar[DiagCode] = ...  # read-only
    LocalVarTypeRequired: ClassVar[DiagCode] = ...  # read-only
    LogicalNotParentheses: ClassVar[DiagCode] = ...  # read-only
    LogicalOpParentheses: ClassVar[DiagCode] = ...  # read-only
    LoopVarShadowsArray: ClassVar[DiagCode] = ...  # read-only
    MacroOpsOutsideDefinition: ClassVar[DiagCode] = ...  # read-only
    MacroTokensAfterPragmaProtect: ClassVar[DiagCode] = ...  # read-only
    MatchItemsAdmitEmpty: ClassVar[DiagCode] = ...  # read-only
    MaxGenerateStepsExceeded: ClassVar[DiagCode] = ...  # read-only
    MaxInstanceArrayExceeded: ClassVar[DiagCode] = ...  # read-only
    MaxInstanceDepthExceeded: ClassVar[DiagCode] = ...  # read-only
    MemberDefinitionBeforeClass: ClassVar[DiagCode] = ...  # read-only
    MethodArgCountMismatch: ClassVar[DiagCode] = ...  # read-only
    MethodArgDefaultMismatch: ClassVar[DiagCode] = ...  # read-only
    MethodArgDirectionMismatch: ClassVar[DiagCode] = ...  # read-only
    MethodArgNameMismatch: ClassVar[DiagCode] = ...  # read-only
    MethodArgNoDefault: ClassVar[DiagCode] = ...  # read-only
    MethodArgTypeMismatch: ClassVar[DiagCode] = ...  # read-only
    MethodKindMismatch: ClassVar[DiagCode] = ...  # read-only
    MethodReturnMismatch: ClassVar[DiagCode] = ...  # read-only
    MethodReturnTypeScoped: ClassVar[DiagCode] = ...  # read-only
    MethodStaticLifetime: ClassVar[DiagCode] = ...  # read-only
    MismatchConstraintSpecifiers: ClassVar[DiagCode] = ...  # read-only
    MismatchStaticConstraint: ClassVar[DiagCode] = ...  # read-only
    MismatchedEndKeywordsDirective: ClassVar[DiagCode] = ...  # read-only
    MismatchedTimeScales: ClassVar[DiagCode] = ...  # read-only
    MismatchedUserDefPortConn: ClassVar[DiagCode] = ...  # read-only
    MismatchedUserDefPortDir: ClassVar[DiagCode] = ...  # read-only
    MisplacedDirectiveChar: ClassVar[DiagCode] = ...  # read-only
    MisplacedTrailingSeparator: ClassVar[DiagCode] = ...  # read-only
    MissingConstraintBlock: ClassVar[DiagCode] = ...  # read-only
    MissingEndIfDirective: ClassVar[DiagCode] = ...  # read-only
    MissingExponentDigits: ClassVar[DiagCode] = ...  # read-only
    MissingExportImpl: ClassVar[DiagCode] = ...  # read-only
    MissingExternImpl: ClassVar[DiagCode] = ...  # read-only
    MissingExternModuleImpl: ClassVar[DiagCode] = ...  # read-only
    MissingExternWildcardPorts: ClassVar[DiagCode] = ...  # read-only
    MissingFormatSpecifier: ClassVar[DiagCode] = ...  # read-only
    MissingFractionalDigits: ClassVar[DiagCode] = ...  # read-only
    MissingInvocationParens: ClassVar[DiagCode] = ...  # read-only
    MissingModportPortDirection: ClassVar[DiagCode] = ...  # read-only
    MissingPortIODeclaration: ClassVar[DiagCode] = ...  # read-only
    MissingReturn: ClassVar[DiagCode] = ...  # read-only
    MissingReturnValue: ClassVar[DiagCode] = ...  # read-only
    MissingReturnValueProd: ClassVar[DiagCode] = ...  # read-only
    MissingTimeScale: ClassVar[DiagCode] = ...  # read-only
    MixedVarAssigns: ClassVar[DiagCode] = ...  # read-only
    MixingOrderedAndNamedArgs: ClassVar[DiagCode] = ...  # read-only
    MixingOrderedAndNamedParams: ClassVar[DiagCode] = ...  # read-only
    MixingOrderedAndNamedPorts: ClassVar[DiagCode] = ...  # read-only
    MixingSubroutinePortKinds: ClassVar[DiagCode] = ...  # read-only
    ModportConnMismatch: ClassVar[DiagCode] = ...  # read-only
    MultiBitEdge: ClassVar[DiagCode] = ...  # read-only
    MulticlockedInClockingBlock: ClassVar[DiagCode] = ...  # read-only
    MulticlockedSeqEmptyMatch: ClassVar[DiagCode] = ...  # read-only
    MultipleAlwaysAssigns: ClassVar[DiagCode] = ...  # read-only
    MultipleContAssigns: ClassVar[DiagCode] = ...  # read-only
    MultipleDefaultCases: ClassVar[DiagCode] = ...  # read-only
    MultipleDefaultClocking: ClassVar[DiagCode] = ...  # read-only
    MultipleDefaultConstructorArg: ClassVar[DiagCode] = ...  # read-only
    MultipleDefaultDisable: ClassVar[DiagCode] = ...  # read-only
    MultipleDefaultDistWeight: ClassVar[DiagCode] = ...  # read-only
    MultipleDefaultInputSkew: ClassVar[DiagCode] = ...  # read-only
    MultipleDefaultOutputSkew: ClassVar[DiagCode] = ...  # read-only
    MultipleDefaultRules: ClassVar[DiagCode] = ...  # read-only
    MultipleGenerateDefaultCases: ClassVar[DiagCode] = ...  # read-only
    MultipleGlobalClocking: ClassVar[DiagCode] = ...  # read-only
    MultipleNetAlias: ClassVar[DiagCode] = ...  # read-only
    MultiplePackedOpenArrays: ClassVar[DiagCode] = ...  # read-only
    MultipleParallelTerminals: ClassVar[DiagCode] = ...  # read-only
    MultipleTopDupName: ClassVar[DiagCode] = ...  # read-only
    MultipleUDNTDrivers: ClassVar[DiagCode] = ...  # read-only
    MultipleUWireDrivers: ClassVar[DiagCode] = ...  # read-only
    NTResolveArgModify: ClassVar[DiagCode] = ...  # read-only
    NTResolveClass: ClassVar[DiagCode] = ...  # read-only
    NTResolveReturn: ClassVar[DiagCode] = ...  # read-only
    NTResolveSingleArg: ClassVar[DiagCode] = ...  # read-only
    NTResolveTask: ClassVar[DiagCode] = ...  # read-only
    NTResolveUserDef: ClassVar[DiagCode] = ...  # read-only
    NameListWithScopeRandomize: ClassVar[DiagCode] = ...  # read-only
    NamedArgNotAllowed: ClassVar[DiagCode] = ...  # read-only
    NegativeTimingLimit: ClassVar[DiagCode] = ...  # read-only
    NestedBlockComment: ClassVar[DiagCode] = ...  # read-only
    NestedConfigMultipleTops: ClassVar[DiagCode] = ...  # read-only
    NestedDisableIff: ClassVar[DiagCode] = ...  # read-only
    NestedIface: ClassVar[DiagCode] = ...  # read-only
    NestedNonStaticClassMethod: ClassVar[DiagCode] = ...  # read-only
    NestedNonStaticClassProperty: ClassVar[DiagCode] = ...  # read-only
    NestedProtectBegin: ClassVar[DiagCode] = ...  # read-only
    NetAliasCommonNetType: ClassVar[DiagCode] = ...  # read-only
    NetAliasHierarchical: ClassVar[DiagCode] = ...  # read-only
    NetAliasNotANet: ClassVar[DiagCode] = ...  # read-only
    NetAliasSelf: ClassVar[DiagCode] = ...  # read-only
    NetAliasWidthMismatch: ClassVar[DiagCode] = ...  # read-only
    NetInconsistent: ClassVar[DiagCode] = ...  # read-only
    NetRangeInconsistent: ClassVar[DiagCode] = ...  # read-only
    NewArrayTarget: ClassVar[DiagCode] = ...  # read-only
    NewClassTarget: ClassVar[DiagCode] = ...  # read-only
    NewInterfaceClass: ClassVar[DiagCode] = ...  # read-only
    NewKeywordQualified: ClassVar[DiagCode] = ...  # read-only
    NewVirtualClass: ClassVar[DiagCode] = ...  # read-only
    NoChangeEdgeRequired: ClassVar[DiagCode] = ...  # read-only
    NoCommaInList: ClassVar[DiagCode] = ...  # read-only
    NoCommonComparisonType: ClassVar[DiagCode] = ...  # read-only
    NoConstraintBody: ClassVar[DiagCode] = ...  # read-only
    NoDeclInClass: ClassVar[DiagCode] = ...  # read-only
    NoDefaultClocking: ClassVar[DiagCode] = ...  # read-only
    NoDefaultSpecialization: ClassVar[DiagCode] = ...  # read-only
    NoGlobalClocking: ClassVar[DiagCode] = ...  # read-only
    NoImplicitConversion: ClassVar[DiagCode] = ...  # read-only
    NoInferredClock: ClassVar[DiagCode] = ...  # read-only
    NoLabelOnSemicolon: ClassVar[DiagCode] = ...  # read-only
    NoMemberImplFound: ClassVar[DiagCode] = ...  # read-only
    NoTopModules: ClassVar[DiagCode] = ...  # read-only
    NoUniqueClock: ClassVar[DiagCode] = ...  # read-only
    NonIntegralConstraintLiteral: ClassVar[DiagCode] = ...  # read-only
    NonPrintableChar: ClassVar[DiagCode] = ...  # read-only
    NonProceduralFuncArg: ClassVar[DiagCode] = ...  # read-only
    NonStandardGenBlock: ClassVar[DiagCode] = ...  # read-only
    NonStaticClassMethod: ClassVar[DiagCode] = ...  # read-only
    NonStaticClassProperty: ClassVar[DiagCode] = ...  # read-only
    NonblockingAssignmentToAuto: ClassVar[DiagCode] = ...  # read-only
    NonblockingDynamicAssign: ClassVar[DiagCode] = ...  # read-only
    NonblockingInFinal: ClassVar[DiagCode] = ...  # read-only
    NonstandardDist: ClassVar[DiagCode] = ...  # read-only
    NonstandardEscapeCode: ClassVar[DiagCode] = ...  # read-only
    NonstandardForeach: ClassVar[DiagCode] = ...  # read-only
    NonstandardSysFunc: ClassVar[DiagCode] = ...  # read-only
    NotAChecker: ClassVar[DiagCode] = ...  # read-only
    NotAClass: ClassVar[DiagCode] = ...  # read-only
    NotAClockingBlock: ClassVar[DiagCode] = ...  # read-only
    NotAGenericClass: ClassVar[DiagCode] = ...  # read-only
    NotAGenvar: ClassVar[DiagCode] = ...  # read-only
    NotAHierarchicalScope: ClassVar[DiagCode] = ...  # read-only
    NotAModport: ClassVar[DiagCode] = ...  # read-only
    NotAProduction: ClassVar[DiagCode] = ...  # read-only
    NotASubroutine: ClassVar[DiagCode] = ...  # read-only
    NotAType: ClassVar[DiagCode] = ...  # read-only
    NotAValue: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInAnonymousProgram: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInCU: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInChecker: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInClass: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInClocking: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInGenerate: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInIfaceClass: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInInterface: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInModport: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInModule: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInPackage: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInProgram: ClassVar[DiagCode] = ...  # read-only
    NotAnArray: ClassVar[DiagCode] = ...  # read-only
    NotAnEvent: ClassVar[DiagCode] = ...  # read-only
    NotAnInterface: ClassVar[DiagCode] = ...  # read-only
    NotAnInterfaceOrPort: ClassVar[DiagCode] = ...  # read-only
    NotBooleanConvertible: ClassVar[DiagCode] = ...  # read-only
    NotEnoughMacroArgs: ClassVar[DiagCode] = ...  # read-only
    NoteAliasDeclaration: ClassVar[DiagCode] = ...  # read-only
    NoteAliasedTo: ClassVar[DiagCode] = ...  # read-only
    NoteAlwaysFalse: ClassVar[DiagCode] = ...  # read-only
    NoteAssignedHere: ClassVar[DiagCode] = ...  # read-only
    NoteClockHere: ClassVar[DiagCode] = ...  # read-only
    NoteCommonAncestor: ClassVar[DiagCode] = ...  # read-only
    NoteComparisonReduces: ClassVar[DiagCode] = ...  # read-only
    NoteConditionalPrecedenceFix: ClassVar[DiagCode] = ...  # read-only
    NoteConfigRule: ClassVar[DiagCode] = ...  # read-only
    NoteDeclarationHere: ClassVar[DiagCode] = ...  # read-only
    NoteDirectiveHere: ClassVar[DiagCode] = ...  # read-only
    NoteDrivenHere: ClassVar[DiagCode] = ...  # read-only
    NoteExpandedHere: ClassVar[DiagCode] = ...  # read-only
    NoteFromHere2: ClassVar[DiagCode] = ...  # read-only
    NoteHierarchicalRef: ClassVar[DiagCode] = ...  # read-only
    NoteImportedFrom: ClassVar[DiagCode] = ...  # read-only
    NoteInCallTo: ClassVar[DiagCode] = ...  # read-only
    NoteLastBlockEnded: ClassVar[DiagCode] = ...  # read-only
    NoteLastBlockStarted: ClassVar[DiagCode] = ...  # read-only
    NoteLogicalNotFix: ClassVar[DiagCode] = ...  # read-only
    NoteLogicalNotSilence: ClassVar[DiagCode] = ...  # read-only
    NoteOriginalAssign: ClassVar[DiagCode] = ...  # read-only
    NotePrecedenceBitwiseFirst: ClassVar[DiagCode] = ...  # read-only
    NotePrecedenceSilence: ClassVar[DiagCode] = ...  # read-only
    NotePreviousDefinition: ClassVar[DiagCode] = ...  # read-only
    NotePreviousMatch: ClassVar[DiagCode] = ...  # read-only
    NotePreviousUsage: ClassVar[DiagCode] = ...  # read-only
    NoteReferencedHere: ClassVar[DiagCode] = ...  # read-only
    NoteRequiredHere: ClassVar[DiagCode] = ...  # read-only
    NoteSkippingFrames: ClassVar[DiagCode] = ...  # read-only
    NoteToMatchThis: ClassVar[DiagCode] = ...  # read-only
    NoteUdpCoverage: ClassVar[DiagCode] = ...  # read-only
    NoteWhileExpanding: ClassVar[DiagCode] = ...  # read-only
    NullPortExpression: ClassVar[DiagCode] = ...  # read-only
    ObjectTooLarge: ClassVar[DiagCode] = ...  # read-only
    OctalEscapeCodeTooBig: ClassVar[DiagCode] = ...  # read-only
    OutRefFuncConstraint: ClassVar[DiagCode] = ...  # read-only
    OutputPortCoercion: ClassVar[DiagCode] = ...  # read-only
    OverridingExtends: ClassVar[DiagCode] = ...  # read-only
    OverridingFinal: ClassVar[DiagCode] = ...  # read-only
    OverridingInitial: ClassVar[DiagCode] = ...  # read-only
    PackageExportSelf: ClassVar[DiagCode] = ...  # read-only
    PackageImportSelf: ClassVar[DiagCode] = ...  # read-only
    PackageNetInit: ClassVar[DiagCode] = ...  # read-only
    PackedArrayConv: ClassVar[DiagCode] = ...  # read-only
    PackedArrayNotIntegral: ClassVar[DiagCode] = ...  # read-only
    PackedDimsOnPredefinedType: ClassVar[DiagCode] = ...  # read-only
    PackedDimsOnUnpacked: ClassVar[DiagCode] = ...  # read-only
    PackedDimsRequireFullRange: ClassVar[DiagCode] = ...  # read-only
    PackedMemberHasInitializer: ClassVar[DiagCode] = ...  # read-only
    PackedMemberNotIntegral: ClassVar[DiagCode] = ...  # read-only
    PackedTypeTooLarge: ClassVar[DiagCode] = ...  # read-only
    PackedUnionWidthMismatch: ClassVar[DiagCode] = ...  # read-only
    ParallelPathWidth: ClassVar[DiagCode] = ...  # read-only
    ParamHasNoValue: ClassVar[DiagCode] = ...  # read-only
    ParameterDoesNotExist: ClassVar[DiagCode] = ...  # read-only
    ParseTreeTooDeep: ClassVar[DiagCode] = ...  # read-only
    PastNumTicksInvalid: ClassVar[DiagCode] = ...  # read-only
    PathPulseInExpr: ClassVar[DiagCode] = ...  # read-only
    PathPulseInvalidPathName: ClassVar[DiagCode] = ...  # read-only
    PatternStructTooFew: ClassVar[DiagCode] = ...  # read-only
    PatternStructTooMany: ClassVar[DiagCode] = ...  # read-only
    PatternStructType: ClassVar[DiagCode] = ...  # read-only
    PatternTaggedType: ClassVar[DiagCode] = ...  # read-only
    PlaRangeInAscendingOrder: ClassVar[DiagCode] = ...  # read-only
    PointlessVoidCast: ClassVar[DiagCode] = ...  # read-only
    PortConcatInOut: ClassVar[DiagCode] = ...  # read-only
    PortConcatRef: ClassVar[DiagCode] = ...  # read-only
    PortConnArrayMismatch: ClassVar[DiagCode] = ...  # read-only
    PortConnDimensionsMismatch: ClassVar[DiagCode] = ...  # read-only
    PortDeclDimensionsMismatch: ClassVar[DiagCode] = ...  # read-only
    PortDeclInANSIModule: ClassVar[DiagCode] = ...  # read-only
    PortDoesNotExist: ClassVar[DiagCode] = ...  # read-only
    PortTypeNotInterfaceOrData: ClassVar[DiagCode] = ...  # read-only
    PortWidthExpand: ClassVar[DiagCode] = ...  # read-only
    PortWidthTruncate: ClassVar[DiagCode] = ...  # read-only
    PrimitiveAnsiMix: ClassVar[DiagCode] = ...  # read-only
    PrimitiveDupInitial: ClassVar[DiagCode] = ...  # read-only
    PrimitiveDupOutput: ClassVar[DiagCode] = ...  # read-only
    PrimitiveInitVal: ClassVar[DiagCode] = ...  # read-only
    PrimitiveInitialInComb: ClassVar[DiagCode] = ...  # read-only
    PrimitiveOutputFirst: ClassVar[DiagCode] = ...  # read-only
    PrimitivePortCountWrong: ClassVar[DiagCode] = ...  # read-only
    PrimitivePortDup: ClassVar[DiagCode] = ...  # read-only
    PrimitivePortMissing: ClassVar[DiagCode] = ...  # read-only
    PrimitivePortUnknown: ClassVar[DiagCode] = ...  # read-only
    PrimitiveRegDup: ClassVar[DiagCode] = ...  # read-only
    PrimitiveRegInput: ClassVar[DiagCode] = ...  # read-only
    PrimitiveTwoPorts: ClassVar[DiagCode] = ...  # read-only
    PrimitiveWrongInitial: ClassVar[DiagCode] = ...  # read-only
    PropAbortLocalVar: ClassVar[DiagCode] = ...  # read-only
    PropAbortMatched: ClassVar[DiagCode] = ...  # read-only
    PropExprInSequence: ClassVar[DiagCode] = ...  # read-only
    PropInstanceRepetition: ClassVar[DiagCode] = ...  # read-only
    PropertyLhsInvalid: ClassVar[DiagCode] = ...  # read-only
    PropertyPortInLet: ClassVar[DiagCode] = ...  # read-only
    PropertyPortInSeq: ClassVar[DiagCode] = ...  # read-only
    ProtectArgList: ClassVar[DiagCode] = ...  # read-only
    ProtectEncodingBytes: ClassVar[DiagCode] = ...  # read-only
    ProtectedEnvelope: ClassVar[DiagCode] = ...  # read-only
    ProtectedMemberAccess: ClassVar[DiagCode] = ...  # read-only
    PullStrengthHighZ: ClassVar[DiagCode] = ...  # read-only
    PulseControlPATHPULSE: ClassVar[DiagCode] = ...  # read-only
    PulseControlSpecifyParent: ClassVar[DiagCode] = ...  # read-only
    PureConstraintInAbstract: ClassVar[DiagCode] = ...  # read-only
    PureInAbstract: ClassVar[DiagCode] = ...  # read-only
    PureRequiresVirtual: ClassVar[DiagCode] = ...  # read-only
    QualifierConflict: ClassVar[DiagCode] = ...  # read-only
    QualifierNotFirst: ClassVar[DiagCode] = ...  # read-only
    QualifiersOnOutOfBlock: ClassVar[DiagCode] = ...  # read-only
    QueryOnAssociativeNonIntegral: ClassVar[DiagCode] = ...  # read-only
    QueryOnAssociativeWildcard: ClassVar[DiagCode] = ...  # read-only
    QueryOnDynamicType: ClassVar[DiagCode] = ...  # read-only
    RandCInDist: ClassVar[DiagCode] = ...  # read-only
    RandCInSoft: ClassVar[DiagCode] = ...  # read-only
    RandCInSolveBefore: ClassVar[DiagCode] = ...  # read-only
    RandCInUnique: ClassVar[DiagCode] = ...  # read-only
    RandJoinNotEnough: ClassVar[DiagCode] = ...  # read-only
    RandJoinNotNumeric: ClassVar[DiagCode] = ...  # read-only
    RandJoinProdItem: ClassVar[DiagCode] = ...  # read-only
    RandNeededInDist: ClassVar[DiagCode] = ...  # read-only
    RandOnPackedMember: ClassVar[DiagCode] = ...  # read-only
    RandOnUnionMember: ClassVar[DiagCode] = ...  # read-only
    RangeOOB: ClassVar[DiagCode] = ...  # read-only
    RangeSelectAssociative: ClassVar[DiagCode] = ...  # read-only
    RangeWidthOOB: ClassVar[DiagCode] = ...  # read-only
    RangeWidthOverflow: ClassVar[DiagCode] = ...  # read-only
    RawProtectEOF: ClassVar[DiagCode] = ...  # read-only
    RealCoverpointBins: ClassVar[DiagCode] = ...  # read-only
    RealCoverpointDefaultArray: ClassVar[DiagCode] = ...  # read-only
    RealCoverpointImplicit: ClassVar[DiagCode] = ...  # read-only
    RealCoverpointTransBins: ClassVar[DiagCode] = ...  # read-only
    RealCoverpointWildcardBins: ClassVar[DiagCode] = ...  # read-only
    RealCoverpointWithExpr: ClassVar[DiagCode] = ...  # read-only
    RealLiteralOverflow: ClassVar[DiagCode] = ...  # read-only
    RealLiteralUnderflow: ClassVar[DiagCode] = ...  # read-only
    RecursiveClassSpecialization: ClassVar[DiagCode] = ...  # read-only
    RecursiveDefinition: ClassVar[DiagCode] = ...  # read-only
    RecursiveLet: ClassVar[DiagCode] = ...  # read-only
    RecursiveMacro: ClassVar[DiagCode] = ...  # read-only
    RecursivePropArgExpr: ClassVar[DiagCode] = ...  # read-only
    RecursivePropDisableIff: ClassVar[DiagCode] = ...  # read-only
    RecursivePropNegation: ClassVar[DiagCode] = ...  # read-only
    RecursivePropTimeAdvance: ClassVar[DiagCode] = ...  # read-only
    RecursiveSequence: ClassVar[DiagCode] = ...  # read-only
    RedefiningMacro: ClassVar[DiagCode] = ...  # read-only
    Redefinition: ClassVar[DiagCode] = ...  # read-only
    RedefinitionDifferentType: ClassVar[DiagCode] = ...  # read-only
    RefArgAutomaticFunc: ClassVar[DiagCode] = ...  # read-only
    RefArgForkJoin: ClassVar[DiagCode] = ...  # read-only
    RefPortMustBeVariable: ClassVar[DiagCode] = ...  # read-only
    RefPortUnconnected: ClassVar[DiagCode] = ...  # read-only
    RefPortUnnamedUnconnected: ClassVar[DiagCode] = ...  # read-only
    RefTypeMismatch: ClassVar[DiagCode] = ...  # read-only
    RegAfterNettype: ClassVar[DiagCode] = ...  # read-only
    RepeatControlNotEvent: ClassVar[DiagCode] = ...  # read-only
    RepeatNotNumeric: ClassVar[DiagCode] = ...  # read-only
    ReplicationZeroOutsideConcat: ClassVar[DiagCode] = ...  # read-only
    RestrictStmtNoFail: ClassVar[DiagCode] = ...  # read-only
    ReturnInParallel: ClassVar[DiagCode] = ...  # read-only
    ReturnNotInSubroutine: ClassVar[DiagCode] = ...  # read-only
    ReversedValueRange: ClassVar[DiagCode] = ...  # read-only
    SampledValueFuncClock: ClassVar[DiagCode] = ...  # read-only
    SampledValueLocalVar: ClassVar[DiagCode] = ...  # read-only
    SampledValueMatched: ClassVar[DiagCode] = ...  # read-only
    ScopeIncompleteTypedef: ClassVar[DiagCode] = ...  # read-only
    ScopeIndexOutOfRange: ClassVar[DiagCode] = ...  # read-only
    ScopeNotIndexable: ClassVar[DiagCode] = ...  # read-only
    ScopedClassCopy: ClassVar[DiagCode] = ...  # read-only
    SelectAfterRangeSelect: ClassVar[DiagCode] = ...  # read-only
    SelectEndianDynamic: ClassVar[DiagCode] = ...  # read-only
    SelectEndianMismatch: ClassVar[DiagCode] = ...  # read-only
    SelectOfVectoredNet: ClassVar[DiagCode] = ...  # read-only
    SeqEmptyMatch: ClassVar[DiagCode] = ...  # read-only
    SeqInstanceRepetition: ClassVar[DiagCode] = ...  # read-only
    SeqMethodEndClock: ClassVar[DiagCode] = ...  # read-only
    SeqMethodInputLocalVar: ClassVar[DiagCode] = ...  # read-only
    SeqNoMatch: ClassVar[DiagCode] = ...  # read-only
    SeqOnlyEmpty: ClassVar[DiagCode] = ...  # read-only
    SeqRangeMinMax: ClassVar[DiagCode] = ...  # read-only
    SequenceMatchedOutsideAssertion: ClassVar[DiagCode] = ...  # read-only
    SequenceMethodLocalVar: ClassVar[DiagCode] = ...  # read-only
    SignCompare: ClassVar[DiagCode] = ...  # read-only
    SignConversion: ClassVar[DiagCode] = ...  # read-only
    SignedIntegerOverflow: ClassVar[DiagCode] = ...  # read-only
    SignednessNoEffect: ClassVar[DiagCode] = ...  # read-only
    SingleBitVectored: ClassVar[DiagCode] = ...  # read-only
    SolveBeforeDisallowed: ClassVar[DiagCode] = ...  # read-only
    SpecifiersNotAllowed: ClassVar[DiagCode] = ...  # read-only
    SpecifyBlockParam: ClassVar[DiagCode] = ...  # read-only
    SpecifyPathBadReference: ClassVar[DiagCode] = ...  # read-only
    SpecifyPathConditionExpr: ClassVar[DiagCode] = ...  # read-only
    SpecifyPathMultiDim: ClassVar[DiagCode] = ...  # read-only
    SpecparamInConstant: ClassVar[DiagCode] = ...  # read-only
    SplitDistWeightOp: ClassVar[DiagCode] = ...  # read-only
    StatementNotInLoop: ClassVar[DiagCode] = ...  # read-only
    StaticAssert: ClassVar[DiagCode] = ...  # read-only
    StaticConstNoInitializer: ClassVar[DiagCode] = ...  # read-only
    StaticFuncSpecifier: ClassVar[DiagCode] = ...  # read-only
    StaticInitOrder: ClassVar[DiagCode] = ...  # read-only
    StaticInitValue: ClassVar[DiagCode] = ...  # read-only
    StaticInitializerMustBeExplicit: ClassVar[DiagCode] = ...  # read-only
    SubroutineMatchAutoRefArg: ClassVar[DiagCode] = ...  # read-only
    SubroutineMatchNonVoid: ClassVar[DiagCode] = ...  # read-only
    SubroutineMatchOutArg: ClassVar[DiagCode] = ...  # read-only
    SubroutinePortInitializer: ClassVar[DiagCode] = ...  # read-only
    SubroutinePrototypeScoped: ClassVar[DiagCode] = ...  # read-only
    SuperNoBase: ClassVar[DiagCode] = ...  # read-only
    SuperOutsideClass: ClassVar[DiagCode] = ...  # read-only
    SysFuncHierarchicalNotAllowed: ClassVar[DiagCode] = ...  # read-only
    SysFuncNotConst: ClassVar[DiagCode] = ...  # read-only
    TaggedStruct: ClassVar[DiagCode] = ...  # read-only
    TaggedUnionMissingInit: ClassVar[DiagCode] = ...  # read-only
    TaggedUnionTarget: ClassVar[DiagCode] = ...  # read-only
    TaskConstructor: ClassVar[DiagCode] = ...  # read-only
    TaskFromFinal: ClassVar[DiagCode] = ...  # read-only
    TaskFromFunction: ClassVar[DiagCode] = ...  # read-only
    TaskInConstraint: ClassVar[DiagCode] = ...  # read-only
    TaskReturnType: ClassVar[DiagCode] = ...  # read-only
    ThroughoutLhsInvalid: ClassVar[DiagCode] = ...  # read-only
    TimeScaleFirstInScope: ClassVar[DiagCode] = ...  # read-only
    TimingCheckEventEdgeRequired: ClassVar[DiagCode] = ...  # read-only
    TimingCheckEventNotAllowed: ClassVar[DiagCode] = ...  # read-only
    TimingControlNotAllowed: ClassVar[DiagCode] = ...  # read-only
    TimingInFuncNotAllowed: ClassVar[DiagCode] = ...  # read-only
    TooFewArguments: ClassVar[DiagCode] = ...  # read-only
    TooManyActualMacroArgs: ClassVar[DiagCode] = ...  # read-only
    TooManyArguments: ClassVar[DiagCode] = ...  # read-only
    TooManyEdgeDescriptors: ClassVar[DiagCode] = ...  # read-only
    TooManyErrors: ClassVar[DiagCode] = ...  # read-only
    TooManyForeachVars: ClassVar[DiagCode] = ...  # read-only
    TooManyLexerErrors: ClassVar[DiagCode] = ...  # read-only
    TooManyParamAssignments: ClassVar[DiagCode] = ...  # read-only
    TooManyPortConnections: ClassVar[DiagCode] = ...  # read-only
    TopModuleIfacePort: ClassVar[DiagCode] = ...  # read-only
    TopModuleRefPort: ClassVar[DiagCode] = ...  # read-only
    TopModuleUnnamedRefPort: ClassVar[DiagCode] = ...  # read-only
    TypeHierarchical: ClassVar[DiagCode] = ...  # read-only
    TypeIsNotAClass: ClassVar[DiagCode] = ...  # read-only
    TypeRefDeclVar: ClassVar[DiagCode] = ...  # read-only
    TypeRefHierarchical: ClassVar[DiagCode] = ...  # read-only
    TypeRefVoid: ClassVar[DiagCode] = ...  # read-only
    TypeRestrictionMismatch: ClassVar[DiagCode] = ...  # read-only
    TypoIdentifier: ClassVar[DiagCode] = ...  # read-only
    UTF8Char: ClassVar[DiagCode] = ...  # read-only
    UdpAllX: ClassVar[DiagCode] = ...  # read-only
    UdpCombState: ClassVar[DiagCode] = ...  # read-only
    UdpCoverage: ClassVar[DiagCode] = ...  # read-only
    UdpDupDiffOutput: ClassVar[DiagCode] = ...  # read-only
    UdpDupTransition: ClassVar[DiagCode] = ...  # read-only
    UdpEdgeInComb: ClassVar[DiagCode] = ...  # read-only
    UdpInvalidEdgeSymbol: ClassVar[DiagCode] = ...  # read-only
    UdpInvalidInputOnly: ClassVar[DiagCode] = ...  # read-only
    UdpInvalidMinus: ClassVar[DiagCode] = ...  # read-only
    UdpInvalidOutput: ClassVar[DiagCode] = ...  # read-only
    UdpInvalidSymbol: ClassVar[DiagCode] = ...  # read-only
    UdpInvalidTransition: ClassVar[DiagCode] = ...  # read-only
    UdpSequentialState: ClassVar[DiagCode] = ...  # read-only
    UdpSingleChar: ClassVar[DiagCode] = ...  # read-only
    UdpTransSameChar: ClassVar[DiagCode] = ...  # read-only
    UdpTransitionLength: ClassVar[DiagCode] = ...  # read-only
    UdpWrongInputCount: ClassVar[DiagCode] = ...  # read-only
    UnassignedVariable: ClassVar[DiagCode] = ...  # read-only
    UnbalancedMacroArgDims: ClassVar[DiagCode] = ...  # read-only
    UnboundedNotAllowed: ClassVar[DiagCode] = ...  # read-only
    UnclosedTranslateOff: ClassVar[DiagCode] = ...  # read-only
    UnconnectedArg: ClassVar[DiagCode] = ...  # read-only
    UnconnectedNamedPort: ClassVar[DiagCode] = ...  # read-only
    UnconnectedUnnamedPort: ClassVar[DiagCode] = ...  # read-only
    UndeclaredButFoundPackage: ClassVar[DiagCode] = ...  # read-only
    UndeclaredIdentifier: ClassVar[DiagCode] = ...  # read-only
    UndefineBuiltinDirective: ClassVar[DiagCode] = ...  # read-only
    UndrivenNet: ClassVar[DiagCode] = ...  # read-only
    UndrivenPort: ClassVar[DiagCode] = ...  # read-only
    UnexpectedClockingExpr: ClassVar[DiagCode] = ...  # read-only
    UnexpectedConditionalDirective: ClassVar[DiagCode] = ...  # read-only
    UnexpectedConstraintBlock: ClassVar[DiagCode] = ...  # read-only
    UnexpectedEndDelim: ClassVar[DiagCode] = ...  # read-only
    UnexpectedLetPortKeyword: ClassVar[DiagCode] = ...  # read-only
    UnexpectedNameToken: ClassVar[DiagCode] = ...  # read-only
    UnexpectedPortDecl: ClassVar[DiagCode] = ...  # read-only
    UnexpectedQualifiers: ClassVar[DiagCode] = ...  # read-only
    UnexpectedSelection: ClassVar[DiagCode] = ...  # read-only
    UnexpectedWithClause: ClassVar[DiagCode] = ...  # read-only
    UnicodeBOM: ClassVar[DiagCode] = ...  # read-only
    UniquePriorityAfterElse: ClassVar[DiagCode] = ...  # read-only
    UnknownClassMember: ClassVar[DiagCode] = ...  # read-only
    UnknownClassOrPackage: ClassVar[DiagCode] = ...  # read-only
    UnknownConstraintLiteral: ClassVar[DiagCode] = ...  # read-only
    UnknownCovergroupBase: ClassVar[DiagCode] = ...  # read-only
    UnknownCovergroupMember: ClassVar[DiagCode] = ...  # read-only
    UnknownDiagPragmaArg: ClassVar[DiagCode] = ...  # read-only
    UnknownDirective: ClassVar[DiagCode] = ...  # read-only
    UnknownEscapeCode: ClassVar[DiagCode] = ...  # read-only
    UnknownFormatSpecifier: ClassVar[DiagCode] = ...  # read-only
    UnknownInterface: ClassVar[DiagCode] = ...  # read-only
    UnknownLibrary: ClassVar[DiagCode] = ...  # read-only
    UnknownMember: ClassVar[DiagCode] = ...  # read-only
    UnknownModule: ClassVar[DiagCode] = ...  # read-only
    UnknownPackage: ClassVar[DiagCode] = ...  # read-only
    UnknownPackageMember: ClassVar[DiagCode] = ...  # read-only
    UnknownPragma: ClassVar[DiagCode] = ...  # read-only
    UnknownPrimitive: ClassVar[DiagCode] = ...  # read-only
    UnknownProtectEncoding: ClassVar[DiagCode] = ...  # read-only
    UnknownProtectKeyword: ClassVar[DiagCode] = ...  # read-only
    UnknownProtectOption: ClassVar[DiagCode] = ...  # read-only
    UnknownSystemMethod: ClassVar[DiagCode] = ...  # read-only
    UnknownSystemName: ClassVar[DiagCode] = ...  # read-only
    UnknownSystemTimingCheck: ClassVar[DiagCode] = ...  # read-only
    UnknownWarningOption: ClassVar[DiagCode] = ...  # read-only
    UnpackedArrayParamType: ClassVar[DiagCode] = ...  # read-only
    UnpackedConcatAssociative: ClassVar[DiagCode] = ...  # read-only
    UnpackedConcatSize: ClassVar[DiagCode] = ...  # read-only
    UnpackedSigned: ClassVar[DiagCode] = ...  # read-only
    UnrecognizedKeywordVersion: ClassVar[DiagCode] = ...  # read-only
    UnresolvedForwardTypedef: ClassVar[DiagCode] = ...  # read-only
    UnsignedArithShift: ClassVar[DiagCode] = ...  # read-only
    UnsizedInConcat: ClassVar[DiagCode] = ...  # read-only
    UnterminatedBlockComment: ClassVar[DiagCode] = ...  # read-only
    UnusedArgument: ClassVar[DiagCode] = ...  # read-only
    UnusedAssertionDecl: ClassVar[DiagCode] = ...  # read-only
    UnusedButSetNet: ClassVar[DiagCode] = ...  # read-only
    UnusedButSetPort: ClassVar[DiagCode] = ...  # read-only
    UnusedButSetVariable: ClassVar[DiagCode] = ...  # read-only
    UnusedConfigCell: ClassVar[DiagCode] = ...  # read-only
    UnusedConfigInstance: ClassVar[DiagCode] = ...  # read-only
    UnusedDefinition: ClassVar[DiagCode] = ...  # read-only
    UnusedGenvar: ClassVar[DiagCode] = ...  # read-only
    UnusedImplicitNet: ClassVar[DiagCode] = ...  # read-only
    UnusedImport: ClassVar[DiagCode] = ...  # read-only
    UnusedNet: ClassVar[DiagCode] = ...  # read-only
    UnusedParameter: ClassVar[DiagCode] = ...  # read-only
    UnusedPort: ClassVar[DiagCode] = ...  # read-only
    UnusedPortDecl: ClassVar[DiagCode] = ...  # read-only
    UnusedResult: ClassVar[DiagCode] = ...  # read-only
    UnusedTypeParameter: ClassVar[DiagCode] = ...  # read-only
    UnusedTypedef: ClassVar[DiagCode] = ...  # read-only
    UnusedVariable: ClassVar[DiagCode] = ...  # read-only
    UnusedWildcardImport: ClassVar[DiagCode] = ...  # read-only
    UsedBeforeDeclared: ClassVar[DiagCode] = ...  # read-only
    UselessCast: ClassVar[DiagCode] = ...  # read-only
    UserDefPartialDriver: ClassVar[DiagCode] = ...  # read-only
    UserDefPortMixedConcat: ClassVar[DiagCode] = ...  # read-only
    UserDefPortTwoSided: ClassVar[DiagCode] = ...  # read-only
    ValueExceedsMaxBitWidth: ClassVar[DiagCode] = ...  # read-only
    ValueMustBeIntegral: ClassVar[DiagCode] = ...  # read-only
    ValueMustBePositive: ClassVar[DiagCode] = ...  # read-only
    ValueMustNotBeUnknown: ClassVar[DiagCode] = ...  # read-only
    ValueOutOfRange: ClassVar[DiagCode] = ...  # read-only
    ValueRangeUnbounded: ClassVar[DiagCode] = ...  # read-only
    VarDeclWithDelay: ClassVar[DiagCode] = ...  # read-only
    VarWithInterfacePort: ClassVar[DiagCode] = ...  # read-only
    VectorLiteralOverflow: ClassVar[DiagCode] = ...  # read-only
    VirtualArgCountMismatch: ClassVar[DiagCode] = ...  # read-only
    VirtualArgDirectionMismatch: ClassVar[DiagCode] = ...  # read-only
    VirtualArgNameMismatch: ClassVar[DiagCode] = ...  # read-only
    VirtualArgNoDerivedDefault: ClassVar[DiagCode] = ...  # read-only
    VirtualArgNoParentDefault: ClassVar[DiagCode] = ...  # read-only
    VirtualArgTypeMismatch: ClassVar[DiagCode] = ...  # read-only
    VirtualIfaceConfigRule: ClassVar[DiagCode] = ...  # read-only
    VirtualIfaceDefparam: ClassVar[DiagCode] = ...  # read-only
    VirtualIfaceHierRef: ClassVar[DiagCode] = ...  # read-only
    VirtualIfaceIfacePort: ClassVar[DiagCode] = ...  # read-only
    VirtualInterfaceIfaceMember: ClassVar[DiagCode] = ...  # read-only
    VirtualInterfaceUnionMember: ClassVar[DiagCode] = ...  # read-only
    VirtualKindMismatch: ClassVar[DiagCode] = ...  # read-only
    VirtualReturnMismatch: ClassVar[DiagCode] = ...  # read-only
    VirtualVisibilityMismatch: ClassVar[DiagCode] = ...  # read-only
    VoidAssignment: ClassVar[DiagCode] = ...  # read-only
    VoidCastFuncCall: ClassVar[DiagCode] = ...  # read-only
    VoidNotAllowed: ClassVar[DiagCode] = ...  # read-only
    WarnUnknownLibrary: ClassVar[DiagCode] = ...  # read-only
    WarningTask: ClassVar[DiagCode] = ...  # read-only
    WidthExpand: ClassVar[DiagCode] = ...  # read-only
    WidthTruncate: ClassVar[DiagCode] = ...  # read-only
    WildcardPortGenericIface: ClassVar[DiagCode] = ...  # read-only
    WireDataType: ClassVar[DiagCode] = ...  # read-only
    WithClauseNotAllowed: ClassVar[DiagCode] = ...  # read-only
    WriteToInputClockVar: ClassVar[DiagCode] = ...  # read-only
    WrongBindTargetDef: ClassVar[DiagCode] = ...  # read-only
    WrongLanguageVersion: ClassVar[DiagCode] = ...  # read-only
    WrongNumberAssignmentPatterns: ClassVar[DiagCode] = ...  # read-only
    WrongSpecifyDelayCount: ClassVar[DiagCode] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...

class DimensionKind:
    __members__: ClassVar[dict] = ...  # read-only
    AbbreviatedRange: ClassVar[DimensionKind] = ...
    Associative: ClassVar[DimensionKind] = ...
    DPIOpenArray: ClassVar[DimensionKind] = ...
    Dynamic: ClassVar[DimensionKind] = ...
    Queue: ClassVar[DimensionKind] = ...
    Range: ClassVar[DimensionKind] = ...
    Unknown: ClassVar[DimensionKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class DimensionSpecifierSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class DirectiveSyntax(SyntaxNode):
    directive: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DisableConstraintSyntax(ConstraintItemSyntax):
    disable: Token
    name: ExpressionSyntax
    semi: Token
    soft: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DisableForkStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...

class DisableForkStatementSyntax(StatementSyntax):
    disable: Token
    fork: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DisableIffAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def condition(self): ...
    @property
    def expr(self) -> AssertionExpr: ...

class DisableIffSyntax(SyntaxNode):
    closeParen: Token
    disable: Token
    expr: ExpressionSyntax
    iff: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DisableSoftConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def target(self): ...

class DisableStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def target(self) -> Expression: ...

class DisableStatementSyntax(StatementSyntax):
    disable: Token
    name: NameSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DistConstraintListSyntax(SyntaxNode):
    closeBrace: Token
    dist: Token
    items: Incomplete
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DistExpression(Expression):
    class DistItem:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def value(self) -> Expression: ...
        @property
        def weight(self) -> DistExpression.DistWeight | None: ...

    class DistWeight:
        class Kind:
            __members__: ClassVar[dict] = ...  # read-only
            PerRange: ClassVar[DistExpression.DistWeight.Kind] = ...
            PerValue: ClassVar[DistExpression.DistWeight.Kind] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        PerRange: ClassVar[DistExpression.DistWeight.Kind] = ...
        PerValue: ClassVar[DistExpression.DistWeight.Kind] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def kind(self): ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def defaultWeight(self): ...
    @property
    def items(self): ...
    @property
    def left(self) -> Expression: ...

class DistItemBaseSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class DistItemSyntax(DistItemBaseSyntax):
    range: ExpressionSyntax
    weight: DistWeightSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class DistWeightSyntax(SyntaxNode):
    expr: ExpressionSyntax
    extraOp: Token
    op: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DividerClauseSyntax(SyntaxNode):
    divide: Token
    value: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DoWhileLoopStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self) -> Statement: ...
    @property
    def cond(self) -> Expression: ...

class DoWhileStatementSyntax(StatementSyntax):
    closeParen: Token
    doKeyword: Token
    expr: ExpressionSyntax
    openParen: Token
    semi: Token
    statement: StatementSyntax
    whileKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DotMemberClauseSyntax(SyntaxNode):
    dot: Token
    member: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DriveStrengthSyntax(NetStrengthSyntax):
    closeParen: Token
    comma: Token
    openParen: Token
    strength0: Token
    strength1: Token
    def __init__(self, *args, **kwargs) -> None: ...

class Driver:
    languageVersion: LanguageVersion
    def __init__(self) -> None: ...
    def addStandardArgs(self) -> None: ...
    def createCompilation(self) -> Compilation: ...
    def createOptionBag(self, *args, **kwargs): ...
    def getDepfiles(self, includesOnly: bool = ...) -> list[os.PathLike]: ...
    def parseAllSources(self) -> bool: ...
    def parseCommandLine(self, arg: str, parseOptions: CommandLineOptions = ...) -> bool: ...
    def processCommandFiles(self, fileName: str, makeRelative: bool, separateUnit: bool) -> bool: ...
    def processOptions(self) -> bool: ...
    def reportCompilation(self, compilation: Compilation, quiet: bool) -> None: ...
    def reportDiagnostics(self, quiet: bool) -> bool: ...
    def reportMacros(self) -> None: ...
    def reportParseDiags(self) -> bool: ...
    def runAnalysis(self, compilation: Compilation) -> AnalysisManager: ...
    def runFullCompilation(self, quiet: bool = ...) -> bool: ...
    def runPreprocessor(self, includeComments: bool, includeDirectives: bool, obfuscateIds: bool, useFixedObfuscationSeed: bool = ...) -> bool: ...
    def serializeDepfiles(self, files: list[os.PathLike], depfileTarget: str | None = ...) -> str: ...
    @property
    def diagEngine(self): ...
    @property
    def sourceLoader(self): ...
    @property
    def sourceManager(self): ...
    @property
    def syntaxTrees(self): ...
    @property
    def textDiagClient(self): ...

class DynamicArrayType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elementType(self) -> Type: ...

class EdgeControlSpecifierSyntax(SyntaxNode):
    closeBracket: Token
    descriptors: Incomplete
    openBracket: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EdgeDescriptorSyntax(SyntaxNode):
    t1: Token
    t2: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EdgeKind:
    __members__: ClassVar[dict] = ...  # read-only
    BothEdges: ClassVar[EdgeKind] = ...
    NegEdge: ClassVar[EdgeKind] = ...
    None_: ClassVar[EdgeKind] = ...
    PosEdge: ClassVar[EdgeKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class EdgeSensitivePathSuffixSyntax(PathSuffixSyntax):
    closeParen: Token
    colon: Token
    expr: ExpressionSyntax
    openParen: Token
    outputs: Incomplete
    polarityOperator: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ElabSystemTaskKind:
    __members__: ClassVar[dict] = ...  # read-only
    Error: ClassVar[ElabSystemTaskKind] = ...
    Fatal: ClassVar[ElabSystemTaskKind] = ...
    Info: ClassVar[ElabSystemTaskKind] = ...
    StaticAssert: ClassVar[ElabSystemTaskKind] = ...
    Warning: ClassVar[ElabSystemTaskKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ElabSystemTaskSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def assertCondition(self) -> Expression: ...
    @property
    def message(self) -> str | None: ...
    @property
    def taskKind(self) -> ElabSystemTaskKind: ...

class ElabSystemTaskSyntax(MemberSyntax):
    arguments: ArgumentListSyntax
    name: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ElementSelectExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def selector(self) -> Expression: ...
    @property
    def value(self) -> Expression: ...

class ElementSelectExpressionSyntax(ExpressionSyntax):
    left: ExpressionSyntax
    select: ElementSelectSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ElementSelectSyntax(SyntaxNode):
    closeBracket: Token
    openBracket: Token
    selector: SelectorSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ElseClauseSyntax(SyntaxNode):
    clause: SyntaxNode
    elseKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ElseConstraintClauseSyntax(SyntaxNode):
    constraints: ConstraintItemSyntax
    elseKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ElsePropertyClauseSyntax(SyntaxNode):
    elseKeyword: Token
    expr: PropertyExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyArgumentExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyArgumentSyntax(ArgumentSyntax):
    placeholder: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyIdentifierNameSyntax(NameSyntax):
    placeholder: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyMemberSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyMemberSyntax(MemberSyntax):
    qualifiers: Incomplete
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyNonAnsiPortSyntax(NonAnsiPortSyntax):
    placeholder: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyPortConnectionSyntax(PortConnectionSyntax):
    placeholder: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyQueueExpressionSyntax(PrimaryExpressionSyntax):
    closeBrace: Token
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyStatementSyntax(StatementSyntax):
    semicolon: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyTimingCheckArgSyntax(TimingCheckArgSyntax):
    placeholder: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EnumType(IntegralType, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def baseType(self) -> Type: ...
    @property
    def systemId(self) -> int: ...

class EnumTypeSyntax(DataTypeSyntax):
    baseType: DataTypeSyntax
    closeBrace: Token
    dimensions: Incomplete
    keyword: Token
    members: Incomplete
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EnumValueSymbol(ValueSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def value(self) -> ConstantValue: ...

class EqualsAssertionArgClauseSyntax(SyntaxNode):
    equals: Token
    expr: PropertyExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class EqualsTypeClauseSyntax(SyntaxNode):
    equals: Token
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class EqualsValueClauseSyntax(SyntaxNode):
    equals: Token
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ErrorType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class EvalContext:
    class Frame:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def callLocation(self): ...
        @property
        def lookupLocation(self): ...
        @property
        def subroutine(self): ...
        @property
        def temporaries(self): ...
    queueTarget: Incomplete
    def __init__(self, astCtx, flags: EvalFlags = ...) -> None: ...
    def createLocal(self, *args, **kwargs): ...
    def deleteLocal(self, symbol) -> None: ...
    def dumpStack(self) -> str: ...
    def findLocal(self, *args, **kwargs): ...
    def popFrame(self) -> None: ...
    def popLValue(self) -> None: ...
    def pushEmptyFrame(self) -> None: ...
    def pushFrame(self, subroutine, callLocation, lookupLocation) -> bool: ...
    def pushLValue(self, lval) -> None: ...
    def setDisableTarget(self, arg0, arg1) -> None: ...
    def step(self, loc) -> bool: ...
    @property
    def cacheResults(self) -> bool: ...
    @property
    def diagnostics(self): ...
    @property
    def disableRange(self): ...
    @property
    def disableTarget(self): ...
    @property
    def flags(self) -> EvalFlags: ...
    @property
    def inFunction(self) -> bool: ...
    @property
    def topFrame(self): ...
    @property
    def topLValue(self): ...

class EvalFlags:
    __members__: ClassVar[dict] = ...  # read-only
    AllowUnboundedPlaceholder: ClassVar[EvalFlags] = ...
    CacheResults: ClassVar[EvalFlags] = ...
    CovergroupExpr: ClassVar[EvalFlags] = ...
    IsScript: ClassVar[EvalFlags] = ...
    None_: ClassVar[EvalFlags] = ...
    SpecparamsAllowed: ClassVar[EvalFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class EvalResult:
    __members__: ClassVar[dict] = ...  # read-only
    Break: ClassVar[EvalResult] = ...
    Continue: ClassVar[EvalResult] = ...
    Disable: ClassVar[EvalResult] = ...
    Fail: ClassVar[EvalResult] = ...
    Return: ClassVar[EvalResult] = ...
    Success: ClassVar[EvalResult] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class EvaluatedDimension:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def associativeType(self): ...
    @property
    def isRange(self) -> bool: ...
    @property
    def kind(self) -> DimensionKind: ...
    @property
    def queueMaxSize(self) -> int: ...
    @property
    def range(self): ...

class EventControlSyntax(TimingControlSyntax):
    at: Token
    eventName: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class EventControlWithExpressionSyntax(TimingControlSyntax):
    at: Token
    expr: EventExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class EventExpressionSyntax(SequenceExprSyntax):
    def __init__(self, *args, **kwargs) -> None: ...

class EventListControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def events(self) -> span[TimingControl]: ...

class EventTriggerStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isNonBlocking(self) -> bool: ...
    @property
    def target(self) -> Expression: ...
    @property
    def timing(self) -> TimingControl: ...

class EventTriggerStatementSyntax(StatementSyntax):
    name: NameSyntax
    semi: Token
    timing: TimingControlSyntax
    trigger: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EventType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class ExplicitAnsiPortSyntax(MemberSyntax):
    closeParen: Token
    direction: Token
    dot: Token
    expr: ExpressionSyntax
    name: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ExplicitImportSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def importName(self) -> str: ...
    @property
    def importedSymbol(self) -> Symbol: ...
    @property
    def isFromExport(self) -> bool: ...
    @property
    def package(self) -> PackageSymbol: ...
    @property
    def packageName(self) -> str: ...

class ExplicitNonAnsiPortSyntax(NonAnsiPortSyntax):
    closeParen: Token
    dot: Token
    expr: PortExpressionSyntax
    name: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class Expression:
    def __init__(self, *args, **kwargs) -> None: ...
    def eval(self, *args, **kwargs): ...
    def evalLValue(self, context: EvalContext) -> LValue: ...
    def getSymbolReference(self, *args, **kwargs): ...
    def isImplicitlyAssignableTo(self, compilation: Compilation, type) -> bool: ...
    def visit(self, f: object) -> None: ...
    @property
    def bad(self) -> bool: ...
    @property
    def constant(self): ...
    @property
    def effectiveWidth(self) -> int | None: ...
    @property
    def hasHierarchicalReference(self) -> bool: ...
    @property
    def isImplicitString(self) -> bool: ...
    @property
    def isUnsizedInteger(self) -> bool: ...
    @property
    def kind(self) -> ExpressionKind: ...
    @property
    def sourceRange(self): ...
    @property
    def syntax(self): ...
    @property
    def type(self): ...

class ExpressionConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self): ...
    @property
    def isSoft(self) -> bool: ...

class ExpressionConstraintSyntax(ConstraintItemSyntax):
    expr: ExpressionSyntax
    semi: Token
    soft: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ExpressionCoverageBinInitializerSyntax(CoverageBinInitializerSyntax):
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ExpressionKind:
    __members__: ClassVar[dict] = ...  # read-only
    ArbitrarySymbol: ClassVar[ExpressionKind] = ...
    AssertionInstance: ClassVar[ExpressionKind] = ...
    Assignment: ClassVar[ExpressionKind] = ...
    BinaryOp: ClassVar[ExpressionKind] = ...
    Call: ClassVar[ExpressionKind] = ...
    ClockingEvent: ClassVar[ExpressionKind] = ...
    Concatenation: ClassVar[ExpressionKind] = ...
    ConditionalOp: ClassVar[ExpressionKind] = ...
    Conversion: ClassVar[ExpressionKind] = ...
    CopyClass: ClassVar[ExpressionKind] = ...
    DataType: ClassVar[ExpressionKind] = ...
    Dist: ClassVar[ExpressionKind] = ...
    ElementSelect: ClassVar[ExpressionKind] = ...
    EmptyArgument: ClassVar[ExpressionKind] = ...
    HierarchicalValue: ClassVar[ExpressionKind] = ...
    Inside: ClassVar[ExpressionKind] = ...
    IntegerLiteral: ClassVar[ExpressionKind] = ...
    Invalid: ClassVar[ExpressionKind] = ...
    LValueReference: ClassVar[ExpressionKind] = ...
    MemberAccess: ClassVar[ExpressionKind] = ...
    MinTypMax: ClassVar[ExpressionKind] = ...
    NamedValue: ClassVar[ExpressionKind] = ...
    NewArray: ClassVar[ExpressionKind] = ...
    NewClass: ClassVar[ExpressionKind] = ...
    NewCovergroup: ClassVar[ExpressionKind] = ...
    NullLiteral: ClassVar[ExpressionKind] = ...
    RangeSelect: ClassVar[ExpressionKind] = ...
    RealLiteral: ClassVar[ExpressionKind] = ...
    ReplicatedAssignmentPattern: ClassVar[ExpressionKind] = ...
    Replication: ClassVar[ExpressionKind] = ...
    SimpleAssignmentPattern: ClassVar[ExpressionKind] = ...
    Streaming: ClassVar[ExpressionKind] = ...
    StringLiteral: ClassVar[ExpressionKind] = ...
    StructuredAssignmentPattern: ClassVar[ExpressionKind] = ...
    TaggedUnion: ClassVar[ExpressionKind] = ...
    TimeLiteral: ClassVar[ExpressionKind] = ...
    TypeReference: ClassVar[ExpressionKind] = ...
    UnaryOp: ClassVar[ExpressionKind] = ...
    UnbasedUnsizedIntegerLiteral: ClassVar[ExpressionKind] = ...
    UnboundedLiteral: ClassVar[ExpressionKind] = ...
    ValueRange: ClassVar[ExpressionKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ExpressionOrDistSyntax(ExpressionSyntax):
    distribution: DistConstraintListSyntax
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ExpressionPatternSyntax(PatternSyntax):
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ExpressionStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> Expression: ...

class ExpressionStatementSyntax(StatementSyntax):
    expr: ExpressionSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ExpressionSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ExpressionTimingCheckArgSyntax(TimingCheckArgSyntax):
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ExtendsClauseSyntax(SyntaxNode):
    arguments: ArgumentListSyntax
    baseName: NameSyntax
    defaultedArg: DefaultExtendsClauseArgSyntax
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ExternInterfaceMethodSyntax(MemberSyntax):
    externKeyword: Token
    forkJoin: Token
    prototype: FunctionPrototypeSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ExternModuleDeclSyntax(MemberSyntax):
    actualAttributes: Incomplete
    externKeyword: Token
    header: ModuleHeaderSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ExternUdpDeclSyntax(MemberSyntax):
    actualAttributes: Incomplete
    externKeyword: Token
    name: Token
    portList: UdpPortListSyntax
    primitive: Token
    def __init__(self, *args, **kwargs) -> None: ...

class FieldSymbol(VariableSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def bitOffset(self) -> int: ...
    @property
    def fieldIndex(self) -> int: ...
    @property
    def randMode(self) -> RandMode: ...

class FilePathSpecSyntax(SyntaxNode):
    path: Token
    def __init__(self, *args, **kwargs) -> None: ...

class FirstMatchAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def matchItems(self): ...
    @property
    def seq(self) -> AssertionExpr: ...

class FirstMatchSequenceExprSyntax(SequenceExprSyntax):
    closeParen: Token
    expr: SequenceExprSyntax
    first_match: Token
    matchList: SequenceMatchListSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class FixedSizeUnpackedArrayType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elementType(self) -> Type: ...
    @property
    def range(self) -> ConstantRange: ...

class FloatingType(Type):
    class Kind:
        __members__: ClassVar[dict] = ...  # read-only
        Real: ClassVar[FloatingType.Kind] = ...
        RealTime: ClassVar[FloatingType.Kind] = ...
        ShortReal: ClassVar[FloatingType.Kind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Real: ClassVar[FloatingType.Kind] = ...
    RealTime: ClassVar[FloatingType.Kind] = ...
    ShortReal: ClassVar[FloatingType.Kind] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def floatKind(self): ...

class ForLoopStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self) -> Statement: ...
    @property
    def initializers(self) -> span[Expression]: ...
    @property
    def loopVars(self): ...
    @property
    def steps(self) -> span[Expression]: ...
    @property
    def stopExpr(self) -> Expression: ...

class ForLoopStatementSyntax(StatementSyntax):
    closeParen: Token
    forKeyword: Token
    initializers: Incomplete
    openParen: Token
    semi1: Token
    semi2: Token
    statement: StatementSyntax
    steps: Incomplete
    stopExpr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ForVariableDeclarationSyntax(SyntaxNode):
    declarator: DeclaratorSyntax
    type: DataTypeSyntax
    varKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ForeachConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arrayRef(self): ...
    @property
    def body(self) -> Constraint: ...
    @property
    def loopDims(self): ...

class ForeachLoopListSyntax(SyntaxNode):
    arrayName: NameSyntax
    closeBracket: Token
    closeParen: Token
    loopVariables: Incomplete
    openBracket: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ForeachLoopStatement(Statement):
    class LoopDim:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def loopVar(self): ...
        @property
        def range(self) -> ConstantRange | None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arrayRef(self) -> Expression: ...
    @property
    def body(self) -> Statement: ...
    @property
    def loopDims(self): ...

class ForeachLoopStatementSyntax(StatementSyntax):
    keyword: Token
    loopList: ForeachLoopListSyntax
    statement: StatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ForeverLoopStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self) -> Statement: ...

class ForeverStatementSyntax(StatementSyntax):
    foreverKeyword: Token
    statement: StatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class FormalArgumentSymbol(VariableSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def defaultValue(self) -> Expression: ...
    @property
    def direction(self) -> ArgumentDirection: ...

class ForwardTypeRestriction:
    __members__: ClassVar[dict] = ...  # read-only
    Class: ClassVar[ForwardTypeRestriction] = ...
    Enum: ClassVar[ForwardTypeRestriction] = ...
    InterfaceClass: ClassVar[ForwardTypeRestriction] = ...
    None_: ClassVar[ForwardTypeRestriction] = ...
    Struct: ClassVar[ForwardTypeRestriction] = ...
    Union: ClassVar[ForwardTypeRestriction] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ForwardTypeRestrictionSyntax(SyntaxNode):
    keyword1: Token
    keyword2: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ForwardTypedefDeclarationSyntax(MemberSyntax):
    name: Token
    semi: Token
    typeRestriction: ForwardTypeRestrictionSyntax
    typedefKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ForwardingTypedefSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def nextForwardDecl(self) -> ForwardingTypedefSymbol: ...
    @property
    def typeRestriction(self) -> ForwardTypeRestriction: ...
    @property
    def visibility(self) -> Visibility | None: ...

class FunctionDeclarationSyntax(MemberSyntax):
    end: Token
    endBlockName: NamedBlockClauseSyntax
    items: Incomplete
    prototype: FunctionPrototypeSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class FunctionPortBaseSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class FunctionPortListSyntax(SyntaxNode):
    closeParen: Token
    openParen: Token
    ports: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class FunctionPortSyntax(FunctionPortBaseSyntax):
    attributes: Incomplete
    constKeyword: Token
    dataType: DataTypeSyntax
    declarator: DeclaratorSyntax
    direction: Token
    staticKeyword: Token
    varKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class FunctionPrototypeSyntax(SyntaxNode):
    keyword: Token
    lifetime: Token
    name: NameSyntax
    portList: FunctionPortListSyntax
    returnType: DataTypeSyntax
    specifiers: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class GenerateBlockArraySymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def constructIndex(self) -> int: ...
    @property
    def entries(self) -> span[GenerateBlockSymbol]: ...
    @property
    def externalName(self) -> str: ...
    @property
    def valid(self) -> bool: ...

class GenerateBlockSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arrayIndex(self) -> SVInt: ...
    @property
    def constructIndex(self) -> int: ...
    @property
    def externalName(self) -> str: ...
    @property
    def isUninstantiated(self) -> bool: ...

class GenerateBlockSyntax(MemberSyntax):
    begin: Token
    beginName: NamedBlockClauseSyntax
    end: Token
    endName: NamedBlockClauseSyntax
    label: NamedLabelSyntax
    members: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class GenerateRegionSyntax(MemberSyntax):
    endgenerate: Token
    keyword: Token
    members: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class GenericClassDefSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def defaultSpecialization(self) -> Type: ...
    @property
    def firstForwardDecl(self) -> ForwardingTypedefSymbol: ...
    @property
    def invalidSpecialization(self) -> Type: ...
    @property
    def isInterface(self) -> bool: ...

class GenvarDeclarationSyntax(MemberSyntax):
    identifiers: Incomplete
    keyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class GenvarSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...

class HierarchicalInstanceSyntax(SyntaxNode):
    closeParen: Token
    connections: Incomplete
    decl: InstanceNameSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class HierarchicalValueExpression(ValueExpressionBase):
    def __init__(self, *args, **kwargs) -> None: ...

class HierarchyInstantiationSyntax(MemberSyntax):
    instances: Incomplete
    parameters: ParameterValueAssignmentSyntax
    semi: Token
    type: Token
    def __init__(self, *args, **kwargs) -> None: ...

class IdWithExprCoverageBinInitializerSyntax(CoverageBinInitializerSyntax):
    id: Token
    withClause: WithClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class IdentifierNameSyntax(NameSyntax):
    identifier: Token
    def __init__(self, *args, **kwargs) -> None: ...

class IdentifierSelectNameSyntax(NameSyntax):
    identifier: Token
    selectors: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class IfGenerateSyntax(MemberSyntax):
    block: MemberSyntax
    closeParen: Token
    condition: ExpressionSyntax
    elseClause: ElseClauseSyntax
    keyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class IfNonePathDeclarationSyntax(MemberSyntax):
    keyword: Token
    path: PathDeclarationSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class IffEventClauseSyntax(SyntaxNode):
    expr: ExpressionSyntax
    iff: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ImmediateAssertionMemberSyntax(MemberSyntax):
    statement: ImmediateAssertionStatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ImmediateAssertionStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def assertionKind(self) -> AssertionKind: ...
    @property
    def cond(self) -> Expression: ...
    @property
    def ifFalse(self) -> Statement: ...
    @property
    def ifTrue(self) -> Statement: ...
    @property
    def isDeferred(self) -> bool: ...
    @property
    def isFinal(self) -> bool: ...

class ImmediateAssertionStatementSyntax(StatementSyntax):
    action: ActionBlockSyntax
    delay: DeferredAssertionSyntax
    expr: ParenthesizedExpressionSyntax
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ImplementsClauseSyntax(SyntaxNode):
    interfaces: Incomplete
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ImplicationConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self) -> Constraint: ...
    @property
    def predicate(self): ...

class ImplicationConstraintSyntax(ConstraintItemSyntax):
    arrow: Token
    constraints: ConstraintItemSyntax
    left: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ImplicitAnsiPortSyntax(MemberSyntax):
    declarator: DeclaratorSyntax
    header: PortHeaderSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ImplicitEventControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...

class ImplicitEventControlSyntax(TimingControlSyntax):
    at: Token
    closeParen: Token
    openParen: Token
    star: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ImplicitNonAnsiPortSyntax(NonAnsiPortSyntax):
    expr: PortExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ImplicitTypeSyntax(DataTypeSyntax):
    dimensions: Incomplete
    placeholder: Token
    signing: Token
    def __init__(self, *args, **kwargs) -> None: ...

class IncludeDirectiveSyntax(DirectiveSyntax):
    fileName: Token
    def __init__(self, *args, **kwargs) -> None: ...

class IncludeMetadata:
    def __init__(self) -> None: ...
    @property
    def buffer(self) -> SourceBuffer: ...
    @property
    def isSystem(self) -> bool: ...
    @property
    def path(self) -> str: ...
    @property
    def syntax(self): ...

class InsideExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def left(self) -> Expression: ...
    @property
    def rangeList(self) -> span[Expression]: ...

class InsideExpressionSyntax(ExpressionSyntax):
    expr: ExpressionSyntax
    inside: Token
    ranges: RangeListSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class InstanceArraySymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arrayName(self) -> str: ...
    @property
    def elements(self) -> span[Symbol]: ...
    @property
    def range(self) -> ConstantRange: ...

class InstanceBodySymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    def findPort(self, portName: str) -> Symbol: ...
    def hasSameType(self, other: InstanceBodySymbol) -> bool: ...
    @property
    def definition(self) -> DefinitionSymbol: ...
    @property
    def parameters(self) -> span[ParameterSymbolBase]: ...
    @property
    def parentInstance(self) -> InstanceSymbol: ...
    @property
    def portList(self) -> span[Symbol]: ...

class InstanceConfigRuleSyntax(ConfigRuleSyntax):
    instance: Token
    instanceNames: Incomplete
    ruleClause: ConfigRuleClauseSyntax
    semi: Token
    topModule: Token
    def __init__(self, *args, **kwargs) -> None: ...

class InstanceNameSyntax(SyntaxNode):
    dimensions: Incomplete
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class InstanceSymbol(InstanceSymbolBase):
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def getPortConnection(self, port: PortSymbol) -> PortConnection: ...
    @overload
    def getPortConnection(self, port: MultiPortSymbol) -> PortConnection: ...
    @overload
    def getPortConnection(self, port: InterfacePortSymbol) -> PortConnection: ...
    @property
    def body(self): ...
    @property
    def canonicalBody(self): ...
    @property
    def definition(self) -> DefinitionSymbol: ...
    @property
    def isInterface(self) -> bool: ...
    @property
    def isModule(self) -> bool: ...
    @property
    def portConnections(self) -> span[PortConnection]: ...

class InstanceSymbolBase(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arrayName(self) -> str: ...
    @property
    def arrayPath(self) -> span[int]: ...

class IntegerLiteral(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isDeclaredUnsized(self) -> bool: ...
    @property
    def value(self): ...

class IntegerTypeSyntax(DataTypeSyntax):
    dimensions: Incomplete
    keyword: Token
    signing: Token
    def __init__(self, *args, **kwargs) -> None: ...

class IntegerVectorExpressionSyntax(PrimaryExpressionSyntax):
    base: Token
    size: Token
    value: Token
    def __init__(self, *args, **kwargs) -> None: ...

class IntegralFlags:
    __members__: ClassVar[dict] = ...  # read-only
    FourState: ClassVar[IntegralFlags] = ...
    Reg: ClassVar[IntegralFlags] = ...
    Signed: ClassVar[IntegralFlags] = ...
    TwoState: ClassVar[IntegralFlags] = ...
    Unsigned: ClassVar[IntegralFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class IntegralType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    def getBitVectorRange(self) -> ConstantRange: ...
    def isDeclaredReg(self) -> bool: ...

class InterfacePortHeaderSyntax(PortHeaderSyntax):
    modport: DotMemberClauseSyntax
    nameOrKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class InterfacePortSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def connection(self): ...
    @property
    def declaredRange(self) -> span[ConstantRange] | None: ...
    @property
    def interfaceDef(self) -> DefinitionSymbol: ...
    @property
    def isGeneric(self) -> bool: ...
    @property
    def isInvalid(self) -> bool: ...
    @property
    def modport(self) -> str: ...

class IntersectClauseSyntax(SyntaxNode):
    intersect: Token
    ranges: RangeListSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class InvalidAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...

class InvalidBinsSelectExpr(BinsSelectExpr):
    def __init__(self, *args, **kwargs) -> None: ...

class InvalidConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...

class InvalidExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...

class InvalidPattern(Pattern):
    def __init__(self, *args, **kwargs) -> None: ...

class InvalidStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...

class InvalidTimingControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...

class InvocationExpressionSyntax(ExpressionSyntax):
    arguments: ArgumentListSyntax
    attributes: Incomplete
    left: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class IteratorSymbol(TempVarSymbol):
    def __init__(self, *args, **kwargs) -> None: ...

class JumpStatementSyntax(StatementSyntax):
    breakOrContinue: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class KeywordNameSyntax(NameSyntax):
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class KeywordTypeSyntax(DataTypeSyntax):
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class KnownSystemName:
    __members__: ClassVar[dict] = ...  # read-only
    $acos: ClassVar[KnownSystemName] = ...
    $acosh: ClassVar[KnownSystemName] = ...
    $asin: ClassVar[KnownSystemName] = ...
    $asinh: ClassVar[KnownSystemName] = ...
    $assertcontrol: ClassVar[KnownSystemName] = ...
    $assertfailoff: ClassVar[KnownSystemName] = ...
    $assertfailon: ClassVar[KnownSystemName] = ...
    $assertkill: ClassVar[KnownSystemName] = ...
    $assertnonvacuouson: ClassVar[KnownSystemName] = ...
    $assertoff: ClassVar[KnownSystemName] = ...
    $asserton: ClassVar[KnownSystemName] = ...
    $assertpassoff: ClassVar[KnownSystemName] = ...
    $assertpasson: ClassVar[KnownSystemName] = ...
    $assertvacuousoff: ClassVar[KnownSystemName] = ...
    $async$and$array: ClassVar[KnownSystemName] = ...
    $async$and$plane: ClassVar[KnownSystemName] = ...
    $async$nand$array: ClassVar[KnownSystemName] = ...
    $async$nand$plane: ClassVar[KnownSystemName] = ...
    $async$nor$array: ClassVar[KnownSystemName] = ...
    $async$nor$plane: ClassVar[KnownSystemName] = ...
    $async$or$array: ClassVar[KnownSystemName] = ...
    $async$or$plane: ClassVar[KnownSystemName] = ...
    $atan: ClassVar[KnownSystemName] = ...
    $atan2: ClassVar[KnownSystemName] = ...
    $atanh: ClassVar[KnownSystemName] = ...
    $bits: ClassVar[KnownSystemName] = ...
    $bitstoreal: ClassVar[KnownSystemName] = ...
    $bitstoshortreal: ClassVar[KnownSystemName] = ...
    $cast: ClassVar[KnownSystemName] = ...
    $ceil: ClassVar[KnownSystemName] = ...
    $changed: ClassVar[KnownSystemName] = ...
    $changed_gclk: ClassVar[KnownSystemName] = ...
    $changing_gclk: ClassVar[KnownSystemName] = ...
    $clog2: ClassVar[KnownSystemName] = ...
    $cos: ClassVar[KnownSystemName] = ...
    $cosh: ClassVar[KnownSystemName] = ...
    $countbits: ClassVar[KnownSystemName] = ...
    $countdrivers: ClassVar[KnownSystemName] = ...
    $countones: ClassVar[KnownSystemName] = ...
    $coverage_control: ClassVar[KnownSystemName] = ...
    $coverage_get: ClassVar[KnownSystemName] = ...
    $coverage_get_max: ClassVar[KnownSystemName] = ...
    $coverage_merge: ClassVar[KnownSystemName] = ...
    $coverage_save: ClassVar[KnownSystemName] = ...
    $dimensions: ClassVar[KnownSystemName] = ...
    $display: ClassVar[KnownSystemName] = ...
    $displayb: ClassVar[KnownSystemName] = ...
    $displayh: ClassVar[KnownSystemName] = ...
    $displayo: ClassVar[KnownSystemName] = ...
    $dist_chi_square: ClassVar[KnownSystemName] = ...
    $dist_erlang: ClassVar[KnownSystemName] = ...
    $dist_exponential: ClassVar[KnownSystemName] = ...
    $dist_normal: ClassVar[KnownSystemName] = ...
    $dist_poisson: ClassVar[KnownSystemName] = ...
    $dist_t: ClassVar[KnownSystemName] = ...
    $dist_uniform: ClassVar[KnownSystemName] = ...
    $dumpall: ClassVar[KnownSystemName] = ...
    $dumpfile: ClassVar[KnownSystemName] = ...
    $dumpflush: ClassVar[KnownSystemName] = ...
    $dumplimit: ClassVar[KnownSystemName] = ...
    $dumpoff: ClassVar[KnownSystemName] = ...
    $dumpon: ClassVar[KnownSystemName] = ...
    $dumpports: ClassVar[KnownSystemName] = ...
    $dumpportsall: ClassVar[KnownSystemName] = ...
    $dumpportsflush: ClassVar[KnownSystemName] = ...
    $dumpportslimit: ClassVar[KnownSystemName] = ...
    $dumpportsoff: ClassVar[KnownSystemName] = ...
    $dumpportson: ClassVar[KnownSystemName] = ...
    $dumpvars: ClassVar[KnownSystemName] = ...
    $error: ClassVar[KnownSystemName] = ...
    $exit: ClassVar[KnownSystemName] = ...
    $exp: ClassVar[KnownSystemName] = ...
    $falling_gclk: ClassVar[KnownSystemName] = ...
    $fatal: ClassVar[KnownSystemName] = ...
    $fclose: ClassVar[KnownSystemName] = ...
    $fdisplay: ClassVar[KnownSystemName] = ...
    $fdisplayb: ClassVar[KnownSystemName] = ...
    $fdisplayh: ClassVar[KnownSystemName] = ...
    $fdisplayo: ClassVar[KnownSystemName] = ...
    $fell: ClassVar[KnownSystemName] = ...
    $fell_gclk: ClassVar[KnownSystemName] = ...
    $feof: ClassVar[KnownSystemName] = ...
    $ferror: ClassVar[KnownSystemName] = ...
    $fflush: ClassVar[KnownSystemName] = ...
    $fgetc: ClassVar[KnownSystemName] = ...
    $fgets: ClassVar[KnownSystemName] = ...
    $finish: ClassVar[KnownSystemName] = ...
    $floor: ClassVar[KnownSystemName] = ...
    $fmonitor: ClassVar[KnownSystemName] = ...
    $fmonitorb: ClassVar[KnownSystemName] = ...
    $fmonitorh: ClassVar[KnownSystemName] = ...
    $fmonitoro: ClassVar[KnownSystemName] = ...
    $fopen: ClassVar[KnownSystemName] = ...
    $fread: ClassVar[KnownSystemName] = ...
    $fscanf: ClassVar[KnownSystemName] = ...
    $fseek: ClassVar[KnownSystemName] = ...
    $fstrobe: ClassVar[KnownSystemName] = ...
    $fstrobeb: ClassVar[KnownSystemName] = ...
    $fstrobeh: ClassVar[KnownSystemName] = ...
    $fstrobeo: ClassVar[KnownSystemName] = ...
    $ftell: ClassVar[KnownSystemName] = ...
    $future_gclk: ClassVar[KnownSystemName] = ...
    $fwrite: ClassVar[KnownSystemName] = ...
    $fwriteb: ClassVar[KnownSystemName] = ...
    $fwriteh: ClassVar[KnownSystemName] = ...
    $fwriteo: ClassVar[KnownSystemName] = ...
    $get_coverage: ClassVar[KnownSystemName] = ...
    $getpattern: ClassVar[KnownSystemName] = ...
    $global_clock: ClassVar[KnownSystemName] = ...
    $high: ClassVar[KnownSystemName] = ...
    $hypot: ClassVar[KnownSystemName] = ...
    $increment: ClassVar[KnownSystemName] = ...
    $incsave: ClassVar[KnownSystemName] = ...
    $inferred_clock: ClassVar[KnownSystemName] = ...
    $inferred_disable: ClassVar[KnownSystemName] = ...
    $info: ClassVar[KnownSystemName] = ...
    $input: ClassVar[KnownSystemName] = ...
    $isunbounded: ClassVar[KnownSystemName] = ...
    $isunknown: ClassVar[KnownSystemName] = ...
    $itor: ClassVar[KnownSystemName] = ...
    $key: ClassVar[KnownSystemName] = ...
    $left: ClassVar[KnownSystemName] = ...
    $list: ClassVar[KnownSystemName] = ...
    $ln: ClassVar[KnownSystemName] = ...
    $load_coverage_db: ClassVar[KnownSystemName] = ...
    $log: ClassVar[KnownSystemName] = ...
    $log10: ClassVar[KnownSystemName] = ...
    $low: ClassVar[KnownSystemName] = ...
    $monitor: ClassVar[KnownSystemName] = ...
    $monitorb: ClassVar[KnownSystemName] = ...
    $monitorh: ClassVar[KnownSystemName] = ...
    $monitoro: ClassVar[KnownSystemName] = ...
    $monitoroff: ClassVar[KnownSystemName] = ...
    $monitoron: ClassVar[KnownSystemName] = ...
    $nokey: ClassVar[KnownSystemName] = ...
    $nolog: ClassVar[KnownSystemName] = ...
    $onehot: ClassVar[KnownSystemName] = ...
    $onehot0: ClassVar[KnownSystemName] = ...
    $past: ClassVar[KnownSystemName] = ...
    $past_gclk: ClassVar[KnownSystemName] = ...
    $pow: ClassVar[KnownSystemName] = ...
    $printtimescale: ClassVar[KnownSystemName] = ...
    $psprintf: ClassVar[KnownSystemName] = ...
    $q_add: ClassVar[KnownSystemName] = ...
    $q_exam: ClassVar[KnownSystemName] = ...
    $q_full: ClassVar[KnownSystemName] = ...
    $q_initialize: ClassVar[KnownSystemName] = ...
    $q_remove: ClassVar[KnownSystemName] = ...
    $random: ClassVar[KnownSystemName] = ...
    $readmemb: ClassVar[KnownSystemName] = ...
    $readmemh: ClassVar[KnownSystemName] = ...
    $realtime: ClassVar[KnownSystemName] = ...
    $realtobits: ClassVar[KnownSystemName] = ...
    $reset: ClassVar[KnownSystemName] = ...
    $reset_count: ClassVar[KnownSystemName] = ...
    $reset_value: ClassVar[KnownSystemName] = ...
    $restart: ClassVar[KnownSystemName] = ...
    $rewind: ClassVar[KnownSystemName] = ...
    $right: ClassVar[KnownSystemName] = ...
    $rising_gclk: ClassVar[KnownSystemName] = ...
    $rose: ClassVar[KnownSystemName] = ...
    $rose_gclk: ClassVar[KnownSystemName] = ...
    $rtoi: ClassVar[KnownSystemName] = ...
    $sampled: ClassVar[KnownSystemName] = ...
    $save: ClassVar[KnownSystemName] = ...
    $scale: ClassVar[KnownSystemName] = ...
    $scope: ClassVar[KnownSystemName] = ...
    $sdf_annotate: ClassVar[KnownSystemName] = ...
    $set_coverage_db_name: ClassVar[KnownSystemName] = ...
    $sformat: ClassVar[KnownSystemName] = ...
    $sformatf: ClassVar[KnownSystemName] = ...
    $shortrealtobits: ClassVar[KnownSystemName] = ...
    $showscopes: ClassVar[KnownSystemName] = ...
    $showvars: ClassVar[KnownSystemName] = ...
    $signed: ClassVar[KnownSystemName] = ...
    $sin: ClassVar[KnownSystemName] = ...
    $sinh: ClassVar[KnownSystemName] = ...
    $size: ClassVar[KnownSystemName] = ...
    $sqrt: ClassVar[KnownSystemName] = ...
    $sreadmemb: ClassVar[KnownSystemName] = ...
    $sreadmemh: ClassVar[KnownSystemName] = ...
    $sscanf: ClassVar[KnownSystemName] = ...
    $stable: ClassVar[KnownSystemName] = ...
    $stable_gclk: ClassVar[KnownSystemName] = ...
    $stacktrace: ClassVar[KnownSystemName] = ...
    $static_assert: ClassVar[KnownSystemName] = ...
    $steady_gclk: ClassVar[KnownSystemName] = ...
    $stime: ClassVar[KnownSystemName] = ...
    $stop: ClassVar[KnownSystemName] = ...
    $strobe: ClassVar[KnownSystemName] = ...
    $strobeb: ClassVar[KnownSystemName] = ...
    $strobeh: ClassVar[KnownSystemName] = ...
    $strobeo: ClassVar[KnownSystemName] = ...
    $swrite: ClassVar[KnownSystemName] = ...
    $swriteb: ClassVar[KnownSystemName] = ...
    $swriteh: ClassVar[KnownSystemName] = ...
    $swriteo: ClassVar[KnownSystemName] = ...
    $sync$and$array: ClassVar[KnownSystemName] = ...
    $sync$and$plane: ClassVar[KnownSystemName] = ...
    $sync$nand$array: ClassVar[KnownSystemName] = ...
    $sync$nand$plane: ClassVar[KnownSystemName] = ...
    $sync$nor$array: ClassVar[KnownSystemName] = ...
    $sync$nor$plane: ClassVar[KnownSystemName] = ...
    $sync$or$array: ClassVar[KnownSystemName] = ...
    $sync$or$plane: ClassVar[KnownSystemName] = ...
    $system: ClassVar[KnownSystemName] = ...
    $tan: ClassVar[KnownSystemName] = ...
    $tanh: ClassVar[KnownSystemName] = ...
    $test$plusargs: ClassVar[KnownSystemName] = ...
    $time: ClassVar[KnownSystemName] = ...
    $timeformat: ClassVar[KnownSystemName] = ...
    $timeprecision: ClassVar[KnownSystemName] = ...
    $timeunit: ClassVar[KnownSystemName] = ...
    $typename: ClassVar[KnownSystemName] = ...
    $ungetc: ClassVar[KnownSystemName] = ...
    $unpacked_dimensions: ClassVar[KnownSystemName] = ...
    $unsigned: ClassVar[KnownSystemName] = ...
    $urandom: ClassVar[KnownSystemName] = ...
    $urandom_range: ClassVar[KnownSystemName] = ...
    $value$plusargs: ClassVar[KnownSystemName] = ...
    $warning: ClassVar[KnownSystemName] = ...
    $write: ClassVar[KnownSystemName] = ...
    $writeb: ClassVar[KnownSystemName] = ...
    $writeh: ClassVar[KnownSystemName] = ...
    $writememb: ClassVar[KnownSystemName] = ...
    $writememh: ClassVar[KnownSystemName] = ...
    $writeo: ClassVar[KnownSystemName] = ...
    Unknown: ClassVar[KnownSystemName] = ...
    __entries: ClassVar[dict] = ...
    atobin: ClassVar[KnownSystemName] = ...
    atohex: ClassVar[KnownSystemName] = ...
    atoi: ClassVar[KnownSystemName] = ...
    atooct: ClassVar[KnownSystemName] = ...
    atoreal: ClassVar[KnownSystemName] = ...
    bintoa: ClassVar[KnownSystemName] = ...
    compare: ClassVar[KnownSystemName] = ...
    constraint_mode: ClassVar[KnownSystemName] = ...
    delete: ClassVar[KnownSystemName] = ...
    exists: ClassVar[KnownSystemName] = ...
    find: ClassVar[KnownSystemName] = ...
    find_first: ClassVar[KnownSystemName] = ...
    find_first_index: ClassVar[KnownSystemName] = ...
    find_index: ClassVar[KnownSystemName] = ...
    find_last: ClassVar[KnownSystemName] = ...
    find_last_index: ClassVar[KnownSystemName] = ...
    first: ClassVar[KnownSystemName] = ...
    getc: ClassVar[KnownSystemName] = ...
    hextoa: ClassVar[KnownSystemName] = ...
    icompare: ClassVar[KnownSystemName] = ...
    index: ClassVar[KnownSystemName] = ...
    insert: ClassVar[KnownSystemName] = ...
    itoa: ClassVar[KnownSystemName] = ...
    last: ClassVar[KnownSystemName] = ...
    len: ClassVar[KnownSystemName] = ...
    map: ClassVar[KnownSystemName] = ...
    matched: ClassVar[KnownSystemName] = ...
    max: ClassVar[KnownSystemName] = ...
    min: ClassVar[KnownSystemName] = ...
    name: ClassVar[KnownSystemName] = ...
    next: ClassVar[KnownSystemName] = ...
    num: ClassVar[KnownSystemName] = ...
    octtoa: ClassVar[KnownSystemName] = ...
    pop_back: ClassVar[KnownSystemName] = ...
    pop_front: ClassVar[KnownSystemName] = ...
    prev: ClassVar[KnownSystemName] = ...
    product: ClassVar[KnownSystemName] = ...
    push_back: ClassVar[KnownSystemName] = ...
    push_front: ClassVar[KnownSystemName] = ...
    putc: ClassVar[KnownSystemName] = ...
    rand_mode: ClassVar[KnownSystemName] = ...
    randomize: ClassVar[KnownSystemName] = ...
    realtoa: ClassVar[KnownSystemName] = ...
    reverse: ClassVar[KnownSystemName] = ...
    rsort: ClassVar[KnownSystemName] = ...
    shuffle: ClassVar[KnownSystemName] = ...
    size: ClassVar[KnownSystemName] = ...
    sort: ClassVar[KnownSystemName] = ...
    substr: ClassVar[KnownSystemName] = ...
    sum: ClassVar[KnownSystemName] = ...
    tolower: ClassVar[KnownSystemName] = ...
    toupper: ClassVar[KnownSystemName] = ...
    triggered: ClassVar[KnownSystemName] = ...
    unique: ClassVar[KnownSystemName] = ...
    unique_index: ClassVar[KnownSystemName] = ...
    xor: ClassVar[KnownSystemName] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def value(self) -> int: ...

class LValue:
    def __init__(self) -> None: ...
    def bad(self) -> bool: ...
    def load(self, *args, **kwargs): ...
    def resolve(self, *args, **kwargs): ...
    def store(self, value) -> None: ...

class LValueReferenceExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...

class LanguageVersion:
    __members__: ClassVar[dict] = ...  # read-only
    Default: ClassVar[LanguageVersion] = ...
    __entries: ClassVar[dict] = ...
    v1800_2017: ClassVar[LanguageVersion] = ...
    v1800_2023: ClassVar[LanguageVersion] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LetDeclSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def ports(self) -> span[AssertionPortSymbol]: ...

class LetDeclarationSyntax(MemberSyntax):
    equals: Token
    expr: ExpressionSyntax
    identifier: Token
    let: Token
    portList: AssertionItemPortListSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class LexerOptions:
    languageVersion: LanguageVersion
    maxErrors: int
    def __init__(self) -> None: ...

class LibraryDeclarationSyntax(MemberSyntax):
    filePaths: Incomplete
    incDirClause: LibraryIncDirClauseSyntax
    library: Token
    name: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class LibraryIncDirClauseSyntax(SyntaxNode):
    filePaths: Incomplete
    incdir: Token
    minus: Token
    def __init__(self, *args, **kwargs) -> None: ...

class LibraryIncludeStatementSyntax(MemberSyntax):
    filePath: FilePathSpecSyntax
    include: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class LibraryMapSyntax(SyntaxNode):
    endOfFile: Token
    members: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class LineDirectiveSyntax(DirectiveSyntax):
    fileName: Token
    level: Token
    lineNumber: Token
    def __init__(self, *args, **kwargs) -> None: ...

class LiteralBase:
    __members__: ClassVar[dict] = ...  # read-only
    Binary: ClassVar[LiteralBase] = ...
    Decimal: ClassVar[LiteralBase] = ...
    Hex: ClassVar[LiteralBase] = ...
    Octal: ClassVar[LiteralBase] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LiteralExpressionSyntax(PrimaryExpressionSyntax):
    literal: Token
    def __init__(self, *args, **kwargs) -> None: ...

class LocalAssertionVarSymbol(VariableSymbol):
    def __init__(self, *args, **kwargs) -> None: ...

class LocalVariableDeclarationSyntax(MemberSyntax):
    declarators: Incomplete
    semi: Token
    type: DataTypeSyntax
    var: Token
    def __init__(self, *args, **kwargs) -> None: ...

class Lookup:
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def ensureAccessible(symbol, context: ASTContext, sourceRange: SourceRange | None) -> bool: ...
    @staticmethod
    def ensureVisible(symbol, context: ASTContext, sourceRange: SourceRange | None) -> bool: ...
    @staticmethod
    def findAssertionLocalVar(context: ASTContext, name, result: LookupResult) -> bool: ...
    @staticmethod
    def findClass(*args, **kwargs): ...
    @staticmethod
    def findTempVar(scope, symbol, name, result: LookupResult) -> bool: ...
    @staticmethod
    def getContainingClass(*args, **kwargs): ...
    @staticmethod
    def getVisibility(symbol) -> Visibility: ...
    @staticmethod
    def isAccessibleFrom(target, sourceScope) -> bool: ...
    @staticmethod
    def isVisibleFrom(symbol, scope) -> bool: ...
    @staticmethod
    def name(syntax, context: ASTContext, flags: LookupFlags, result: LookupResult) -> None: ...
    @staticmethod
    def unqualified(*args, **kwargs): ...
    @staticmethod
    def unqualifiedAt(*args, **kwargs): ...
    @staticmethod
    def withinClassRandomize(context: ASTContext, syntax, flags: LookupFlags, result: LookupResult) -> bool: ...

class LookupFlags:
    __members__: ClassVar[dict] = ...  # read-only
    AllowDeclaredAfter: ClassVar[LookupFlags] = ...
    AllowIncompleteForwardTypedefs: ClassVar[LookupFlags] = ...
    AllowRoot: ClassVar[LookupFlags] = ...
    AllowUnit: ClassVar[LookupFlags] = ...
    AlwaysAllowUpward: ClassVar[LookupFlags] = ...
    DisallowUnitReferences: ClassVar[LookupFlags] = ...
    DisallowWildcardImport: ClassVar[LookupFlags] = ...
    ForceHierarchical: ClassVar[LookupFlags] = ...
    IfacePortConn: ClassVar[LookupFlags] = ...
    NoParentScope: ClassVar[LookupFlags] = ...
    NoSelectors: ClassVar[LookupFlags] = ...
    NoUndeclaredError: ClassVar[LookupFlags] = ...
    NoUndeclaredErrorIfUninstantiated: ClassVar[LookupFlags] = ...
    None_: ClassVar[LookupFlags] = ...
    StaticInitializer: ClassVar[LookupFlags] = ...
    Type: ClassVar[LookupFlags] = ...
    TypeReference: ClassVar[LookupFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LookupLocation:
    max: ClassVar[LookupLocation] = ...  # read-only
    min: ClassVar[LookupLocation] = ...  # read-only
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, scope, index: int) -> None: ...
    @staticmethod
    def after(symbol) -> LookupLocation: ...
    @staticmethod
    def before(symbol) -> LookupLocation: ...
    def __eq__(self, arg0: LookupLocation) -> bool: ...
    def __ne__(self, arg0: LookupLocation) -> bool: ...
    @property
    def index(self): ...
    @property
    def scope(self): ...

class LookupResult:
    class MemberSelector:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def dotLocation(self) -> SourceLocation: ...
        @property
        def name(self) -> str: ...
        @property
        def nameRange(self) -> SourceRange: ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def errorIfSelectors(self, context: ASTContext) -> None: ...
    def reportDiags(self, context: ASTContext) -> None: ...
    @property
    def diagnostics(self) -> Diagnostics: ...
    @property
    def flags(self) -> LookupResultFlags: ...
    @property
    def found(self): ...
    @property
    def hasError(self) -> bool: ...
    @property
    def selectors(self): ...
    @property
    def systemSubroutine(self) -> SystemSubroutine: ...
    @property
    def upwardCount(self) -> int: ...

class LookupResultFlags:
    __members__: ClassVar[dict] = ...  # read-only
    FromForwardTypedef: ClassVar[LookupResultFlags] = ...
    FromTypeParam: ClassVar[LookupResultFlags] = ...
    IsHierarchical: ClassVar[LookupResultFlags] = ...
    None_: ClassVar[LookupResultFlags] = ...
    SuppressUndeclared: ClassVar[LookupResultFlags] = ...
    WasImported: ClassVar[LookupResultFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LoopConstraintSyntax(ConstraintItemSyntax):
    constraints: ConstraintItemSyntax
    foreachKeyword: Token
    loopList: ForeachLoopListSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class LoopGenerateSyntax(MemberSyntax):
    block: MemberSyntax
    closeParen: Token
    equals: Token
    genvar: Token
    identifier: Token
    initialExpr: ExpressionSyntax
    iterationExpr: ExpressionSyntax
    keyword: Token
    openParen: Token
    semi1: Token
    semi2: Token
    stopExpr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class LoopStatementSyntax(StatementSyntax):
    closeParen: Token
    expr: ExpressionSyntax
    openParen: Token
    repeatOrWhile: Token
    statement: StatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class MacroActualArgumentListSyntax(SyntaxNode):
    args: Incomplete
    closeParen: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class MacroActualArgumentSyntax(SyntaxNode):
    tokens: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class MacroArgumentDefaultSyntax(SyntaxNode):
    equals: Token
    tokens: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class MacroFormalArgumentListSyntax(SyntaxNode):
    args: Incomplete
    closeParen: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class MacroFormalArgumentSyntax(SyntaxNode):
    defaultValue: MacroArgumentDefaultSyntax
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class MacroUsageSyntax(DirectiveSyntax):
    args: MacroActualArgumentListSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class MatchesClauseSyntax(SyntaxNode):
    matchesKeyword: Token
    pattern: PatternSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class MemberAccessExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def member(self): ...
    @property
    def value(self) -> Expression: ...

class MemberAccessExpressionSyntax(ExpressionSyntax):
    dot: Token
    left: ExpressionSyntax
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class MemberSyntax(SyntaxNode):
    attributes: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class MethodFlags:
    __members__: ClassVar[dict] = ...  # read-only
    BuiltIn: ClassVar[MethodFlags] = ...
    Constructor: ClassVar[MethodFlags] = ...
    DPIContext: ClassVar[MethodFlags] = ...
    DPIImport: ClassVar[MethodFlags] = ...
    DefaultedSuperArg: ClassVar[MethodFlags] = ...
    Extends: ClassVar[MethodFlags] = ...
    Final: ClassVar[MethodFlags] = ...
    ForkJoin: ClassVar[MethodFlags] = ...
    Initial: ClassVar[MethodFlags] = ...
    InterfaceExtern: ClassVar[MethodFlags] = ...
    ModportExport: ClassVar[MethodFlags] = ...
    ModportImport: ClassVar[MethodFlags] = ...
    None_: ClassVar[MethodFlags] = ...
    Pure: ClassVar[MethodFlags] = ...
    Randomize: ClassVar[MethodFlags] = ...
    Static: ClassVar[MethodFlags] = ...
    Virtual: ClassVar[MethodFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MethodPrototypeSymbol(Symbol, Scope):
    class ExternImpl:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def impl(self) -> SubroutineSymbol: ...
        @property
        def nextImpl(self) -> MethodPrototypeSymbol.ExternImpl: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self) -> span[FormalArgumentSymbol]: ...
    @property
    def firstExternImpl(self): ...
    @property
    def flags(self) -> MethodFlags: ...
    @property
    def isVirtual(self) -> bool: ...
    @property
    def override(self) -> Symbol: ...
    @property
    def returnType(self): ...
    @property
    def subroutine(self) -> SubroutineSymbol: ...
    @property
    def subroutineKind(self) -> SubroutineKind: ...
    @property
    def visibility(self) -> Visibility: ...

class MinTypMax:
    __members__: ClassVar[dict] = ...  # read-only
    Max: ClassVar[MinTypMax] = ...
    Min: ClassVar[MinTypMax] = ...
    Typ: ClassVar[MinTypMax] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MinTypMaxExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def max(self) -> Expression: ...
    @property
    def min(self) -> Expression: ...
    @property
    def selected(self) -> Expression: ...
    @property
    def typ(self) -> Expression: ...

class MinTypMaxExpressionSyntax(ExpressionSyntax):
    colon1: Token
    colon2: Token
    max: ExpressionSyntax
    min: ExpressionSyntax
    typ: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ModportClockingPortSyntax(MemberSyntax):
    clocking: Token
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ModportClockingSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def target(self) -> Symbol: ...

class ModportDeclarationSyntax(MemberSyntax):
    items: Incomplete
    keyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ModportExplicitPortSyntax(ModportPortSyntax):
    closeParen: Token
    dot: Token
    expr: ExpressionSyntax
    name: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ModportItemSyntax(SyntaxNode):
    name: Token
    ports: AnsiPortListSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ModportNamedPortSyntax(ModportPortSyntax):
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ModportPortSymbol(ValueSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def direction(self) -> ArgumentDirection: ...
    @property
    def explicitConnection(self) -> Expression: ...
    @property
    def internalSymbol(self) -> Symbol: ...

class ModportPortSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ModportSimplePortListSyntax(MemberSyntax):
    direction: Token
    ports: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ModportSubroutinePortListSyntax(MemberSyntax):
    importExport: Token
    ports: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ModportSubroutinePortSyntax(ModportPortSyntax):
    prototype: FunctionPrototypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ModportSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def hasExports(self) -> bool: ...

class ModuleDeclarationSyntax(MemberSyntax):
    blockName: NamedBlockClauseSyntax
    endmodule: Token
    header: ModuleHeaderSyntax
    members: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ModuleHeaderSyntax(SyntaxNode):
    imports: Incomplete
    lifetime: Token
    moduleKeyword: Token
    name: Token
    parameters: ParameterPortListSyntax
    ports: PortListSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class MultiPortSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def direction(self) -> ArgumentDirection: ...
    @property
    def initializer(self) -> Expression: ...
    @property
    def isNullPort(self) -> bool: ...
    @property
    def ports(self) -> span[PortSymbol]: ...
    @property
    def type(self): ...

class MultipleConcatenationExpressionSyntax(PrimaryExpressionSyntax):
    closeBrace: Token
    concatenation: ConcatenationExpressionSyntax
    expression: ExpressionSyntax
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NameSyntax(ExpressionSyntax):
    def __init__(self, *args, **kwargs) -> None: ...

class NameValuePragmaExpressionSyntax(PragmaExpressionSyntax):
    equals: Token
    name: Token
    value: PragmaExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class NamedArgumentSyntax(ArgumentSyntax):
    closeParen: Token
    dot: Token
    expr: PropertyExprSyntax
    name: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NamedBlockClauseSyntax(SyntaxNode):
    colon: Token
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NamedConditionalDirectiveExpressionSyntax(ConditionalDirectiveExpressionSyntax):
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NamedLabelSyntax(SyntaxNode):
    colon: Token
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NamedParamAssignmentSyntax(ParamAssignmentSyntax):
    closeParen: Token
    dot: Token
    expr: ExpressionSyntax
    name: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NamedPortConnectionSyntax(PortConnectionSyntax):
    closeParen: Token
    dot: Token
    expr: PropertyExprSyntax
    name: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NamedStructurePatternMemberSyntax(StructurePatternMemberSyntax):
    colon: Token
    name: Token
    pattern: PatternSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class NamedTypeSyntax(DataTypeSyntax):
    name: NameSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class NamedValueExpression(ValueExpressionBase):
    def __init__(self, *args, **kwargs) -> None: ...

class NetAliasSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def netReferences(self) -> span[Expression]: ...

class NetAliasSyntax(MemberSyntax):
    keyword: Token
    nets: Incomplete
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NetDeclarationSyntax(MemberSyntax):
    declarators: Incomplete
    delay: TimingControlSyntax
    expansionHint: Token
    netType: Token
    semi: Token
    strength: NetStrengthSyntax
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class NetPortHeaderSyntax(PortHeaderSyntax):
    dataType: DataTypeSyntax
    direction: Token
    netType: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NetStrengthSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class NetSymbol(ValueSymbol):
    class ExpansionHint:
        __members__: ClassVar[dict] = ...  # read-only
        None_: ClassVar[NetSymbol.ExpansionHint] = ...
        Scalared: ClassVar[NetSymbol.ExpansionHint] = ...
        Vectored: ClassVar[NetSymbol.ExpansionHint] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    None_: ClassVar[NetSymbol.ExpansionHint] = ...
    Scalared: ClassVar[NetSymbol.ExpansionHint] = ...
    Vectored: ClassVar[NetSymbol.ExpansionHint] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def chargeStrength(self): ...
    @property
    def delay(self) -> TimingControl: ...
    @property
    def driveStrength(self): ...
    @property
    def expansionHint(self): ...
    @property
    def isImplicit(self) -> bool: ...
    @property
    def netType(self): ...

class NetType(Symbol):
    class NetKind:
        __members__: ClassVar[dict] = ...  # read-only
        Interconnect: ClassVar[NetType.NetKind] = ...
        Supply0: ClassVar[NetType.NetKind] = ...
        Supply1: ClassVar[NetType.NetKind] = ...
        Tri: ClassVar[NetType.NetKind] = ...
        Tri0: ClassVar[NetType.NetKind] = ...
        Tri1: ClassVar[NetType.NetKind] = ...
        TriAnd: ClassVar[NetType.NetKind] = ...
        TriOr: ClassVar[NetType.NetKind] = ...
        TriReg: ClassVar[NetType.NetKind] = ...
        UWire: ClassVar[NetType.NetKind] = ...
        Unknown: ClassVar[NetType.NetKind] = ...
        UserDefined: ClassVar[NetType.NetKind] = ...
        WAnd: ClassVar[NetType.NetKind] = ...
        WOr: ClassVar[NetType.NetKind] = ...
        Wire: ClassVar[NetType.NetKind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Interconnect: ClassVar[NetType.NetKind] = ...
    Supply0: ClassVar[NetType.NetKind] = ...
    Supply1: ClassVar[NetType.NetKind] = ...
    Tri: ClassVar[NetType.NetKind] = ...
    Tri0: ClassVar[NetType.NetKind] = ...
    Tri1: ClassVar[NetType.NetKind] = ...
    TriAnd: ClassVar[NetType.NetKind] = ...
    TriOr: ClassVar[NetType.NetKind] = ...
    TriReg: ClassVar[NetType.NetKind] = ...
    UWire: ClassVar[NetType.NetKind] = ...
    Unknown: ClassVar[NetType.NetKind] = ...
    UserDefined: ClassVar[NetType.NetKind] = ...
    WAnd: ClassVar[NetType.NetKind] = ...
    WOr: ClassVar[NetType.NetKind] = ...
    Wire: ClassVar[NetType.NetKind] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def getSimulatedNetType(internal: NetType, external: NetType, shouldWarn: bool) -> NetType: ...
    @property
    def declaredType(self): ...
    @property
    def isBuiltIn(self) -> bool: ...
    @property
    def isError(self) -> bool: ...
    @property
    def netKind(self): ...
    @property
    def resolutionFunction(self) -> SubroutineSymbol: ...

class NetTypeDeclarationSyntax(MemberSyntax):
    keyword: Token
    name: Token
    semi: Token
    type: DataTypeSyntax
    withFunction: WithFunctionClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class NewArrayExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def initExpr(self) -> Expression: ...
    @property
    def sizeExpr(self) -> Expression: ...

class NewArrayExpressionSyntax(ExpressionSyntax):
    closeBracket: Token
    initializer: ParenthesizedExpressionSyntax
    newKeyword: NameSyntax
    openBracket: Token
    sizeExpr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class NewClassExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def constructorCall(self) -> Expression: ...
    @property
    def isSuperClass(self) -> bool: ...

class NewClassExpressionSyntax(ExpressionSyntax):
    argList: ArgumentListSyntax
    scopedNew: NameSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class NewCovergroupExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self) -> span[Expression]: ...

class NonAnsiPortListSyntax(PortListSyntax):
    closeParen: Token
    openParen: Token
    ports: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class NonAnsiPortSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class NonAnsiUdpPortListSyntax(UdpPortListSyntax):
    closeParen: Token
    openParen: Token
    ports: Incomplete
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NonConstantFunction(SimpleSystemSubroutine):
    def __init__(self, name: str, returnType, requiredArgs: int = ..., argTypes=..., isMethod: bool = ...) -> None: ...

class Null:
    def __init__(self) -> None: ...

class NullLiteral(Expression):
    def __init__(self, *args, **kwargs) -> None: ...

class NullType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class NumberPragmaExpressionSyntax(PragmaExpressionSyntax):
    base: Token
    size: Token
    value: Token
    def __init__(self, *args, **kwargs) -> None: ...

class OneStepDelayControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...

class OneStepDelaySyntax(TimingControlSyntax):
    hash: Token
    oneStep: Token
    def __init__(self, *args, **kwargs) -> None: ...

class OrderedArgumentSyntax(ArgumentSyntax):
    expr: PropertyExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class OrderedParamAssignmentSyntax(ParamAssignmentSyntax):
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class OrderedPortConnectionSyntax(PortConnectionSyntax):
    expr: PropertyExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class OrderedStructurePatternMemberSyntax(StructurePatternMemberSyntax):
    pattern: PatternSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class PackageExportAllDeclarationSyntax(MemberSyntax):
    doubleColon: Token
    keyword: Token
    semi: Token
    star1: Token
    star2: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PackageExportDeclarationSyntax(MemberSyntax):
    items: Incomplete
    keyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PackageImportDeclarationSyntax(MemberSyntax):
    items: Incomplete
    keyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PackageImportItemSyntax(SyntaxNode):
    doubleColon: Token
    item: Token
    package: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PackageSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    def findForImport(self, name: str) -> Symbol: ...
    @property
    def defaultLifetime(self) -> VariableLifetime: ...
    @property
    def defaultNetType(self): ...
    @property
    def exportDecls(self): ...
    @property
    def hasExportAll(self) -> bool: ...
    @property
    def timeScale(self) -> TimeScale | None: ...

class PackedArrayType(IntegralType):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elementType(self) -> Type: ...
    @property
    def range(self) -> ConstantRange: ...

class PackedStructType(IntegralType, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def systemId(self) -> int: ...

class PackedUnionType(IntegralType, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isSoft(self) -> bool: ...
    @property
    def isTagged(self) -> bool: ...
    @property
    def systemId(self) -> int: ...
    @property
    def tagBits(self) -> int: ...

class ParamAssignmentSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ParameterDeclarationBaseSyntax(SyntaxNode):
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParameterDeclarationStatementSyntax(MemberSyntax):
    parameter: ParameterDeclarationBaseSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParameterDeclarationSyntax(ParameterDeclarationBaseSyntax):
    declarators: Incomplete
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ParameterPortListSyntax(SyntaxNode):
    closeParen: Token
    declarations: Incomplete
    hash: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParameterSymbol(ValueSymbol, ParameterSymbolBase):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isOverridden(self) -> bool: ...
    @property
    def value(self) -> ConstantValue: ...

class ParameterSymbolBase:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isBodyParam(self) -> bool: ...
    @property
    def isLocalParam(self) -> bool: ...
    @property
    def isPortParam(self) -> bool: ...

class ParameterValueAssignmentSyntax(SyntaxNode):
    closeParen: Token
    hash: Token
    openParen: Token
    parameters: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ParenExpressionListSyntax(SyntaxNode):
    closeParen: Token
    expressions: Incomplete
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParenPragmaExpressionSyntax(PragmaExpressionSyntax):
    closeParen: Token
    openParen: Token
    values: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ParenthesizedBinsSelectExprSyntax(BinsSelectExpressionSyntax):
    closeParen: Token
    expr: BinsSelectExpressionSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParenthesizedConditionalDirectiveExpressionSyntax(ConditionalDirectiveExpressionSyntax):
    closeParen: Token
    openParen: Token
    operand: ConditionalDirectiveExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ParenthesizedEventExpressionSyntax(EventExpressionSyntax):
    closeParen: Token
    expr: EventExpressionSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParenthesizedExpressionSyntax(PrimaryExpressionSyntax):
    closeParen: Token
    expression: ExpressionSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParenthesizedPatternSyntax(PatternSyntax):
    closeParen: Token
    openParen: Token
    pattern: PatternSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ParenthesizedPropertyExprSyntax(PropertyExprSyntax):
    closeParen: Token
    expr: PropertyExprSyntax
    matchList: SequenceMatchListSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParenthesizedSequenceExprSyntax(SequenceExprSyntax):
    closeParen: Token
    expr: SequenceExprSyntax
    matchList: SequenceMatchListSyntax
    openParen: Token
    repetition: SequenceRepetitionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ParserOptions:
    languageVersion: LanguageVersion
    maxRecursionDepth: int
    def __init__(self) -> None: ...

class PathDeclarationSyntax(MemberSyntax):
    closeParen: Token
    delays: Incomplete
    desc: PathDescriptionSyntax
    equals: Token
    openParen: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PathDescriptionSyntax(SyntaxNode):
    closeParen: Token
    edgeIdentifier: Token
    inputs: Incomplete
    openParen: Token
    pathOperator: Token
    polarityOperator: Token
    suffix: PathSuffixSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class PathSuffixSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class Pattern:
    def __init__(self, *args, **kwargs) -> None: ...
    def eval(self, *args, **kwargs): ...
    @property
    def bad(self) -> bool: ...
    @property
    def kind(self) -> PatternKind: ...
    @property
    def sourceRange(self): ...
    @property
    def syntax(self): ...

class PatternCaseItemSyntax(CaseItemSyntax):
    colon: Token
    expr: ExpressionSyntax
    pattern: PatternSyntax
    statement: StatementSyntax
    tripleAnd: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PatternCaseStatement(Statement):
    class ItemGroup:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def filter(self) -> Expression: ...
        @property
        def pattern(self) -> Pattern: ...
        @property
        def stmt(self) -> Statement: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def check(self) -> UniquePriorityCheck: ...
    @property
    def condition(self) -> CaseStatementCondition: ...
    @property
    def defaultCase(self) -> Statement: ...
    @property
    def expr(self) -> Expression: ...
    @property
    def items(self): ...

class PatternKind:
    __members__: ClassVar[dict] = ...  # read-only
    Constant: ClassVar[PatternKind] = ...
    Invalid: ClassVar[PatternKind] = ...
    Structure: ClassVar[PatternKind] = ...
    Tagged: ClassVar[PatternKind] = ...
    Variable: ClassVar[PatternKind] = ...
    Wildcard: ClassVar[PatternKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PatternSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class PatternVarSymbol(TempVarSymbol):
    def __init__(self, *args, **kwargs) -> None: ...

class PendingAnalysis:
    def __init__(self, *args, **kwargs) -> None: ...
    def tryGet(self) -> AnalyzedScope: ...
    @property
    def symbol(self): ...

class PortConcatenationSyntax(PortExpressionSyntax):
    closeBrace: Token
    openBrace: Token
    references: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class PortConnection:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expression(self) -> Expression: ...
    @property
    def ifaceConn(self): ...
    @property
    def port(self) -> Symbol: ...

class PortConnectionSyntax(SyntaxNode):
    attributes: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class PortDeclarationSyntax(MemberSyntax):
    declarators: Incomplete
    header: PortHeaderSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PortExpressionSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class PortHeaderSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class PortListSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class PortReferenceSyntax(PortExpressionSyntax):
    name: Token
    select: ElementSelectSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class PortSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def direction(self) -> ArgumentDirection: ...
    @property
    def externalLoc(self) -> SourceLocation: ...
    @property
    def initializer(self) -> Expression: ...
    @property
    def internalExpr(self) -> Expression: ...
    @property
    def internalSymbol(self) -> Symbol: ...
    @property
    def isAnsiPort(self) -> bool: ...
    @property
    def isNetPort(self) -> bool: ...
    @property
    def isNullPort(self) -> bool: ...
    @property
    def type(self): ...

class PostfixUnaryExpressionSyntax(ExpressionSyntax):
    attributes: Incomplete
    operand: ExpressionSyntax
    operatorToken: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PragmaDirectiveSyntax(DirectiveSyntax):
    args: Incomplete
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PragmaExpressionSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class PredefinedIntegerType(IntegralType):
    class Kind:
        __members__: ClassVar[dict] = ...  # read-only
        Byte: ClassVar[PredefinedIntegerType.Kind] = ...
        Int: ClassVar[PredefinedIntegerType.Kind] = ...
        Integer: ClassVar[PredefinedIntegerType.Kind] = ...
        LongInt: ClassVar[PredefinedIntegerType.Kind] = ...
        ShortInt: ClassVar[PredefinedIntegerType.Kind] = ...
        Time: ClassVar[PredefinedIntegerType.Kind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Byte: ClassVar[PredefinedIntegerType.Kind] = ...
    Int: ClassVar[PredefinedIntegerType.Kind] = ...
    Integer: ClassVar[PredefinedIntegerType.Kind] = ...
    LongInt: ClassVar[PredefinedIntegerType.Kind] = ...
    ShortInt: ClassVar[PredefinedIntegerType.Kind] = ...
    Time: ClassVar[PredefinedIntegerType.Kind] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def integerKind(self): ...

class PrefixUnaryExpressionSyntax(ExpressionSyntax):
    attributes: Incomplete
    operand: ExpressionSyntax
    operatorToken: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PreprocessorOptions:
    additionalIncludePaths: list[os.PathLike]
    ignoreDirectives: set[str]
    languageVersion: LanguageVersion
    maxIncludeDepth: int
    predefineSource: str
    predefines: list[str]
    undefines: list[str]
    def __init__(self) -> None: ...

class PrimaryBlockEventExpressionSyntax(BlockEventExpressionSyntax):
    keyword: Token
    name: NameSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class PrimaryExpressionSyntax(ExpressionSyntax):
    def __init__(self, *args, **kwargs) -> None: ...

class PrimitiveInstanceSymbol(InstanceSymbolBase):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def delay(self) -> TimingControl: ...
    @property
    def driveStrength(self): ...
    @property
    def portConnections(self) -> span[Expression]: ...
    @property
    def primitiveType(self): ...

class PrimitiveInstantiationSyntax(MemberSyntax):
    delay: TimingControlSyntax
    instances: Incomplete
    semi: Token
    strength: NetStrengthSyntax
    type: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PrimitivePortDirection:
    __members__: ClassVar[dict] = ...  # read-only
    In: ClassVar[PrimitivePortDirection] = ...
    InOut: ClassVar[PrimitivePortDirection] = ...
    Out: ClassVar[PrimitivePortDirection] = ...
    OutReg: ClassVar[PrimitivePortDirection] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PrimitivePortSymbol(ValueSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def direction(self) -> PrimitivePortDirection: ...

class PrimitiveSymbol(Symbol, Scope):
    class PrimitiveKind:
        __members__: ClassVar[dict] = ...  # read-only
        Fixed: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
        NInput: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
        NOutput: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
        UserDefined: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class TableEntry:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def inputs(self) -> str: ...
        @property
        def output(self) -> str: ...
        @property
        def state(self) -> str: ...
    Fixed: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
    NInput: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
    NOutput: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
    UserDefined: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def initVal(self) -> ConstantValue: ...
    @property
    def isSequential(self) -> bool: ...
    @property
    def ports(self) -> span[PrimitivePortSymbol]: ...
    @property
    def primitiveKind(self): ...
    @property
    def table(self): ...

class ProceduralAssignStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def assignment(self) -> Expression: ...
    @property
    def isForce(self) -> bool: ...

class ProceduralAssignStatementSyntax(StatementSyntax):
    expr: ExpressionSyntax
    keyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ProceduralBlockKind:
    __members__: ClassVar[dict] = ...  # read-only
    Always: ClassVar[ProceduralBlockKind] = ...
    AlwaysComb: ClassVar[ProceduralBlockKind] = ...
    AlwaysFF: ClassVar[ProceduralBlockKind] = ...
    AlwaysLatch: ClassVar[ProceduralBlockKind] = ...
    Final: ClassVar[ProceduralBlockKind] = ...
    Initial: ClassVar[ProceduralBlockKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ProceduralBlockSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self) -> Statement: ...
    @property
    def isSingleDriverBlock(self) -> bool: ...
    @property
    def procedureKind(self) -> ProceduralBlockKind: ...

class ProceduralBlockSyntax(MemberSyntax):
    keyword: Token
    statement: StatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ProceduralCheckerStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def instances(self): ...

class ProceduralDeassignStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isRelease(self) -> bool: ...
    @property
    def lvalue(self) -> Expression: ...

class ProceduralDeassignStatementSyntax(StatementSyntax):
    keyword: Token
    semi: Token
    variable: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ProductionSyntax(SyntaxNode):
    colon: Token
    dataType: DataTypeSyntax
    name: Token
    portList: FunctionPortListSyntax
    rules: Incomplete
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PropertyCaseItemSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class PropertyDeclarationSyntax(MemberSyntax):
    end: Token
    endBlockName: NamedBlockClauseSyntax
    keyword: Token
    name: Token
    optionalSemi: Token
    portList: AssertionItemPortListSyntax
    propertySpec: PropertySpecSyntax
    semi: Token
    variables: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class PropertyExprSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class PropertySpecSyntax(SyntaxNode):
    clocking: TimingControlSyntax
    disable: DisableIffSyntax
    expr: PropertyExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class PropertySymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def ports(self) -> span[AssertionPortSymbol]: ...

class PropertyType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class PullStrengthSyntax(NetStrengthSyntax):
    closeParen: Token
    openParen: Token
    strength: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PulseStyleDeclarationSyntax(MemberSyntax):
    inputs: Incomplete
    keyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PulseStyleKind:
    __members__: ClassVar[dict] = ...  # read-only
    NoShowCancelled: ClassVar[PulseStyleKind] = ...
    OnDetect: ClassVar[PulseStyleKind] = ...
    OnEvent: ClassVar[PulseStyleKind] = ...
    ShowCancelled: ClassVar[PulseStyleKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PulseStyleSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def pulseStyleKind(self) -> PulseStyleKind: ...
    @property
    def terminals(self) -> span[Expression]: ...

class QueueDimensionSpecifierSyntax(DimensionSpecifierSyntax):
    dollar: Token
    maxSizeClause: ColonExpressionClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class QueueType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elementType(self) -> Type: ...
    @property
    def maxBound(self) -> int: ...

class RandCaseItemSyntax(SyntaxNode):
    colon: Token
    expr: ExpressionSyntax
    statement: StatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class RandCaseStatement(Statement):
    class Item:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def stmt(self) -> Statement: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def items(self): ...

class RandCaseStatementSyntax(StatementSyntax):
    endCase: Token
    items: Incomplete
    randCase: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RandJoinClauseSyntax(SyntaxNode):
    expr: ParenthesizedExpressionSyntax
    join: Token
    rand: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RandMode:
    __members__: ClassVar[dict] = ...  # read-only
    None_: ClassVar[RandMode] = ...
    Rand: ClassVar[RandMode] = ...
    RandC: ClassVar[RandMode] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RandSeqProductionSymbol(Symbol, Scope):
    class CaseItem:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expressions(self) -> span[Expression]: ...
        @property
        def item(self) -> RandSeqProductionSymbol.ProdItem: ...

    class CaseProd(RandSeqProductionSymbol.ProdBase):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def defaultItem(self) -> RandSeqProductionSymbol.ProdItem | None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def items(self) -> span[RandSeqProductionSymbol.CaseItem]: ...

    class CodeBlockProd(RandSeqProductionSymbol.ProdBase):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def block(self) -> StatementBlockSymbol: ...

    class IfElseProd(RandSeqProductionSymbol.ProdBase):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def elseItem(self) -> RandSeqProductionSymbol.ProdItem | None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def ifItem(self) -> RandSeqProductionSymbol.ProdItem: ...

    class ProdBase:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def kind(self) -> RandSeqProductionSymbol.ProdKind: ...

    class ProdItem(RandSeqProductionSymbol.ProdBase):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def args(self) -> span[Expression]: ...
        @property
        def target(self) -> RandSeqProductionSymbol: ...

    class ProdKind:
        __members__: ClassVar[dict] = ...  # read-only
        Case: ClassVar[RandSeqProductionSymbol.ProdKind] = ...
        CodeBlock: ClassVar[RandSeqProductionSymbol.ProdKind] = ...
        IfElse: ClassVar[RandSeqProductionSymbol.ProdKind] = ...
        Item: ClassVar[RandSeqProductionSymbol.ProdKind] = ...
        Repeat: ClassVar[RandSeqProductionSymbol.ProdKind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class RepeatProd(RandSeqProductionSymbol.ProdBase):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def item(self) -> RandSeqProductionSymbol.ProdItem: ...

    class Rule:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def codeBlock(self) -> RandSeqProductionSymbol.CodeBlockProd | None: ...
        @property
        def isRandJoin(self) -> bool: ...
        @property
        def prods(self) -> span[RandSeqProductionSymbol.ProdBase]: ...
        @property
        def randJoinExpr(self) -> Expression: ...
        @property
        def ruleBlock(self) -> StatementBlockSymbol: ...
        @property
        def weightExpr(self) -> Expression: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self) -> span[FormalArgumentSymbol]: ...
    @property
    def returnType(self): ...
    @property
    def rules(self): ...

class RandSequenceStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def firstProduction(self): ...

class RandSequenceStatementSyntax(StatementSyntax):
    closeParen: Token
    endsequence: Token
    firstProduction: Token
    openParen: Token
    productions: Incomplete
    randsequence: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RangeCoverageBinInitializerSyntax(CoverageBinInitializerSyntax):
    ranges: RangeListSyntax
    withClause: WithClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class RangeDimensionSpecifierSyntax(DimensionSpecifierSyntax):
    selector: SelectorSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class RangeListSyntax(SyntaxNode):
    closeBrace: Token
    openBrace: Token
    valueRanges: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class RangeSelectExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def left(self) -> Expression: ...
    @property
    def right(self) -> Expression: ...
    @property
    def selectionKind(self) -> RangeSelectionKind: ...
    @property
    def value(self) -> Expression: ...

class RangeSelectSyntax(SelectorSyntax):
    left: ExpressionSyntax
    range: Token
    right: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class RangeSelectionKind:
    __members__: ClassVar[dict] = ...  # read-only
    IndexedDown: ClassVar[RangeSelectionKind] = ...
    IndexedUp: ClassVar[RangeSelectionKind] = ...
    Simple: ClassVar[RangeSelectionKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RealLiteral(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def value(self) -> float: ...

class RepeatLoopStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self) -> Statement: ...
    @property
    def count(self) -> Expression: ...

class RepeatedEventControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def event(self) -> TimingControl: ...
    @property
    def expr(self): ...

class RepeatedEventControlSyntax(TimingControlSyntax):
    closeParen: Token
    eventControl: TimingControlSyntax
    expr: ExpressionSyntax
    openParen: Token
    repeat: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ReplicatedAssignmentPatternExpression(AssignmentPatternExpressionBase):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def count(self) -> Expression: ...

class ReplicatedAssignmentPatternSyntax(AssignmentPatternSyntax):
    closeBrace: Token
    countExpr: ExpressionSyntax
    innerCloseBrace: Token
    innerOpenBrace: Token
    items: Incomplete
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ReplicationExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def concat(self) -> Expression: ...
    @property
    def count(self) -> Expression: ...

class ReportedDiagnostic:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expansionLocs(self) -> span[SourceLocation]: ...
    @property
    def formattedMessage(self) -> str: ...
    @property
    def location(self) -> SourceLocation: ...
    @property
    def originalDiagnostic(self) -> Diagnostic: ...
    @property
    def ranges(self) -> span[SourceRange]: ...
    @property
    def severity(self) -> DiagnosticSeverity: ...
    @property
    def shouldShowIncludeStack(self) -> bool: ...

class ReturnStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> Expression: ...

class ReturnStatementSyntax(StatementSyntax):
    returnKeyword: Token
    returnValue: ExpressionSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RootSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def compilationUnits(self) -> span[CompilationUnitSymbol]: ...
    @property
    def topInstances(self): ...

class RsCaseItemSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class RsCaseSyntax(RsProdSyntax):
    closeParen: Token
    endcase: Token
    expr: ExpressionSyntax
    items: Incomplete
    keyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RsCodeBlockSyntax(RsProdSyntax):
    closeBrace: Token
    items: Incomplete
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RsElseClauseSyntax(SyntaxNode):
    item: RsProdItemSyntax
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RsIfElseSyntax(RsProdSyntax):
    closeParen: Token
    condition: ExpressionSyntax
    elseClause: RsElseClauseSyntax
    ifItem: RsProdItemSyntax
    keyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RsProdItemSyntax(RsProdSyntax):
    argList: ArgumentListSyntax
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RsProdSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class RsRepeatSyntax(RsProdSyntax):
    closeParen: Token
    expr: ExpressionSyntax
    item: RsProdItemSyntax
    keyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RsRuleSyntax(SyntaxNode):
    prods: Incomplete
    randJoin: RandJoinClauseSyntax
    weightClause: RsWeightClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class RsWeightClauseSyntax(SyntaxNode):
    codeBlock: RsProdSyntax
    colonEqual: Token
    weight: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SVInt:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, bit: logic_t) -> None: ...
    @overload
    def __init__(self, bits: int, value: int, isSigned: bool) -> None: ...
    @overload
    def __init__(self, bits: int, bytes, isSigned: bool) -> None: ...
    @overload
    def __init__(self, str: str) -> None: ...
    @overload
    def __init__(self, value: float) -> None: ...
    @overload
    def __init__(self, value: int) -> None: ...
    def ashr(self, rhs: SVInt) -> SVInt: ...
    @staticmethod
    def concat(arg0: span[SVInt]) -> SVInt: ...
    @staticmethod
    def conditional(condition: SVInt, lhs: SVInt, rhs: SVInt) -> SVInt: ...
    def countLeadingOnes(self) -> int: ...
    def countLeadingUnknowns(self) -> int: ...
    def countLeadingZeros(self) -> int: ...
    def countLeadingZs(self) -> int: ...
    def countOnes(self) -> int: ...
    def countXs(self) -> int: ...
    def countZeros(self) -> int: ...
    def countZs(self) -> int: ...
    @staticmethod
    def createFillX(bitWidth: int, isSigned: bool) -> SVInt: ...
    @staticmethod
    def createFillZ(bitWidth: int, isSigned: bool) -> SVInt: ...
    def extend(self, bits: int, isSigned: bool) -> SVInt: ...
    def flattenUnknowns(self) -> None: ...
    @staticmethod
    def fromDigits(bits: int, base: LiteralBase, isSigned: bool, anyUnknown: bool, digits: span[logic_t]) -> SVInt: ...
    @staticmethod
    def fromDouble(bits: int, value: float, isSigned: bool, round: bool = ...) -> SVInt: ...
    @staticmethod
    def fromFloat(bits: int, value: float, isSigned: bool, round: bool = ...) -> SVInt: ...
    def getActiveBits(self) -> int: ...
    def getMinRepresentedBits(self) -> int: ...
    def isEven(self) -> bool: ...
    def isNegative(self) -> bool: ...
    def isOdd(self) -> bool: ...
    def isSignExtendedFrom(self, msb: int) -> bool: ...
    @staticmethod
    def logicalEquiv(lhs: SVInt, rhs: SVInt) -> logic_t: ...
    @staticmethod
    def logicalImpl(lhs: SVInt, rhs: SVInt) -> logic_t: ...
    def lshr(self, rhs: SVInt) -> SVInt: ...
    def reductionAnd(self) -> logic_t: ...
    def reductionOr(self) -> logic_t: ...
    def reductionXor(self) -> logic_t: ...
    def replicate(self, times: SVInt) -> SVInt: ...
    def resize(self, bits: int) -> SVInt: ...
    def reverse(self) -> SVInt: ...
    def set(self, msb: int, lsb: int, value: SVInt) -> None: ...
    def setAllOnes(self) -> None: ...
    def setAllX(self) -> None: ...
    def setAllZ(self) -> None: ...
    def setAllZeros(self) -> None: ...
    def setSigned(self, isSigned: bool) -> None: ...
    def sext(self, bits: int) -> SVInt: ...
    def shl(self, rhs: SVInt) -> SVInt: ...
    def shrinkToFit(self) -> None: ...
    def signExtendFrom(self, msb: int) -> None: ...
    def slice(self, msb: int, lsb: int) -> SVInt: ...
    def toString(self, base: LiteralBase, includeBase: bool, abbreviateThresholdBits: int = ...) -> str: ...
    def trunc(self, bits: int) -> SVInt: ...
    def xnor(self, rhs: SVInt) -> SVInt: ...
    def zext(self, bits: int) -> SVInt: ...
    @overload
    def __add__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __add__(self, arg0: int) -> SVInt: ...
    @overload
    def __and__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __and__(self, arg0: int) -> SVInt: ...
    def __bool__(self) -> bool: ...
    @overload
    def __eq__(self, arg0: SVInt) -> logic_t: ...
    @overload
    def __eq__(self, arg0: int) -> logic_t: ...
    def __float__(self) -> float: ...
    @overload
    def __ge__(self, arg0: SVInt) -> logic_t: ...
    @overload
    def __ge__(self, arg0: int) -> logic_t: ...
    def __getitem__(self, arg0: int) -> logic_t: ...
    def __iter__(self) -> typing.Iterator[logic_t]: ...
    @overload
    def __gt__(self, arg0: SVInt) -> logic_t: ...
    @overload
    def __gt__(self, arg0: int) -> logic_t: ...
    def __hash__(self) -> int: ...
    @overload
    def __iadd__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __iadd__(self, arg0: int) -> SVInt: ...
    @overload
    def __iand__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __iand__(self, arg0: int) -> SVInt: ...
    @overload
    def __imod__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __imod__(self, arg0: int) -> SVInt: ...
    @overload
    def __imul__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __imul__(self, arg0: int) -> SVInt: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> SVInt: ...
    @overload
    def __ior__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __ior__(self, arg0: int) -> SVInt: ...
    @overload
    def __isub__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __isub__(self, arg0: int) -> SVInt: ...
    @overload
    def __itruediv__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __itruediv__(self, arg0: int) -> SVInt: ...
    @overload
    def __ixor__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __ixor__(self, arg0: int) -> SVInt: ...
    @overload
    def __le__(self, arg0: SVInt) -> logic_t: ...
    @overload
    def __le__(self, arg0: int) -> logic_t: ...
    @overload
    def __lt__(self, arg0: SVInt) -> logic_t: ...
    @overload
    def __lt__(self, arg0: int) -> logic_t: ...
    @overload
    def __mod__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __mod__(self, arg0: int) -> SVInt: ...
    @overload
    def __mul__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __mul__(self, arg0: int) -> SVInt: ...
    @overload
    def __ne__(self, arg0: SVInt) -> logic_t: ...
    @overload
    def __ne__(self, arg0: int) -> logic_t: ...
    def __neg__(self) -> SVInt: ...
    @overload
    def __or__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __or__(self, arg0: int) -> SVInt: ...
    def __pow__(self, arg0: SVInt) -> SVInt: ...
    def __radd__(self, arg0: int) -> SVInt: ...
    def __rand__(self, arg0: int) -> SVInt: ...
    def __rdiv__(self, arg0: int) -> SVInt: ...
    def __rmod__(self, arg0: int) -> SVInt: ...
    def __rmul__(self, arg0: int) -> SVInt: ...
    def __ror__(self, arg0: int) -> SVInt: ...
    def __rsub__(self, arg0: int) -> SVInt: ...
    def __rxor__(self, arg0: int) -> SVInt: ...
    @overload
    def __sub__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __sub__(self, arg0: int) -> SVInt: ...
    @overload
    def __truediv__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __truediv__(self, arg0: int) -> SVInt: ...
    @overload
    def __xor__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __xor__(self, arg0: int) -> SVInt: ...
    @property
    def bitWidth(self) -> int: ...
    @property
    def hasUnknown(self) -> bool: ...
    @property
    def isSigned(self) -> bool: ...

class ScalarType(IntegralType):
    class Kind:
        __members__: ClassVar[dict] = ...  # read-only
        Bit: ClassVar[ScalarType.Kind] = ...
        Logic: ClassVar[ScalarType.Kind] = ...
        Reg: ClassVar[ScalarType.Kind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Bit: ClassVar[ScalarType.Kind] = ...
    Logic: ClassVar[ScalarType.Kind] = ...
    Reg: ClassVar[ScalarType.Kind] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def scalarKind(self): ...

class Scope:
    def __init__(self, *args, **kwargs) -> None: ...
    def find(self, arg0: str) -> Symbol: ...
    def lookupName(self, name: str, location: LookupLocation = ..., flags: LookupFlags = ...) -> Symbol: ...
    def __getitem__(self, arg0: int) -> object: ...
    def __iter__(self) -> Iterator[Symbol]: ...
    def __len__(self) -> int: ...
    @property
    def compilation(self) -> Compilation: ...
    @property
    def compilationUnit(self): ...
    @property
    def containingInstance(self): ...
    @property
    def defaultNetType(self): ...
    @property
    def isProceduralContext(self) -> bool: ...
    @property
    def isUninstantiated(self) -> bool: ...
    @property
    def timeScale(self) -> TimeScale | None: ...

class ScopedNameSyntax(NameSyntax):
    left: NameSyntax
    right: NameSyntax
    separator: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ScriptSession:
    def __init__(self) -> None: ...
    def eval(self, *args, **kwargs): ...
    def evalExpression(self, *args, **kwargs): ...
    def evalStatement(self, expr) -> None: ...
    def getDiagnostics(self, *args, **kwargs): ...
    @property
    def compilation(self) -> Compilation: ...

class SelectorSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class SequenceConcatExpr(AssertionExpr):
    class Element:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def delay(self) -> SequenceRange: ...
        @property
        def sequence(self) -> AssertionExpr: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elements(self): ...

class SequenceDeclarationSyntax(MemberSyntax):
    end: Token
    endBlockName: NamedBlockClauseSyntax
    keyword: Token
    name: Token
    optionalSemi: Token
    portList: AssertionItemPortListSyntax
    semi: Token
    seqExpr: SequenceExprSyntax
    variables: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class SequenceExprSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class SequenceMatchListSyntax(SyntaxNode):
    comma: Token
    items: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class SequenceRange:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def max(self) -> int | None: ...
    @property
    def min(self) -> int: ...

class SequenceRepetition:
    class Kind:
        __members__: ClassVar[dict] = ...  # read-only
        Consecutive: ClassVar[SequenceRepetition.Kind] = ...
        GoTo: ClassVar[SequenceRepetition.Kind] = ...
        Nonconsecutive: ClassVar[SequenceRepetition.Kind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Consecutive: ClassVar[SequenceRepetition.Kind] = ...
    GoTo: ClassVar[SequenceRepetition.Kind] = ...
    Nonconsecutive: ClassVar[SequenceRepetition.Kind] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def kind(self): ...
    @property
    def range(self) -> SequenceRange: ...

class SequenceRepetitionSyntax(SyntaxNode):
    closeBracket: Token
    op: Token
    openBracket: Token
    selector: SelectorSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SequenceSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def ports(self) -> span[AssertionPortSymbol]: ...

class SequenceType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class SequenceWithMatchExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> AssertionExpr: ...
    @property
    def matchItems(self): ...
    @property
    def repetition(self) -> SequenceRepetition | None: ...

class SetExprBinsSelectExpr(BinsSelectExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self): ...
    @property
    def matchesExpr(self): ...

class SignalEventControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def edge(self): ...
    @property
    def expr(self): ...
    @property
    def iffCondition(self): ...

class SignalEventExpressionSyntax(EventExpressionSyntax):
    edge: Token
    expr: ExpressionSyntax
    iffClause: IffEventClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SignedCastExpressionSyntax(ExpressionSyntax):
    apostrophe: Token
    inner: ParenthesizedExpressionSyntax
    signing: Token
    def __init__(self, *args, **kwargs) -> None: ...

class SimpleAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self): ...
    @property
    def repetition(self) -> SequenceRepetition | None: ...

class SimpleAssignmentPatternExpression(AssignmentPatternExpressionBase):
    def __init__(self, *args, **kwargs) -> None: ...

class SimpleAssignmentPatternSyntax(AssignmentPatternSyntax):
    closeBrace: Token
    items: Incomplete
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class SimpleBinsSelectExprSyntax(BinsSelectExpressionSyntax):
    expr: ExpressionSyntax
    matchesClause: MatchesClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SimpleDirectiveSyntax(DirectiveSyntax):
    def __init__(self, *args, **kwargs) -> None: ...

class SimplePathSuffixSyntax(PathSuffixSyntax):
    outputs: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class SimplePragmaExpressionSyntax(PragmaExpressionSyntax):
    value: Token
    def __init__(self, *args, **kwargs) -> None: ...

class SimplePropertyExprSyntax(PropertyExprSyntax):
    expr: SequenceExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SimpleSequenceExprSyntax(SequenceExprSyntax):
    expr: ExpressionSyntax
    repetition: SequenceRepetitionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SimpleSystemSubroutine(SystemSubroutine):
    def __init__(self, name: str, kind: SubroutineKind, requiredArgs: int, argTypes, returnType, isMethod: bool, isFirstArgLValue: bool = ...) -> None: ...

class SolveBeforeConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def after(self): ...
    @property
    def solve(self): ...

class SolveBeforeConstraintSyntax(ConstraintItemSyntax):
    afterExpr: Incomplete
    before: Token
    beforeExpr: Incomplete
    semi: Token
    solve: Token
    def __init__(self, *args, **kwargs) -> None: ...

class SourceBuffer:
    def __init__(self) -> None: ...
    def __bool__(self) -> bool: ...
    @property
    def data(self) -> str: ...
    @property
    def id(self) -> BufferID: ...
    @property
    def library(self) -> SourceLibrary: ...

class SourceLibrary:
    def __init__(self) -> None: ...
    @property
    def name(self) -> str: ...

class SourceLoader:
    def __init__(self, sourceManager) -> None: ...
    def addFiles(self, pattern: str) -> None: ...
    def addLibraryFiles(self, libraryName: str, pattern: str) -> None: ...
    def addLibraryMaps(self, pattern: str, basePath: os.PathLike, optionBag) -> None: ...
    def addSearchDirectories(self, pattern: str) -> None: ...
    def addSearchExtension(self, extension: str) -> None: ...
    def addSeparateUnit(self, filePatterns: span[str], includePaths: list[str], defines: list[str], libraryName: str) -> None: ...
    def loadAndParseSources(self, *args, **kwargs): ...
    def loadSources(self, *args, **kwargs): ...
    @property
    def errors(self) -> span[str]: ...
    @property
    def hasFiles(self) -> bool: ...
    @property
    def libraryMaps(self): ...

class SourceLocation:
    NoLocation: ClassVar[SourceLocation] = ...  # read-only
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, buffer: BufferID, offset: int) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, arg0: SourceLocation) -> bool: ...
    def __ge__(self, arg0: SourceLocation) -> bool: ...
    def __gt__(self, arg0: SourceLocation) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, arg0: SourceLocation) -> bool: ...
    def __lt__(self, arg0: SourceLocation) -> bool: ...
    def __ne__(self, arg0: SourceLocation) -> bool: ...
    @property
    def buffer(self) -> BufferID: ...
    @property
    def offset(self) -> int: ...

class SourceManager:
    def __init__(self) -> None: ...
    def addDiagnosticDirective(self, location: SourceLocation, name: str, severity) -> None: ...
    def addLineDirective(self, location: SourceLocation, lineNum: int, name: str, level: int) -> None: ...
    def addSystemDirectories(self, path: str) -> None: ...
    def addUserDirectories(self, path: str) -> None: ...
    @overload
    def assignText(self, text: str, includedFrom: SourceLocation = ..., library: SourceLibrary = ...) -> SourceBuffer: ...
    @overload
    def assignText(self, path: str, text: str, includedFrom: SourceLocation = ..., library: SourceLibrary = ...) -> SourceBuffer: ...
    def getAllBuffers(self) -> list[BufferID]: ...
    def getColumnNumber(self, location: SourceLocation) -> int: ...
    def getExpansionLoc(self, location: SourceLocation) -> SourceLocation: ...
    def getExpansionRange(self, location: SourceLocation) -> SourceRange: ...
    def getFileName(self, location: SourceLocation) -> str: ...
    def getFullPath(self, buffer: BufferID) -> os.PathLike: ...
    def getFullyExpandedLoc(self, location: SourceLocation) -> SourceLocation: ...
    def getFullyOriginalLoc(self, location: SourceLocation) -> SourceLocation: ...
    def getFullyOriginalRange(self, range: SourceRange) -> SourceRange: ...
    def getIncludedFrom(self, buffer: BufferID) -> SourceLocation: ...
    def getLineNumber(self, location: SourceLocation) -> int: ...
    def getMacroName(self, location: SourceLocation) -> str: ...
    def getOriginalLoc(self, location: SourceLocation) -> SourceLocation: ...
    def getRawFileName(self, buffer: BufferID) -> str: ...
    def getSourceText(self, buffer: BufferID) -> str: ...
    def isBeforeInCompilationUnit(self, left: SourceLocation, right: SourceLocation) -> bool | None: ...
    def isCached(self, path: os.PathLike) -> bool: ...
    def isFileLoc(self, location: SourceLocation) -> bool: ...
    def isIncludedFileLoc(self, location: SourceLocation) -> bool: ...
    def isMacroArgLoc(self, location: SourceLocation) -> bool: ...
    def isMacroLoc(self, location: SourceLocation) -> bool: ...
    def isPreprocessedLoc(self, location: SourceLocation) -> bool: ...
    def readHeader(self, path: str, includedFrom: SourceLocation, library: SourceLibrary, isSystemPath: bool) -> SourceBuffer: ...
    def readSource(self, path: os.PathLike, library: SourceLibrary = ...) -> SourceBuffer: ...
    def setDisableProximatePaths(self, set: bool) -> None: ...

class SourceOptions:
    librariesInheritMacros: bool
    numThreads: int | None
    onlyLint: bool
    singleUnit: bool
    def __init__(self) -> None: ...

class SourceRange:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, startLoc: SourceLocation, endLoc: SourceLocation) -> None: ...
    def __eq__(self, arg0: SourceRange) -> bool: ...
    def __ne__(self, arg0: SourceRange) -> bool: ...
    @property
    def end(self) -> SourceLocation: ...
    @property
    def start(self) -> SourceLocation: ...

class SpecifyBlockSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...

class SpecifyBlockSyntax(MemberSyntax):
    endspecify: Token
    items: Incomplete
    specify: Token
    def __init__(self, *args, **kwargs) -> None: ...

class SpecparamDeclarationSyntax(MemberSyntax):
    declarators: Incomplete
    keyword: Token
    semi: Token
    type: ImplicitTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SpecparamDeclaratorSyntax(SyntaxNode):
    closeParen: Token
    comma: Token
    equals: Token
    name: Token
    openParen: Token
    value1: ExpressionSyntax
    value2: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SpecparamSymbol(ValueSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isPathPulse(self) -> bool: ...
    @property
    def pathDest(self) -> Symbol: ...
    @property
    def pathSource(self) -> Symbol: ...
    @property
    def pulseErrorLimit(self) -> ConstantValue: ...
    @property
    def pulseRejectLimit(self) -> ConstantValue: ...
    @property
    def value(self) -> ConstantValue: ...

class StandardCaseItemSyntax(CaseItemSyntax):
    clause: SyntaxNode
    colon: Token
    expressions: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class StandardPropertyCaseItemSyntax(PropertyCaseItemSyntax):
    colon: Token
    expr: PropertyExprSyntax
    expressions: Incomplete
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class StandardRsCaseItemSyntax(RsCaseItemSyntax):
    colon: Token
    expressions: Incomplete
    item: RsProdItemSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class Statement:
    def __init__(self, *args, **kwargs) -> None: ...
    def eval(self, *args, **kwargs): ...
    def visit(self, f: object) -> None: ...
    @property
    def bad(self) -> bool: ...
    @property
    def kind(self) -> StatementKind: ...
    @property
    def sourceRange(self) -> SourceRange: ...
    @property
    def syntax(self): ...

class StatementBlockKind:
    __members__: ClassVar[dict] = ...  # read-only
    JoinAll: ClassVar[StatementBlockKind] = ...
    JoinAny: ClassVar[StatementBlockKind] = ...
    JoinNone: ClassVar[StatementBlockKind] = ...
    Sequential: ClassVar[StatementBlockKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class StatementBlockSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def blockKind(self) -> StatementBlockKind: ...
    @property
    def defaultLifetime(self) -> VariableLifetime: ...

class StatementKind:
    __members__: ClassVar[dict] = ...  # read-only
    Block: ClassVar[StatementKind] = ...
    Break: ClassVar[StatementKind] = ...
    Case: ClassVar[StatementKind] = ...
    ConcurrentAssertion: ClassVar[StatementKind] = ...
    Conditional: ClassVar[StatementKind] = ...
    Continue: ClassVar[StatementKind] = ...
    Disable: ClassVar[StatementKind] = ...
    DisableFork: ClassVar[StatementKind] = ...
    DoWhileLoop: ClassVar[StatementKind] = ...
    Empty: ClassVar[StatementKind] = ...
    EventTrigger: ClassVar[StatementKind] = ...
    ExpressionStatement: ClassVar[StatementKind] = ...
    ForLoop: ClassVar[StatementKind] = ...
    ForeachLoop: ClassVar[StatementKind] = ...
    ForeverLoop: ClassVar[StatementKind] = ...
    ImmediateAssertion: ClassVar[StatementKind] = ...
    Invalid: ClassVar[StatementKind] = ...
    List: ClassVar[StatementKind] = ...
    PatternCase: ClassVar[StatementKind] = ...
    ProceduralAssign: ClassVar[StatementKind] = ...
    ProceduralChecker: ClassVar[StatementKind] = ...
    ProceduralDeassign: ClassVar[StatementKind] = ...
    RandCase: ClassVar[StatementKind] = ...
    RandSequence: ClassVar[StatementKind] = ...
    RepeatLoop: ClassVar[StatementKind] = ...
    Return: ClassVar[StatementKind] = ...
    Timed: ClassVar[StatementKind] = ...
    VariableDeclaration: ClassVar[StatementKind] = ...
    Wait: ClassVar[StatementKind] = ...
    WaitFork: ClassVar[StatementKind] = ...
    WaitOrder: ClassVar[StatementKind] = ...
    WhileLoop: ClassVar[StatementKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class StatementList(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def list(self) -> span[Statement]: ...

class StatementSyntax(SyntaxNode):
    attributes: Incomplete
    label: NamedLabelSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class StreamExpressionSyntax(SyntaxNode):
    expression: ExpressionSyntax
    withRange: StreamExpressionWithRangeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class StreamExpressionWithRangeSyntax(SyntaxNode):
    range: ElementSelectSyntax
    withKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class StreamingConcatenationExpression(Expression):
    class StreamExpression:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def constantWithWidth(self) -> int | None: ...
        @property
        def operand(self) -> Expression: ...
        @property
        def withExpr(self) -> Expression: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def bitstreamWidth(self) -> int: ...
    @property
    def isFixedSize(self) -> bool: ...
    @property
    def sliceSize(self) -> int: ...
    @property
    def streams(self): ...

class StreamingConcatenationExpressionSyntax(PrimaryExpressionSyntax):
    closeBrace: Token
    expressions: Incomplete
    innerCloseBrace: Token
    innerOpenBrace: Token
    openBrace: Token
    operatorToken: Token
    sliceSize: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class StringLiteral(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def intValue(self): ...
    @property
    def rawValue(self) -> str: ...
    @property
    def value(self) -> str: ...

class StringType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class StrongWeakAssertionExpr(AssertionExpr):
    class Strength:
        __members__: ClassVar[dict] = ...  # read-only
        Strong: ClassVar[StrongWeakAssertionExpr.Strength] = ...
        Weak: ClassVar[StrongWeakAssertionExpr.Strength] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Strong: ClassVar[StrongWeakAssertionExpr.Strength] = ...
    Weak: ClassVar[StrongWeakAssertionExpr.Strength] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> AssertionExpr: ...
    @property
    def strength(self): ...

class StrongWeakPropertyExprSyntax(PropertyExprSyntax):
    closeParen: Token
    expr: SequenceExprSyntax
    keyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class StructUnionMemberSyntax(SyntaxNode):
    attributes: Incomplete
    declarators: Incomplete
    randomQualifier: Token
    semi: Token
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class StructUnionTypeSyntax(DataTypeSyntax):
    closeBrace: Token
    dimensions: Incomplete
    keyword: Token
    members: Incomplete
    openBrace: Token
    packed: Token
    signing: Token
    taggedOrSoft: Token
    def __init__(self, *args, **kwargs) -> None: ...

class StructurePattern(Pattern):
    class FieldPattern:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def field(self): ...
        @property
        def pattern(self) -> Pattern: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def patterns(self): ...

class StructurePatternMemberSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class StructurePatternSyntax(PatternSyntax):
    closeBrace: Token
    members: Incomplete
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class StructuredAssignmentPatternExpression(AssignmentPatternExpressionBase):
    class IndexSetter:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def index(self) -> Expression: ...

    class MemberSetter:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def member(self): ...

    class TypeSetter:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def type(self): ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def defaultSetter(self) -> Expression: ...
    @property
    def indexSetters(self): ...
    @property
    def memberSetters(self): ...
    @property
    def typeSetters(self): ...

class StructuredAssignmentPatternSyntax(AssignmentPatternSyntax):
    closeBrace: Token
    items: Incomplete
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class SubroutineKind:
    __members__: ClassVar[dict] = ...  # read-only
    Function: ClassVar[SubroutineKind] = ...
    Task: ClassVar[SubroutineKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SubroutineSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self) -> span[FormalArgumentSymbol]: ...
    @property
    def body(self) -> Statement: ...
    @property
    def defaultLifetime(self) -> VariableLifetime: ...
    @property
    def flags(self) -> MethodFlags: ...
    @property
    def isVirtual(self) -> bool: ...
    @property
    def override(self) -> SubroutineSymbol: ...
    @property
    def prototype(self): ...
    @property
    def returnType(self): ...
    @property
    def subroutineKind(self) -> SubroutineKind: ...
    @property
    def visibility(self) -> Visibility: ...

class SuperNewDefaultedArgsExpressionSyntax(ExpressionSyntax):
    closeParen: Token
    defaultKeyword: Token
    openParen: Token
    scopedNew: NameSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class Symbol:
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def isDeclaredBefore(self, target: Symbol) -> bool | None: ...
    @overload
    def isDeclaredBefore(self, location: LookupLocation) -> bool | None: ...
    def visit(self, f: object) -> None: ...
    @property
    def declaredType(self): ...
    @property
    def declaringDefinition(self): ...
    @property
    def hierarchicalPath(self) -> str: ...
    @property
    def isScope(self) -> bool: ...
    @property
    def isType(self) -> bool: ...
    @property
    def isValue(self) -> bool: ...
    @property
    def kind(self) -> SymbolKind: ...
    @property
    def lexicalPath(self) -> str: ...
    @property
    def location(self) -> SourceLocation: ...
    @property
    def name(self) -> str: ...
    @property
    def nextSibling(self) -> Symbol: ...
    @property
    def parentScope(self): ...
    @property
    def randMode(self) -> RandMode: ...
    @property
    def sourceLibrary(self) -> SourceLibrary: ...
    @property
    def syntax(self): ...

class SymbolKind:
    __members__: ClassVar[dict] = ...  # read-only
    AnonymousProgram: ClassVar[SymbolKind] = ...
    AssertionPort: ClassVar[SymbolKind] = ...
    AssociativeArrayType: ClassVar[SymbolKind] = ...
    Attribute: ClassVar[SymbolKind] = ...
    CHandleType: ClassVar[SymbolKind] = ...
    Checker: ClassVar[SymbolKind] = ...
    CheckerInstance: ClassVar[SymbolKind] = ...
    CheckerInstanceBody: ClassVar[SymbolKind] = ...
    ClassProperty: ClassVar[SymbolKind] = ...
    ClassType: ClassVar[SymbolKind] = ...
    ClockVar: ClassVar[SymbolKind] = ...
    ClockingBlock: ClassVar[SymbolKind] = ...
    CompilationUnit: ClassVar[SymbolKind] = ...
    ConfigBlock: ClassVar[SymbolKind] = ...
    ConstraintBlock: ClassVar[SymbolKind] = ...
    ContinuousAssign: ClassVar[SymbolKind] = ...
    CoverCross: ClassVar[SymbolKind] = ...
    CoverCrossBody: ClassVar[SymbolKind] = ...
    CoverageBin: ClassVar[SymbolKind] = ...
    CovergroupBody: ClassVar[SymbolKind] = ...
    CovergroupType: ClassVar[SymbolKind] = ...
    Coverpoint: ClassVar[SymbolKind] = ...
    DPIOpenArrayType: ClassVar[SymbolKind] = ...
    DefParam: ClassVar[SymbolKind] = ...
    DeferredMember: ClassVar[SymbolKind] = ...
    Definition: ClassVar[SymbolKind] = ...
    DynamicArrayType: ClassVar[SymbolKind] = ...
    ElabSystemTask: ClassVar[SymbolKind] = ...
    EmptyMember: ClassVar[SymbolKind] = ...
    EnumType: ClassVar[SymbolKind] = ...
    EnumValue: ClassVar[SymbolKind] = ...
    ErrorType: ClassVar[SymbolKind] = ...
    EventType: ClassVar[SymbolKind] = ...
    ExplicitImport: ClassVar[SymbolKind] = ...
    Field: ClassVar[SymbolKind] = ...
    FixedSizeUnpackedArrayType: ClassVar[SymbolKind] = ...
    FloatingType: ClassVar[SymbolKind] = ...
    FormalArgument: ClassVar[SymbolKind] = ...
    ForwardingTypedef: ClassVar[SymbolKind] = ...
    GenerateBlock: ClassVar[SymbolKind] = ...
    GenerateBlockArray: ClassVar[SymbolKind] = ...
    GenericClassDef: ClassVar[SymbolKind] = ...
    Genvar: ClassVar[SymbolKind] = ...
    Instance: ClassVar[SymbolKind] = ...
    InstanceArray: ClassVar[SymbolKind] = ...
    InstanceBody: ClassVar[SymbolKind] = ...
    InterfacePort: ClassVar[SymbolKind] = ...
    Iterator: ClassVar[SymbolKind] = ...
    LetDecl: ClassVar[SymbolKind] = ...
    LocalAssertionVar: ClassVar[SymbolKind] = ...
    MethodPrototype: ClassVar[SymbolKind] = ...
    Modport: ClassVar[SymbolKind] = ...
    ModportClocking: ClassVar[SymbolKind] = ...
    ModportPort: ClassVar[SymbolKind] = ...
    MultiPort: ClassVar[SymbolKind] = ...
    Net: ClassVar[SymbolKind] = ...
    NetAlias: ClassVar[SymbolKind] = ...
    NetType: ClassVar[SymbolKind] = ...
    NullType: ClassVar[SymbolKind] = ...
    Package: ClassVar[SymbolKind] = ...
    PackedArrayType: ClassVar[SymbolKind] = ...
    PackedStructType: ClassVar[SymbolKind] = ...
    PackedUnionType: ClassVar[SymbolKind] = ...
    Parameter: ClassVar[SymbolKind] = ...
    PatternVar: ClassVar[SymbolKind] = ...
    Port: ClassVar[SymbolKind] = ...
    PredefinedIntegerType: ClassVar[SymbolKind] = ...
    Primitive: ClassVar[SymbolKind] = ...
    PrimitiveInstance: ClassVar[SymbolKind] = ...
    PrimitivePort: ClassVar[SymbolKind] = ...
    ProceduralBlock: ClassVar[SymbolKind] = ...
    Property: ClassVar[SymbolKind] = ...
    PropertyType: ClassVar[SymbolKind] = ...
    PulseStyle: ClassVar[SymbolKind] = ...
    QueueType: ClassVar[SymbolKind] = ...
    RandSeqProduction: ClassVar[SymbolKind] = ...
    Root: ClassVar[SymbolKind] = ...
    ScalarType: ClassVar[SymbolKind] = ...
    Sequence: ClassVar[SymbolKind] = ...
    SequenceType: ClassVar[SymbolKind] = ...
    SpecifyBlock: ClassVar[SymbolKind] = ...
    Specparam: ClassVar[SymbolKind] = ...
    StatementBlock: ClassVar[SymbolKind] = ...
    StringType: ClassVar[SymbolKind] = ...
    Subroutine: ClassVar[SymbolKind] = ...
    SystemTimingCheck: ClassVar[SymbolKind] = ...
    TimingPath: ClassVar[SymbolKind] = ...
    TransparentMember: ClassVar[SymbolKind] = ...
    TypeAlias: ClassVar[SymbolKind] = ...
    TypeParameter: ClassVar[SymbolKind] = ...
    TypeRefType: ClassVar[SymbolKind] = ...
    UnboundedType: ClassVar[SymbolKind] = ...
    UninstantiatedDef: ClassVar[SymbolKind] = ...
    Unknown: ClassVar[SymbolKind] = ...
    UnpackedStructType: ClassVar[SymbolKind] = ...
    UnpackedUnionType: ClassVar[SymbolKind] = ...
    UntypedType: ClassVar[SymbolKind] = ...
    Variable: ClassVar[SymbolKind] = ...
    VirtualInterfaceType: ClassVar[SymbolKind] = ...
    VoidType: ClassVar[SymbolKind] = ...
    WildcardImport: ClassVar[SymbolKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SyntaxKind:
    __members__: ClassVar[dict] = ...  # read-only
    AcceptOnPropertyExpr: ClassVar[SyntaxKind] = ...
    ActionBlock: ClassVar[SyntaxKind] = ...
    AddAssignmentExpression: ClassVar[SyntaxKind] = ...
    AddExpression: ClassVar[SyntaxKind] = ...
    AlwaysBlock: ClassVar[SyntaxKind] = ...
    AlwaysCombBlock: ClassVar[SyntaxKind] = ...
    AlwaysFFBlock: ClassVar[SyntaxKind] = ...
    AlwaysLatchBlock: ClassVar[SyntaxKind] = ...
    AndAssignmentExpression: ClassVar[SyntaxKind] = ...
    AndPropertyExpr: ClassVar[SyntaxKind] = ...
    AndSequenceExpr: ClassVar[SyntaxKind] = ...
    AnonymousProgram: ClassVar[SyntaxKind] = ...
    AnsiPortList: ClassVar[SyntaxKind] = ...
    AnsiUdpPortList: ClassVar[SyntaxKind] = ...
    ArgumentList: ClassVar[SyntaxKind] = ...
    ArithmeticLeftShiftAssignmentExpression: ClassVar[SyntaxKind] = ...
    ArithmeticRightShiftAssignmentExpression: ClassVar[SyntaxKind] = ...
    ArithmeticShiftLeftExpression: ClassVar[SyntaxKind] = ...
    ArithmeticShiftRightExpression: ClassVar[SyntaxKind] = ...
    ArrayAndMethod: ClassVar[SyntaxKind] = ...
    ArrayOrMethod: ClassVar[SyntaxKind] = ...
    ArrayOrRandomizeMethodExpression: ClassVar[SyntaxKind] = ...
    ArrayUniqueMethod: ClassVar[SyntaxKind] = ...
    ArrayXorMethod: ClassVar[SyntaxKind] = ...
    AscendingRangeSelect: ClassVar[SyntaxKind] = ...
    AssertPropertyStatement: ClassVar[SyntaxKind] = ...
    AssertionItemPort: ClassVar[SyntaxKind] = ...
    AssertionItemPortList: ClassVar[SyntaxKind] = ...
    AssignmentExpression: ClassVar[SyntaxKind] = ...
    AssignmentPatternExpression: ClassVar[SyntaxKind] = ...
    AssignmentPatternItem: ClassVar[SyntaxKind] = ...
    AssumePropertyStatement: ClassVar[SyntaxKind] = ...
    AttributeInstance: ClassVar[SyntaxKind] = ...
    AttributeSpec: ClassVar[SyntaxKind] = ...
    BadExpression: ClassVar[SyntaxKind] = ...
    BeginKeywordsDirective: ClassVar[SyntaxKind] = ...
    BinSelectWithFilterExpr: ClassVar[SyntaxKind] = ...
    BinaryAndExpression: ClassVar[SyntaxKind] = ...
    BinaryBinsSelectExpr: ClassVar[SyntaxKind] = ...
    BinaryBlockEventExpression: ClassVar[SyntaxKind] = ...
    BinaryConditionalDirectiveExpression: ClassVar[SyntaxKind] = ...
    BinaryEventExpression: ClassVar[SyntaxKind] = ...
    BinaryOrExpression: ClassVar[SyntaxKind] = ...
    BinaryXnorExpression: ClassVar[SyntaxKind] = ...
    BinaryXorExpression: ClassVar[SyntaxKind] = ...
    BindDirective: ClassVar[SyntaxKind] = ...
    BindTargetList: ClassVar[SyntaxKind] = ...
    BinsSelectConditionExpr: ClassVar[SyntaxKind] = ...
    BinsSelection: ClassVar[SyntaxKind] = ...
    BitSelect: ClassVar[SyntaxKind] = ...
    BitType: ClassVar[SyntaxKind] = ...
    BlockCoverageEvent: ClassVar[SyntaxKind] = ...
    BlockingEventTriggerStatement: ClassVar[SyntaxKind] = ...
    ByteType: ClassVar[SyntaxKind] = ...
    CHandleType: ClassVar[SyntaxKind] = ...
    CaseEqualityExpression: ClassVar[SyntaxKind] = ...
    CaseGenerate: ClassVar[SyntaxKind] = ...
    CaseInequalityExpression: ClassVar[SyntaxKind] = ...
    CasePropertyExpr: ClassVar[SyntaxKind] = ...
    CaseStatement: ClassVar[SyntaxKind] = ...
    CastExpression: ClassVar[SyntaxKind] = ...
    CellConfigRule: ClassVar[SyntaxKind] = ...
    CellDefineDirective: ClassVar[SyntaxKind] = ...
    ChargeStrength: ClassVar[SyntaxKind] = ...
    CheckerDataDeclaration: ClassVar[SyntaxKind] = ...
    CheckerDeclaration: ClassVar[SyntaxKind] = ...
    CheckerInstanceStatement: ClassVar[SyntaxKind] = ...
    CheckerInstantiation: ClassVar[SyntaxKind] = ...
    ClassDeclaration: ClassVar[SyntaxKind] = ...
    ClassMethodDeclaration: ClassVar[SyntaxKind] = ...
    ClassMethodPrototype: ClassVar[SyntaxKind] = ...
    ClassName: ClassVar[SyntaxKind] = ...
    ClassPropertyDeclaration: ClassVar[SyntaxKind] = ...
    ClassSpecifier: ClassVar[SyntaxKind] = ...
    ClockingDeclaration: ClassVar[SyntaxKind] = ...
    ClockingDirection: ClassVar[SyntaxKind] = ...
    ClockingItem: ClassVar[SyntaxKind] = ...
    ClockingPropertyExpr: ClassVar[SyntaxKind] = ...
    ClockingSequenceExpr: ClassVar[SyntaxKind] = ...
    ClockingSkew: ClassVar[SyntaxKind] = ...
    ColonExpressionClause: ClassVar[SyntaxKind] = ...
    CompilationUnit: ClassVar[SyntaxKind] = ...
    ConcatenationExpression: ClassVar[SyntaxKind] = ...
    ConcurrentAssertionMember: ClassVar[SyntaxKind] = ...
    ConditionalConstraint: ClassVar[SyntaxKind] = ...
    ConditionalExpression: ClassVar[SyntaxKind] = ...
    ConditionalPathDeclaration: ClassVar[SyntaxKind] = ...
    ConditionalPattern: ClassVar[SyntaxKind] = ...
    ConditionalPredicate: ClassVar[SyntaxKind] = ...
    ConditionalPropertyExpr: ClassVar[SyntaxKind] = ...
    ConditionalStatement: ClassVar[SyntaxKind] = ...
    ConfigCellIdentifier: ClassVar[SyntaxKind] = ...
    ConfigDeclaration: ClassVar[SyntaxKind] = ...
    ConfigInstanceIdentifier: ClassVar[SyntaxKind] = ...
    ConfigLiblist: ClassVar[SyntaxKind] = ...
    ConfigUseClause: ClassVar[SyntaxKind] = ...
    ConstraintBlock: ClassVar[SyntaxKind] = ...
    ConstraintDeclaration: ClassVar[SyntaxKind] = ...
    ConstraintPrototype: ClassVar[SyntaxKind] = ...
    ConstructorName: ClassVar[SyntaxKind] = ...
    ContinuousAssign: ClassVar[SyntaxKind] = ...
    CopyClassExpression: ClassVar[SyntaxKind] = ...
    CoverCross: ClassVar[SyntaxKind] = ...
    CoverPropertyStatement: ClassVar[SyntaxKind] = ...
    CoverSequenceStatement: ClassVar[SyntaxKind] = ...
    CoverageBins: ClassVar[SyntaxKind] = ...
    CoverageBinsArraySize: ClassVar[SyntaxKind] = ...
    CoverageIffClause: ClassVar[SyntaxKind] = ...
    CoverageOption: ClassVar[SyntaxKind] = ...
    CovergroupDeclaration: ClassVar[SyntaxKind] = ...
    Coverpoint: ClassVar[SyntaxKind] = ...
    CycleDelay: ClassVar[SyntaxKind] = ...
    DPIExport: ClassVar[SyntaxKind] = ...
    DPIImport: ClassVar[SyntaxKind] = ...
    DataDeclaration: ClassVar[SyntaxKind] = ...
    Declarator: ClassVar[SyntaxKind] = ...
    DefParam: ClassVar[SyntaxKind] = ...
    DefParamAssignment: ClassVar[SyntaxKind] = ...
    DefaultCaseItem: ClassVar[SyntaxKind] = ...
    DefaultClockingReference: ClassVar[SyntaxKind] = ...
    DefaultConfigRule: ClassVar[SyntaxKind] = ...
    DefaultCoverageBinInitializer: ClassVar[SyntaxKind] = ...
    DefaultDecayTimeDirective: ClassVar[SyntaxKind] = ...
    DefaultDisableDeclaration: ClassVar[SyntaxKind] = ...
    DefaultDistItem: ClassVar[SyntaxKind] = ...
    DefaultExtendsClauseArg: ClassVar[SyntaxKind] = ...
    DefaultFunctionPort: ClassVar[SyntaxKind] = ...
    DefaultNetTypeDirective: ClassVar[SyntaxKind] = ...
    DefaultPatternKeyExpression: ClassVar[SyntaxKind] = ...
    DefaultPropertyCaseItem: ClassVar[SyntaxKind] = ...
    DefaultRsCaseItem: ClassVar[SyntaxKind] = ...
    DefaultSkewItem: ClassVar[SyntaxKind] = ...
    DefaultTriregStrengthDirective: ClassVar[SyntaxKind] = ...
    DeferredAssertion: ClassVar[SyntaxKind] = ...
    DefineDirective: ClassVar[SyntaxKind] = ...
    Delay3: ClassVar[SyntaxKind] = ...
    DelayControl: ClassVar[SyntaxKind] = ...
    DelayModeDistributedDirective: ClassVar[SyntaxKind] = ...
    DelayModePathDirective: ClassVar[SyntaxKind] = ...
    DelayModeUnitDirective: ClassVar[SyntaxKind] = ...
    DelayModeZeroDirective: ClassVar[SyntaxKind] = ...
    DelayedSequenceElement: ClassVar[SyntaxKind] = ...
    DelayedSequenceExpr: ClassVar[SyntaxKind] = ...
    DescendingRangeSelect: ClassVar[SyntaxKind] = ...
    DisableConstraint: ClassVar[SyntaxKind] = ...
    DisableForkStatement: ClassVar[SyntaxKind] = ...
    DisableIff: ClassVar[SyntaxKind] = ...
    DisableStatement: ClassVar[SyntaxKind] = ...
    DistConstraintList: ClassVar[SyntaxKind] = ...
    DistItem: ClassVar[SyntaxKind] = ...
    DistWeight: ClassVar[SyntaxKind] = ...
    DivideAssignmentExpression: ClassVar[SyntaxKind] = ...
    DivideExpression: ClassVar[SyntaxKind] = ...
    DividerClause: ClassVar[SyntaxKind] = ...
    DoWhileStatement: ClassVar[SyntaxKind] = ...
    DotMemberClause: ClassVar[SyntaxKind] = ...
    DriveStrength: ClassVar[SyntaxKind] = ...
    EdgeControlSpecifier: ClassVar[SyntaxKind] = ...
    EdgeDescriptor: ClassVar[SyntaxKind] = ...
    EdgeSensitivePathSuffix: ClassVar[SyntaxKind] = ...
    ElabSystemTask: ClassVar[SyntaxKind] = ...
    ElementSelect: ClassVar[SyntaxKind] = ...
    ElementSelectExpression: ClassVar[SyntaxKind] = ...
    ElsIfDirective: ClassVar[SyntaxKind] = ...
    ElseClause: ClassVar[SyntaxKind] = ...
    ElseConstraintClause: ClassVar[SyntaxKind] = ...
    ElseDirective: ClassVar[SyntaxKind] = ...
    ElsePropertyClause: ClassVar[SyntaxKind] = ...
    EmptyArgument: ClassVar[SyntaxKind] = ...
    EmptyIdentifierName: ClassVar[SyntaxKind] = ...
    EmptyMember: ClassVar[SyntaxKind] = ...
    EmptyNonAnsiPort: ClassVar[SyntaxKind] = ...
    EmptyPortConnection: ClassVar[SyntaxKind] = ...
    EmptyQueueExpression: ClassVar[SyntaxKind] = ...
    EmptyStatement: ClassVar[SyntaxKind] = ...
    EmptyTimingCheckArg: ClassVar[SyntaxKind] = ...
    EndCellDefineDirective: ClassVar[SyntaxKind] = ...
    EndIfDirective: ClassVar[SyntaxKind] = ...
    EndKeywordsDirective: ClassVar[SyntaxKind] = ...
    EndProtectDirective: ClassVar[SyntaxKind] = ...
    EndProtectedDirective: ClassVar[SyntaxKind] = ...
    EnumType: ClassVar[SyntaxKind] = ...
    EqualityExpression: ClassVar[SyntaxKind] = ...
    EqualsAssertionArgClause: ClassVar[SyntaxKind] = ...
    EqualsTypeClause: ClassVar[SyntaxKind] = ...
    EqualsValueClause: ClassVar[SyntaxKind] = ...
    EventControl: ClassVar[SyntaxKind] = ...
    EventControlWithExpression: ClassVar[SyntaxKind] = ...
    EventType: ClassVar[SyntaxKind] = ...
    ExpectPropertyStatement: ClassVar[SyntaxKind] = ...
    ExplicitAnsiPort: ClassVar[SyntaxKind] = ...
    ExplicitNonAnsiPort: ClassVar[SyntaxKind] = ...
    ExpressionConstraint: ClassVar[SyntaxKind] = ...
    ExpressionCoverageBinInitializer: ClassVar[SyntaxKind] = ...
    ExpressionOrDist: ClassVar[SyntaxKind] = ...
    ExpressionPattern: ClassVar[SyntaxKind] = ...
    ExpressionStatement: ClassVar[SyntaxKind] = ...
    ExpressionTimingCheckArg: ClassVar[SyntaxKind] = ...
    ExtendsClause: ClassVar[SyntaxKind] = ...
    ExternInterfaceMethod: ClassVar[SyntaxKind] = ...
    ExternModuleDecl: ClassVar[SyntaxKind] = ...
    ExternUdpDecl: ClassVar[SyntaxKind] = ...
    FilePathSpec: ClassVar[SyntaxKind] = ...
    FinalBlock: ClassVar[SyntaxKind] = ...
    FirstMatchSequenceExpr: ClassVar[SyntaxKind] = ...
    FollowedByPropertyExpr: ClassVar[SyntaxKind] = ...
    ForLoopStatement: ClassVar[SyntaxKind] = ...
    ForVariableDeclaration: ClassVar[SyntaxKind] = ...
    ForeachLoopList: ClassVar[SyntaxKind] = ...
    ForeachLoopStatement: ClassVar[SyntaxKind] = ...
    ForeverStatement: ClassVar[SyntaxKind] = ...
    ForwardTypeRestriction: ClassVar[SyntaxKind] = ...
    ForwardTypedefDeclaration: ClassVar[SyntaxKind] = ...
    FunctionDeclaration: ClassVar[SyntaxKind] = ...
    FunctionPort: ClassVar[SyntaxKind] = ...
    FunctionPortList: ClassVar[SyntaxKind] = ...
    FunctionPrototype: ClassVar[SyntaxKind] = ...
    GenerateBlock: ClassVar[SyntaxKind] = ...
    GenerateRegion: ClassVar[SyntaxKind] = ...
    GenvarDeclaration: ClassVar[SyntaxKind] = ...
    GreaterThanEqualExpression: ClassVar[SyntaxKind] = ...
    GreaterThanExpression: ClassVar[SyntaxKind] = ...
    HierarchicalInstance: ClassVar[SyntaxKind] = ...
    HierarchyInstantiation: ClassVar[SyntaxKind] = ...
    IdWithExprCoverageBinInitializer: ClassVar[SyntaxKind] = ...
    IdentifierName: ClassVar[SyntaxKind] = ...
    IdentifierSelectName: ClassVar[SyntaxKind] = ...
    IfDefDirective: ClassVar[SyntaxKind] = ...
    IfGenerate: ClassVar[SyntaxKind] = ...
    IfNDefDirective: ClassVar[SyntaxKind] = ...
    IfNonePathDeclaration: ClassVar[SyntaxKind] = ...
    IffEventClause: ClassVar[SyntaxKind] = ...
    IffPropertyExpr: ClassVar[SyntaxKind] = ...
    ImmediateAssertStatement: ClassVar[SyntaxKind] = ...
    ImmediateAssertionMember: ClassVar[SyntaxKind] = ...
    ImmediateAssumeStatement: ClassVar[SyntaxKind] = ...
    ImmediateCoverStatement: ClassVar[SyntaxKind] = ...
    ImplementsClause: ClassVar[SyntaxKind] = ...
    ImplicationConstraint: ClassVar[SyntaxKind] = ...
    ImplicationPropertyExpr: ClassVar[SyntaxKind] = ...
    ImplicitAnsiPort: ClassVar[SyntaxKind] = ...
    ImplicitEventControl: ClassVar[SyntaxKind] = ...
    ImplicitNonAnsiPort: ClassVar[SyntaxKind] = ...
    ImplicitType: ClassVar[SyntaxKind] = ...
    ImpliesPropertyExpr: ClassVar[SyntaxKind] = ...
    IncludeDirective: ClassVar[SyntaxKind] = ...
    InequalityExpression: ClassVar[SyntaxKind] = ...
    InitialBlock: ClassVar[SyntaxKind] = ...
    InsideExpression: ClassVar[SyntaxKind] = ...
    InstanceConfigRule: ClassVar[SyntaxKind] = ...
    InstanceName: ClassVar[SyntaxKind] = ...
    IntType: ClassVar[SyntaxKind] = ...
    IntegerLiteralExpression: ClassVar[SyntaxKind] = ...
    IntegerType: ClassVar[SyntaxKind] = ...
    IntegerVectorExpression: ClassVar[SyntaxKind] = ...
    InterfaceDeclaration: ClassVar[SyntaxKind] = ...
    InterfaceHeader: ClassVar[SyntaxKind] = ...
    InterfacePortHeader: ClassVar[SyntaxKind] = ...
    IntersectClause: ClassVar[SyntaxKind] = ...
    IntersectSequenceExpr: ClassVar[SyntaxKind] = ...
    InvocationExpression: ClassVar[SyntaxKind] = ...
    JumpStatement: ClassVar[SyntaxKind] = ...
    LessThanEqualExpression: ClassVar[SyntaxKind] = ...
    LessThanExpression: ClassVar[SyntaxKind] = ...
    LetDeclaration: ClassVar[SyntaxKind] = ...
    LibraryDeclaration: ClassVar[SyntaxKind] = ...
    LibraryIncDirClause: ClassVar[SyntaxKind] = ...
    LibraryIncludeStatement: ClassVar[SyntaxKind] = ...
    LibraryMap: ClassVar[SyntaxKind] = ...
    LineDirective: ClassVar[SyntaxKind] = ...
    LocalScope: ClassVar[SyntaxKind] = ...
    LocalVariableDeclaration: ClassVar[SyntaxKind] = ...
    LogicType: ClassVar[SyntaxKind] = ...
    LogicalAndExpression: ClassVar[SyntaxKind] = ...
    LogicalEquivalenceExpression: ClassVar[SyntaxKind] = ...
    LogicalImplicationExpression: ClassVar[SyntaxKind] = ...
    LogicalLeftShiftAssignmentExpression: ClassVar[SyntaxKind] = ...
    LogicalOrExpression: ClassVar[SyntaxKind] = ...
    LogicalRightShiftAssignmentExpression: ClassVar[SyntaxKind] = ...
    LogicalShiftLeftExpression: ClassVar[SyntaxKind] = ...
    LogicalShiftRightExpression: ClassVar[SyntaxKind] = ...
    LongIntType: ClassVar[SyntaxKind] = ...
    LoopConstraint: ClassVar[SyntaxKind] = ...
    LoopGenerate: ClassVar[SyntaxKind] = ...
    LoopStatement: ClassVar[SyntaxKind] = ...
    MacroActualArgument: ClassVar[SyntaxKind] = ...
    MacroActualArgumentList: ClassVar[SyntaxKind] = ...
    MacroArgumentDefault: ClassVar[SyntaxKind] = ...
    MacroFormalArgument: ClassVar[SyntaxKind] = ...
    MacroFormalArgumentList: ClassVar[SyntaxKind] = ...
    MacroUsage: ClassVar[SyntaxKind] = ...
    MatchesClause: ClassVar[SyntaxKind] = ...
    MemberAccessExpression: ClassVar[SyntaxKind] = ...
    MinTypMaxExpression: ClassVar[SyntaxKind] = ...
    ModAssignmentExpression: ClassVar[SyntaxKind] = ...
    ModExpression: ClassVar[SyntaxKind] = ...
    ModportClockingPort: ClassVar[SyntaxKind] = ...
    ModportDeclaration: ClassVar[SyntaxKind] = ...
    ModportExplicitPort: ClassVar[SyntaxKind] = ...
    ModportItem: ClassVar[SyntaxKind] = ...
    ModportNamedPort: ClassVar[SyntaxKind] = ...
    ModportSimplePortList: ClassVar[SyntaxKind] = ...
    ModportSubroutinePort: ClassVar[SyntaxKind] = ...
    ModportSubroutinePortList: ClassVar[SyntaxKind] = ...
    ModuleDeclaration: ClassVar[SyntaxKind] = ...
    ModuleHeader: ClassVar[SyntaxKind] = ...
    MultipleConcatenationExpression: ClassVar[SyntaxKind] = ...
    MultiplyAssignmentExpression: ClassVar[SyntaxKind] = ...
    MultiplyExpression: ClassVar[SyntaxKind] = ...
    NameValuePragmaExpression: ClassVar[SyntaxKind] = ...
    NamedArgument: ClassVar[SyntaxKind] = ...
    NamedBlockClause: ClassVar[SyntaxKind] = ...
    NamedConditionalDirectiveExpression: ClassVar[SyntaxKind] = ...
    NamedLabel: ClassVar[SyntaxKind] = ...
    NamedParamAssignment: ClassVar[SyntaxKind] = ...
    NamedPortConnection: ClassVar[SyntaxKind] = ...
    NamedStructurePatternMember: ClassVar[SyntaxKind] = ...
    NamedType: ClassVar[SyntaxKind] = ...
    NetAlias: ClassVar[SyntaxKind] = ...
    NetDeclaration: ClassVar[SyntaxKind] = ...
    NetPortHeader: ClassVar[SyntaxKind] = ...
    NetTypeDeclaration: ClassVar[SyntaxKind] = ...
    NewArrayExpression: ClassVar[SyntaxKind] = ...
    NewClassExpression: ClassVar[SyntaxKind] = ...
    NoUnconnectedDriveDirective: ClassVar[SyntaxKind] = ...
    NonAnsiPortList: ClassVar[SyntaxKind] = ...
    NonAnsiUdpPortList: ClassVar[SyntaxKind] = ...
    NonblockingAssignmentExpression: ClassVar[SyntaxKind] = ...
    NonblockingEventTriggerStatement: ClassVar[SyntaxKind] = ...
    NullLiteralExpression: ClassVar[SyntaxKind] = ...
    NumberPragmaExpression: ClassVar[SyntaxKind] = ...
    OneStepDelay: ClassVar[SyntaxKind] = ...
    OrAssignmentExpression: ClassVar[SyntaxKind] = ...
    OrPropertyExpr: ClassVar[SyntaxKind] = ...
    OrSequenceExpr: ClassVar[SyntaxKind] = ...
    OrderedArgument: ClassVar[SyntaxKind] = ...
    OrderedParamAssignment: ClassVar[SyntaxKind] = ...
    OrderedPortConnection: ClassVar[SyntaxKind] = ...
    OrderedStructurePatternMember: ClassVar[SyntaxKind] = ...
    PackageDeclaration: ClassVar[SyntaxKind] = ...
    PackageExportAllDeclaration: ClassVar[SyntaxKind] = ...
    PackageExportDeclaration: ClassVar[SyntaxKind] = ...
    PackageHeader: ClassVar[SyntaxKind] = ...
    PackageImportDeclaration: ClassVar[SyntaxKind] = ...
    PackageImportItem: ClassVar[SyntaxKind] = ...
    ParallelBlockStatement: ClassVar[SyntaxKind] = ...
    ParameterDeclaration: ClassVar[SyntaxKind] = ...
    ParameterDeclarationStatement: ClassVar[SyntaxKind] = ...
    ParameterPortList: ClassVar[SyntaxKind] = ...
    ParameterValueAssignment: ClassVar[SyntaxKind] = ...
    ParenExpressionList: ClassVar[SyntaxKind] = ...
    ParenPragmaExpression: ClassVar[SyntaxKind] = ...
    ParenthesizedBinsSelectExpr: ClassVar[SyntaxKind] = ...
    ParenthesizedConditionalDirectiveExpression: ClassVar[SyntaxKind] = ...
    ParenthesizedEventExpression: ClassVar[SyntaxKind] = ...
    ParenthesizedExpression: ClassVar[SyntaxKind] = ...
    ParenthesizedPattern: ClassVar[SyntaxKind] = ...
    ParenthesizedPropertyExpr: ClassVar[SyntaxKind] = ...
    ParenthesizedSequenceExpr: ClassVar[SyntaxKind] = ...
    PathDeclaration: ClassVar[SyntaxKind] = ...
    PathDescription: ClassVar[SyntaxKind] = ...
    PatternCaseItem: ClassVar[SyntaxKind] = ...
    PortConcatenation: ClassVar[SyntaxKind] = ...
    PortDeclaration: ClassVar[SyntaxKind] = ...
    PortReference: ClassVar[SyntaxKind] = ...
    PostdecrementExpression: ClassVar[SyntaxKind] = ...
    PostincrementExpression: ClassVar[SyntaxKind] = ...
    PowerExpression: ClassVar[SyntaxKind] = ...
    PragmaDirective: ClassVar[SyntaxKind] = ...
    PrimaryBlockEventExpression: ClassVar[SyntaxKind] = ...
    PrimitiveInstantiation: ClassVar[SyntaxKind] = ...
    ProceduralAssignStatement: ClassVar[SyntaxKind] = ...
    ProceduralDeassignStatement: ClassVar[SyntaxKind] = ...
    ProceduralForceStatement: ClassVar[SyntaxKind] = ...
    ProceduralReleaseStatement: ClassVar[SyntaxKind] = ...
    Production: ClassVar[SyntaxKind] = ...
    ProgramDeclaration: ClassVar[SyntaxKind] = ...
    ProgramHeader: ClassVar[SyntaxKind] = ...
    PropertyDeclaration: ClassVar[SyntaxKind] = ...
    PropertySpec: ClassVar[SyntaxKind] = ...
    PropertyType: ClassVar[SyntaxKind] = ...
    ProtectDirective: ClassVar[SyntaxKind] = ...
    ProtectedDirective: ClassVar[SyntaxKind] = ...
    PullStrength: ClassVar[SyntaxKind] = ...
    PulseStyleDeclaration: ClassVar[SyntaxKind] = ...
    QueueDimensionSpecifier: ClassVar[SyntaxKind] = ...
    RandCaseItem: ClassVar[SyntaxKind] = ...
    RandCaseStatement: ClassVar[SyntaxKind] = ...
    RandJoinClause: ClassVar[SyntaxKind] = ...
    RandSequenceStatement: ClassVar[SyntaxKind] = ...
    RangeCoverageBinInitializer: ClassVar[SyntaxKind] = ...
    RangeDimensionSpecifier: ClassVar[SyntaxKind] = ...
    RangeList: ClassVar[SyntaxKind] = ...
    RealLiteralExpression: ClassVar[SyntaxKind] = ...
    RealTimeType: ClassVar[SyntaxKind] = ...
    RealType: ClassVar[SyntaxKind] = ...
    RegType: ClassVar[SyntaxKind] = ...
    RepeatedEventControl: ClassVar[SyntaxKind] = ...
    ReplicatedAssignmentPattern: ClassVar[SyntaxKind] = ...
    ResetAllDirective: ClassVar[SyntaxKind] = ...
    RestrictPropertyStatement: ClassVar[SyntaxKind] = ...
    ReturnStatement: ClassVar[SyntaxKind] = ...
    RootScope: ClassVar[SyntaxKind] = ...
    RsCase: ClassVar[SyntaxKind] = ...
    RsCodeBlock: ClassVar[SyntaxKind] = ...
    RsElseClause: ClassVar[SyntaxKind] = ...
    RsIfElse: ClassVar[SyntaxKind] = ...
    RsProdItem: ClassVar[SyntaxKind] = ...
    RsRepeat: ClassVar[SyntaxKind] = ...
    RsRule: ClassVar[SyntaxKind] = ...
    RsWeightClause: ClassVar[SyntaxKind] = ...
    SUntilPropertyExpr: ClassVar[SyntaxKind] = ...
    SUntilWithPropertyExpr: ClassVar[SyntaxKind] = ...
    ScopedName: ClassVar[SyntaxKind] = ...
    SeparatedList: ClassVar[SyntaxKind] = ...
    SequenceDeclaration: ClassVar[SyntaxKind] = ...
    SequenceMatchList: ClassVar[SyntaxKind] = ...
    SequenceRepetition: ClassVar[SyntaxKind] = ...
    SequenceType: ClassVar[SyntaxKind] = ...
    SequentialBlockStatement: ClassVar[SyntaxKind] = ...
    ShortIntType: ClassVar[SyntaxKind] = ...
    ShortRealType: ClassVar[SyntaxKind] = ...
    SignalEventExpression: ClassVar[SyntaxKind] = ...
    SignedCastExpression: ClassVar[SyntaxKind] = ...
    SimpleAssignmentPattern: ClassVar[SyntaxKind] = ...
    SimpleBinsSelectExpr: ClassVar[SyntaxKind] = ...
    SimplePathSuffix: ClassVar[SyntaxKind] = ...
    SimplePragmaExpression: ClassVar[SyntaxKind] = ...
    SimplePropertyExpr: ClassVar[SyntaxKind] = ...
    SimpleRangeSelect: ClassVar[SyntaxKind] = ...
    SimpleSequenceExpr: ClassVar[SyntaxKind] = ...
    SolveBeforeConstraint: ClassVar[SyntaxKind] = ...
    SpecifyBlock: ClassVar[SyntaxKind] = ...
    SpecparamDeclaration: ClassVar[SyntaxKind] = ...
    SpecparamDeclarator: ClassVar[SyntaxKind] = ...
    StandardCaseItem: ClassVar[SyntaxKind] = ...
    StandardPropertyCaseItem: ClassVar[SyntaxKind] = ...
    StandardRsCaseItem: ClassVar[SyntaxKind] = ...
    StreamExpression: ClassVar[SyntaxKind] = ...
    StreamExpressionWithRange: ClassVar[SyntaxKind] = ...
    StreamingConcatenationExpression: ClassVar[SyntaxKind] = ...
    StringLiteralExpression: ClassVar[SyntaxKind] = ...
    StringType: ClassVar[SyntaxKind] = ...
    StrongWeakPropertyExpr: ClassVar[SyntaxKind] = ...
    StructType: ClassVar[SyntaxKind] = ...
    StructUnionMember: ClassVar[SyntaxKind] = ...
    StructurePattern: ClassVar[SyntaxKind] = ...
    StructuredAssignmentPattern: ClassVar[SyntaxKind] = ...
    SubtractAssignmentExpression: ClassVar[SyntaxKind] = ...
    SubtractExpression: ClassVar[SyntaxKind] = ...
    SuperHandle: ClassVar[SyntaxKind] = ...
    SuperNewDefaultedArgsExpression: ClassVar[SyntaxKind] = ...
    SyntaxList: ClassVar[SyntaxKind] = ...
    SystemName: ClassVar[SyntaxKind] = ...
    SystemTimingCheck: ClassVar[SyntaxKind] = ...
    TaggedPattern: ClassVar[SyntaxKind] = ...
    TaggedUnionExpression: ClassVar[SyntaxKind] = ...
    TaskDeclaration: ClassVar[SyntaxKind] = ...
    ThisHandle: ClassVar[SyntaxKind] = ...
    ThroughoutSequenceExpr: ClassVar[SyntaxKind] = ...
    TimeLiteralExpression: ClassVar[SyntaxKind] = ...
    TimeScaleDirective: ClassVar[SyntaxKind] = ...
    TimeType: ClassVar[SyntaxKind] = ...
    TimeUnitsDeclaration: ClassVar[SyntaxKind] = ...
    TimingCheckEventArg: ClassVar[SyntaxKind] = ...
    TimingCheckEventCondition: ClassVar[SyntaxKind] = ...
    TimingControlExpression: ClassVar[SyntaxKind] = ...
    TimingControlStatement: ClassVar[SyntaxKind] = ...
    TokenList: ClassVar[SyntaxKind] = ...
    TransListCoverageBinInitializer: ClassVar[SyntaxKind] = ...
    TransRange: ClassVar[SyntaxKind] = ...
    TransRepeatRange: ClassVar[SyntaxKind] = ...
    TransSet: ClassVar[SyntaxKind] = ...
    TypeAssignment: ClassVar[SyntaxKind] = ...
    TypeParameterDeclaration: ClassVar[SyntaxKind] = ...
    TypeReference: ClassVar[SyntaxKind] = ...
    TypedefDeclaration: ClassVar[SyntaxKind] = ...
    UdpBody: ClassVar[SyntaxKind] = ...
    UdpDeclaration: ClassVar[SyntaxKind] = ...
    UdpEdgeField: ClassVar[SyntaxKind] = ...
    UdpEntry: ClassVar[SyntaxKind] = ...
    UdpInitialStmt: ClassVar[SyntaxKind] = ...
    UdpInputPortDecl: ClassVar[SyntaxKind] = ...
    UdpOutputPortDecl: ClassVar[SyntaxKind] = ...
    UdpSimpleField: ClassVar[SyntaxKind] = ...
    UnaryBinsSelectExpr: ClassVar[SyntaxKind] = ...
    UnaryBitwiseAndExpression: ClassVar[SyntaxKind] = ...
    UnaryBitwiseNandExpression: ClassVar[SyntaxKind] = ...
    UnaryBitwiseNorExpression: ClassVar[SyntaxKind] = ...
    UnaryBitwiseNotExpression: ClassVar[SyntaxKind] = ...
    UnaryBitwiseOrExpression: ClassVar[SyntaxKind] = ...
    UnaryBitwiseXnorExpression: ClassVar[SyntaxKind] = ...
    UnaryBitwiseXorExpression: ClassVar[SyntaxKind] = ...
    UnaryConditionalDirectiveExpression: ClassVar[SyntaxKind] = ...
    UnaryLogicalNotExpression: ClassVar[SyntaxKind] = ...
    UnaryMinusExpression: ClassVar[SyntaxKind] = ...
    UnaryPlusExpression: ClassVar[SyntaxKind] = ...
    UnaryPredecrementExpression: ClassVar[SyntaxKind] = ...
    UnaryPreincrementExpression: ClassVar[SyntaxKind] = ...
    UnaryPropertyExpr: ClassVar[SyntaxKind] = ...
    UnarySelectPropertyExpr: ClassVar[SyntaxKind] = ...
    UnbasedUnsizedLiteralExpression: ClassVar[SyntaxKind] = ...
    UnconnectedDriveDirective: ClassVar[SyntaxKind] = ...
    UndefDirective: ClassVar[SyntaxKind] = ...
    UndefineAllDirective: ClassVar[SyntaxKind] = ...
    UnionType: ClassVar[SyntaxKind] = ...
    UniquenessConstraint: ClassVar[SyntaxKind] = ...
    UnitScope: ClassVar[SyntaxKind] = ...
    Unknown: ClassVar[SyntaxKind] = ...
    UntilPropertyExpr: ClassVar[SyntaxKind] = ...
    UntilWithPropertyExpr: ClassVar[SyntaxKind] = ...
    Untyped: ClassVar[SyntaxKind] = ...
    UserDefinedNetDeclaration: ClassVar[SyntaxKind] = ...
    ValueRangeExpression: ClassVar[SyntaxKind] = ...
    VariableDimension: ClassVar[SyntaxKind] = ...
    VariablePattern: ClassVar[SyntaxKind] = ...
    VariablePortHeader: ClassVar[SyntaxKind] = ...
    VirtualInterfaceType: ClassVar[SyntaxKind] = ...
    VoidCastedCallStatement: ClassVar[SyntaxKind] = ...
    VoidType: ClassVar[SyntaxKind] = ...
    WaitForkStatement: ClassVar[SyntaxKind] = ...
    WaitOrderStatement: ClassVar[SyntaxKind] = ...
    WaitStatement: ClassVar[SyntaxKind] = ...
    WildcardDimensionSpecifier: ClassVar[SyntaxKind] = ...
    WildcardEqualityExpression: ClassVar[SyntaxKind] = ...
    WildcardInequalityExpression: ClassVar[SyntaxKind] = ...
    WildcardLiteralExpression: ClassVar[SyntaxKind] = ...
    WildcardPattern: ClassVar[SyntaxKind] = ...
    WildcardPortConnection: ClassVar[SyntaxKind] = ...
    WildcardPortList: ClassVar[SyntaxKind] = ...
    WildcardUdpPortList: ClassVar[SyntaxKind] = ...
    WithClause: ClassVar[SyntaxKind] = ...
    WithFunctionClause: ClassVar[SyntaxKind] = ...
    WithFunctionSample: ClassVar[SyntaxKind] = ...
    WithinSequenceExpr: ClassVar[SyntaxKind] = ...
    XorAssignmentExpression: ClassVar[SyntaxKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SyntaxNode:
    def __init__(self, *args, **kwargs) -> None: ...
    def getFirstToken(self) -> Token: ...
    def getLastToken(self) -> Token: ...
    def isEquivalentTo(self, other: SyntaxNode) -> bool: ...
    def visit(self, f: object) -> None: ...
    def __getitem__(self, arg0: int) -> object: ...
    def __iter__(self) -> Iterator[object]: ...
    def __len__(self) -> int: ...
    @property
    def kind(self) -> SyntaxKind: ...
    @property
    def parent(self) -> SyntaxNode: ...
    @property
    def sourceRange(self) -> SourceRange: ...

class SyntaxPrinter:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, sourceManager: SourceManager) -> None: ...
    def append(self, text: str) -> SyntaxPrinter: ...
    @overload
    def print(self, trivia: Trivia) -> SyntaxPrinter: ...
    @overload
    def print(self, token: Token) -> SyntaxPrinter: ...
    @overload
    def print(self, node: SyntaxNode) -> SyntaxPrinter: ...
    @overload
    def print(self, tree: SyntaxTree) -> SyntaxPrinter: ...
    @staticmethod
    def printFile(tree: SyntaxTree) -> str: ...
    def setExpandIncludes(self, expand: bool) -> SyntaxPrinter: ...
    def setExpandMacros(self, expand: bool) -> SyntaxPrinter: ...
    def setIncludeComments(self, include: bool) -> SyntaxPrinter: ...
    def setIncludeDirectives(self, include: bool) -> SyntaxPrinter: ...
    def setIncludeMissing(self, include: bool) -> SyntaxPrinter: ...
    def setIncludeSkipped(self, include: bool) -> SyntaxPrinter: ...
    def setIncludeTrivia(self, include: bool) -> SyntaxPrinter: ...
    def setSquashNewlines(self, include: bool) -> SyntaxPrinter: ...
    def str(self) -> str: ...

class SyntaxRewriter:
    def __init__(self, *args, **kwargs) -> None: ...
    def insert_after(self, arg0: SyntaxNode, arg1: SyntaxNode) -> None: ...
    def insert_at_back(self, list, newNode: SyntaxNode, separator: Token = ...) -> None: ...
    def insert_at_front(self, list, newNode: SyntaxNode, separator: Token = ...) -> None: ...
    def insert_before(self, arg0: SyntaxNode, arg1: SyntaxNode) -> None: ...
    def remove(self, arg0: SyntaxNode) -> None: ...
    def replace(self, arg0: SyntaxNode, arg1: SyntaxNode) -> None: ...
    @property
    def factory(self): ...

class SyntaxTree:
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def fromBuffer(buffer: SourceBuffer, sourceManager: SourceManager, options: Bag = ..., inheritedMacros=...) -> SyntaxTree: ...
    @staticmethod
    def fromBuffers(buffers: span[SourceBuffer], sourceManager: SourceManager, options: Bag = ..., inheritedMacros=...) -> SyntaxTree: ...
    @overload
    @staticmethod
    def fromFile(path: str) -> SyntaxTree: ...
    @overload
    @staticmethod
    def fromFile(path: str, sourceManager: SourceManager, options: Bag = ...) -> SyntaxTree: ...
    @staticmethod
    def fromFileInMemory(text: str, sourceManager: SourceManager, name: str = ..., path: str = ..., options: Bag = ...) -> SyntaxTree: ...
    @overload
    @staticmethod
    def fromFiles(paths: span[str]) -> SyntaxTree: ...
    @overload
    @staticmethod
    def fromFiles(paths: span[str], sourceManager: SourceManager, options: Bag = ...) -> SyntaxTree: ...
    @staticmethod
    def fromLibraryMapBuffer(buffer: SourceBuffer, sourceManager: SourceManager, options: Bag = ...) -> SyntaxTree: ...
    @staticmethod
    def fromLibraryMapFile(path: str, sourceManager: SourceManager, options: Bag = ...) -> SyntaxTree: ...
    @staticmethod
    def fromLibraryMapText(text: str, sourceManager: SourceManager, name: str = ..., path: str = ..., options: Bag = ...) -> SyntaxTree: ...
    @overload
    @staticmethod
    def fromText(text: str, name: str = ..., path: str = ...) -> SyntaxTree: ...
    @overload
    @staticmethod
    def fromText(text: str, sourceManager: SourceManager, name: str = ..., path: str = ..., options: Bag = ..., library: SourceLibrary = ...) -> SyntaxTree: ...
    @staticmethod
    def getDefaultSourceManager() -> SourceManager: ...
    def getIncludeDirectives(self) -> span[IncludeMetadata]: ...
    @property
    def diagnostics(self) -> Diagnostics: ...
    @property
    def isLibraryUnit(self) -> bool: ...
    @property
    def options(self) -> Bag: ...
    @property
    def root(self) -> SyntaxNode: ...
    @property
    def sourceLibrary(self) -> SourceLibrary: ...
    @property
    def sourceManager(self) -> SourceManager: ...

class SystemNameSyntax(NameSyntax):
    systemIdentifier: Token
    def __init__(self, *args, **kwargs) -> None: ...

class SystemSubroutine:
    class WithClauseMode:
        __members__: ClassVar[dict] = ...  # read-only
        Iterator: ClassVar[SystemSubroutine.WithClauseMode] = ...
        None_: ClassVar[SystemSubroutine.WithClauseMode] = ...
        Randomize: ClassVar[SystemSubroutine.WithClauseMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    hasOutputArgs: bool
    kind: SubroutineKind
    knownNameId: Incomplete
    name: str
    withClauseMode: Incomplete
    def __init__(self, name: str, kind: SubroutineKind) -> None: ...
    def allowClockingArgument(self, argIndex: int) -> bool: ...
    def allowEmptyArgument(self, argIndex: int) -> bool: ...
    def badArg(self, *args, **kwargs): ...
    def bindArgument(self, *args, **kwargs): ...
    def checkArgCount(self, context: ASTContext, isMethod: bool, args, callRange, min: int, max: int) -> bool: ...
    def checkArguments(self, *args, **kwargs): ...
    def eval(self, *args, **kwargs): ...
    def kindStr(self) -> str: ...
    def noHierarchical(self, context: EvalContext, expr) -> bool: ...
    def notConst(self, context: EvalContext, range) -> bool: ...
    @staticmethod
    def unevaluatedContext(sourceContext: ASTContext) -> ASTContext: ...

class SystemTimingCheckKind:
    __members__: ClassVar[dict] = ...  # read-only
    FullSkew: ClassVar[SystemTimingCheckKind] = ...
    Hold: ClassVar[SystemTimingCheckKind] = ...
    NoChange: ClassVar[SystemTimingCheckKind] = ...
    Period: ClassVar[SystemTimingCheckKind] = ...
    RecRem: ClassVar[SystemTimingCheckKind] = ...
    Recovery: ClassVar[SystemTimingCheckKind] = ...
    Removal: ClassVar[SystemTimingCheckKind] = ...
    Setup: ClassVar[SystemTimingCheckKind] = ...
    SetupHold: ClassVar[SystemTimingCheckKind] = ...
    Skew: ClassVar[SystemTimingCheckKind] = ...
    TimeSkew: ClassVar[SystemTimingCheckKind] = ...
    Unknown: ClassVar[SystemTimingCheckKind] = ...
    Width: ClassVar[SystemTimingCheckKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SystemTimingCheckSymbol(Symbol):
    class Arg:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def condition(self) -> Expression: ...
        @property
        def edge(self) -> EdgeKind: ...
        @property
        def edgeDescriptors(self): ...
        @property
        def expr(self) -> Expression: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self): ...
    @property
    def timingCheckKind(self) -> SystemTimingCheckKind: ...

class SystemTimingCheckSyntax(MemberSyntax):
    args: Incomplete
    closeParen: Token
    name: Token
    openParen: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TaggedPattern(Pattern):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def member(self): ...
    @property
    def valuePattern(self) -> Pattern: ...

class TaggedPatternSyntax(PatternSyntax):
    memberName: Token
    pattern: PatternSyntax
    tagged: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TaggedUnionExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def member(self): ...
    @property
    def valueExpr(self) -> Expression: ...

class TaggedUnionExpressionSyntax(ExpressionSyntax):
    expr: ExpressionSyntax
    member: Token
    tagged: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TempVarSymbol(VariableSymbol):
    def __init__(self, *args, **kwargs) -> None: ...

class TextDiagnosticClient(DiagnosticClient):
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def getString(self) -> str: ...
    def report(self, diag: ReportedDiagnostic) -> None: ...
    def showColors(self, show: bool) -> None: ...
    def showColumn(self, show: bool) -> None: ...
    def showHierarchyInstance(self, show) -> None: ...
    def showIncludeStack(self, show: bool) -> None: ...
    def showLocation(self, show: bool) -> None: ...
    def showMacroExpansion(self, show: bool) -> None: ...
    def showOptionName(self, show: bool) -> None: ...
    def showSourceLine(self, show: bool) -> None: ...

class TimeLiteral(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def value(self) -> float: ...

class TimeScale:
    base: TimeScaleValue
    precision: TimeScaleValue
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, base: TimeScaleValue, precision: TimeScaleValue) -> None: ...
    def apply(self, value: float, unit: TimeUnit, roundToPrecision: bool) -> float: ...
    @staticmethod
    def fromString(str: str) -> TimeScale | None: ...
    def __eq__(self, arg0: TimeScale) -> bool: ...
    def __ne__(self, arg0: TimeScale) -> bool: ...

class TimeScaleDirectiveSyntax(DirectiveSyntax):
    slash: Token
    timePrecision: Token
    timeUnit: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TimeScaleMagnitude:
    __members__: ClassVar[dict] = ...  # read-only
    Hundred: ClassVar[TimeScaleMagnitude] = ...
    One: ClassVar[TimeScaleMagnitude] = ...
    Ten: ClassVar[TimeScaleMagnitude] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TimeScaleValue:
    magnitude: TimeScaleMagnitude
    unit: TimeUnit
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, unit: TimeUnit, magnitude: TimeScaleMagnitude) -> None: ...
    @staticmethod
    def fromLiteral(value: float, unit: TimeUnit) -> TimeScaleValue | None: ...
    @staticmethod
    def fromString(str: str) -> TimeScaleValue | None: ...
    def __eq__(self, arg0: TimeScaleValue) -> bool: ...
    def __ne__(self, arg0: TimeScaleValue) -> bool: ...

class TimeUnit:
    __members__: ClassVar[dict] = ...  # read-only
    Femtoseconds: ClassVar[TimeUnit] = ...
    Microseconds: ClassVar[TimeUnit] = ...
    Milliseconds: ClassVar[TimeUnit] = ...
    Nanoseconds: ClassVar[TimeUnit] = ...
    Picoseconds: ClassVar[TimeUnit] = ...
    Seconds: ClassVar[TimeUnit] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TimeUnitsDeclarationSyntax(MemberSyntax):
    divider: DividerClauseSyntax
    keyword: Token
    semi: Token
    time: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TimedStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def stmt(self) -> Statement: ...
    @property
    def timing(self) -> TimingControl: ...

class TimingCheckArgSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class TimingCheckEventArgSyntax(TimingCheckArgSyntax):
    condition: TimingCheckEventConditionSyntax
    controlSpecifier: EdgeControlSpecifierSyntax
    edge: Token
    terminal: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class TimingCheckEventConditionSyntax(SyntaxNode):
    expr: ExpressionSyntax
    tripleAnd: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TimingControl:
    def __init__(self, *args, **kwargs) -> None: ...
    def visit(self, f: object) -> None: ...
    @property
    def bad(self) -> bool: ...
    @property
    def kind(self) -> TimingControlKind: ...
    @property
    def sourceRange(self): ...
    @property
    def syntax(self): ...

class TimingControlExpressionSyntax(ExpressionSyntax):
    expr: ExpressionSyntax
    timing: TimingControlSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class TimingControlKind:
    __members__: ClassVar[dict] = ...  # read-only
    BlockEventList: ClassVar[TimingControlKind] = ...
    CycleDelay: ClassVar[TimingControlKind] = ...
    Delay: ClassVar[TimingControlKind] = ...
    Delay3: ClassVar[TimingControlKind] = ...
    EventList: ClassVar[TimingControlKind] = ...
    ImplicitEvent: ClassVar[TimingControlKind] = ...
    Invalid: ClassVar[TimingControlKind] = ...
    OneStepDelay: ClassVar[TimingControlKind] = ...
    RepeatedEvent: ClassVar[TimingControlKind] = ...
    SignalEvent: ClassVar[TimingControlKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TimingControlStatementSyntax(StatementSyntax):
    statement: StatementSyntax
    timingControl: TimingControlSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class TimingControlSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class TimingPathSymbol(Symbol):
    class ConnectionKind:
        __members__: ClassVar[dict] = ...  # read-only
        Full: ClassVar[TimingPathSymbol.ConnectionKind] = ...
        Parallel: ClassVar[TimingPathSymbol.ConnectionKind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Polarity:
        __members__: ClassVar[dict] = ...  # read-only
        Negative: ClassVar[TimingPathSymbol.Polarity] = ...
        Positive: ClassVar[TimingPathSymbol.Polarity] = ...
        Unknown: ClassVar[TimingPathSymbol.Polarity] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def conditionExpr(self) -> Expression: ...
    @property
    def connectionKind(self): ...
    @property
    def delays(self) -> span[Expression]: ...
    @property
    def edgeIdentifier(self) -> EdgeKind: ...
    @property
    def edgePolarity(self): ...
    @property
    def edgeSourceExpr(self) -> Expression: ...
    @property
    def inputs(self) -> span[Expression]: ...
    @property
    def isStateDependent(self) -> bool: ...
    @property
    def outputs(self) -> span[Expression]: ...
    @property
    def polarity(self): ...

class Token:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, alloc: BumpAllocator, kind: TokenKind, trivia: span[Trivia], rawText: str, location: SourceLocation) -> None: ...
    @overload
    def __init__(self, alloc: BumpAllocator, kind: TokenKind, trivia: span[Trivia], rawText: str, location: SourceLocation, strText: str) -> None: ...
    @overload
    def __init__(self, alloc: BumpAllocator, kind: TokenKind, trivia: span[Trivia], rawText: str, location: SourceLocation, directive: SyntaxKind) -> None: ...
    @overload
    def __init__(self, alloc: BumpAllocator, kind: TokenKind, trivia: span[Trivia], rawText: str, location: SourceLocation, bit: logic_t) -> None: ...
    @overload
    def __init__(self, alloc: BumpAllocator, kind: TokenKind, trivia: span[Trivia], rawText: str, location: SourceLocation, value: SVInt) -> None: ...
    @overload
    def __init__(self, alloc: BumpAllocator, kind: TokenKind, trivia: span[Trivia], rawText: str, location: SourceLocation, value: float, outOfRange: bool, timeUnit: TimeUnit | None) -> None: ...
    @overload
    def __init__(self, alloc: BumpAllocator, kind: TokenKind, trivia: span[Trivia], rawText: str, location: SourceLocation, base: LiteralBase, isSigned: bool) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, arg0: Token) -> bool: ...
    def __ne__(self, arg0: Token) -> bool: ...
    @property
    def isMissing(self) -> bool: ...
    @property
    def isOnSameLine(self) -> bool: ...
    @property
    def kind(self) -> TokenKind: ...
    @property
    def location(self) -> SourceLocation: ...
    @property
    def range(self) -> SourceRange: ...
    @property
    def rawText(self) -> str: ...
    @property
    def trivia(self) -> span[Trivia]: ...
    @property
    def value(self) -> object: ...
    @property
    def valueText(self) -> str: ...

class TokenKind:
    __members__: ClassVar[dict] = ...  # read-only
    AcceptOnKeyword: ClassVar[TokenKind] = ...
    AliasKeyword: ClassVar[TokenKind] = ...
    AlwaysCombKeyword: ClassVar[TokenKind] = ...
    AlwaysFFKeyword: ClassVar[TokenKind] = ...
    AlwaysKeyword: ClassVar[TokenKind] = ...
    AlwaysLatchKeyword: ClassVar[TokenKind] = ...
    And: ClassVar[TokenKind] = ...
    AndEqual: ClassVar[TokenKind] = ...
    AndKeyword: ClassVar[TokenKind] = ...
    Apostrophe: ClassVar[TokenKind] = ...
    ApostropheOpenBrace: ClassVar[TokenKind] = ...
    AssertKeyword: ClassVar[TokenKind] = ...
    AssignKeyword: ClassVar[TokenKind] = ...
    AssumeKeyword: ClassVar[TokenKind] = ...
    At: ClassVar[TokenKind] = ...
    AutomaticKeyword: ClassVar[TokenKind] = ...
    BeforeKeyword: ClassVar[TokenKind] = ...
    BeginKeyword: ClassVar[TokenKind] = ...
    BindKeyword: ClassVar[TokenKind] = ...
    BinsKeyword: ClassVar[TokenKind] = ...
    BinsOfKeyword: ClassVar[TokenKind] = ...
    BitKeyword: ClassVar[TokenKind] = ...
    BreakKeyword: ClassVar[TokenKind] = ...
    BufIf0Keyword: ClassVar[TokenKind] = ...
    BufIf1Keyword: ClassVar[TokenKind] = ...
    BufKeyword: ClassVar[TokenKind] = ...
    ByteKeyword: ClassVar[TokenKind] = ...
    CHandleKeyword: ClassVar[TokenKind] = ...
    CaseKeyword: ClassVar[TokenKind] = ...
    CaseXKeyword: ClassVar[TokenKind] = ...
    CaseZKeyword: ClassVar[TokenKind] = ...
    CellKeyword: ClassVar[TokenKind] = ...
    CheckerKeyword: ClassVar[TokenKind] = ...
    ClassKeyword: ClassVar[TokenKind] = ...
    ClockingKeyword: ClassVar[TokenKind] = ...
    CloseBrace: ClassVar[TokenKind] = ...
    CloseBracket: ClassVar[TokenKind] = ...
    CloseParenthesis: ClassVar[TokenKind] = ...
    CmosKeyword: ClassVar[TokenKind] = ...
    Colon: ClassVar[TokenKind] = ...
    ColonEquals: ClassVar[TokenKind] = ...
    ColonSlash: ClassVar[TokenKind] = ...
    Comma: ClassVar[TokenKind] = ...
    ConfigKeyword: ClassVar[TokenKind] = ...
    ConstKeyword: ClassVar[TokenKind] = ...
    ConstraintKeyword: ClassVar[TokenKind] = ...
    ContextKeyword: ClassVar[TokenKind] = ...
    ContinueKeyword: ClassVar[TokenKind] = ...
    CoverGroupKeyword: ClassVar[TokenKind] = ...
    CoverKeyword: ClassVar[TokenKind] = ...
    CoverPointKeyword: ClassVar[TokenKind] = ...
    CrossKeyword: ClassVar[TokenKind] = ...
    DeassignKeyword: ClassVar[TokenKind] = ...
    DefParamKeyword: ClassVar[TokenKind] = ...
    DefaultKeyword: ClassVar[TokenKind] = ...
    DesignKeyword: ClassVar[TokenKind] = ...
    Directive: ClassVar[TokenKind] = ...
    DisableKeyword: ClassVar[TokenKind] = ...
    DistKeyword: ClassVar[TokenKind] = ...
    DoKeyword: ClassVar[TokenKind] = ...
    Dollar: ClassVar[TokenKind] = ...
    Dot: ClassVar[TokenKind] = ...
    DoubleAnd: ClassVar[TokenKind] = ...
    DoubleAt: ClassVar[TokenKind] = ...
    DoubleColon: ClassVar[TokenKind] = ...
    DoubleEquals: ClassVar[TokenKind] = ...
    DoubleEqualsQuestion: ClassVar[TokenKind] = ...
    DoubleHash: ClassVar[TokenKind] = ...
    DoubleMinus: ClassVar[TokenKind] = ...
    DoubleOr: ClassVar[TokenKind] = ...
    DoublePlus: ClassVar[TokenKind] = ...
    DoubleStar: ClassVar[TokenKind] = ...
    EdgeKeyword: ClassVar[TokenKind] = ...
    ElseKeyword: ClassVar[TokenKind] = ...
    EmptyMacroArgument: ClassVar[TokenKind] = ...
    EndCaseKeyword: ClassVar[TokenKind] = ...
    EndCheckerKeyword: ClassVar[TokenKind] = ...
    EndClassKeyword: ClassVar[TokenKind] = ...
    EndClockingKeyword: ClassVar[TokenKind] = ...
    EndConfigKeyword: ClassVar[TokenKind] = ...
    EndFunctionKeyword: ClassVar[TokenKind] = ...
    EndGenerateKeyword: ClassVar[TokenKind] = ...
    EndGroupKeyword: ClassVar[TokenKind] = ...
    EndInterfaceKeyword: ClassVar[TokenKind] = ...
    EndKeyword: ClassVar[TokenKind] = ...
    EndModuleKeyword: ClassVar[TokenKind] = ...
    EndOfFile: ClassVar[TokenKind] = ...
    EndPackageKeyword: ClassVar[TokenKind] = ...
    EndPrimitiveKeyword: ClassVar[TokenKind] = ...
    EndProgramKeyword: ClassVar[TokenKind] = ...
    EndPropertyKeyword: ClassVar[TokenKind] = ...
    EndSequenceKeyword: ClassVar[TokenKind] = ...
    EndSpecifyKeyword: ClassVar[TokenKind] = ...
    EndTableKeyword: ClassVar[TokenKind] = ...
    EndTaskKeyword: ClassVar[TokenKind] = ...
    EnumKeyword: ClassVar[TokenKind] = ...
    Equals: ClassVar[TokenKind] = ...
    EqualsArrow: ClassVar[TokenKind] = ...
    EventKeyword: ClassVar[TokenKind] = ...
    EventuallyKeyword: ClassVar[TokenKind] = ...
    Exclamation: ClassVar[TokenKind] = ...
    ExclamationDoubleEquals: ClassVar[TokenKind] = ...
    ExclamationEquals: ClassVar[TokenKind] = ...
    ExclamationEqualsQuestion: ClassVar[TokenKind] = ...
    ExpectKeyword: ClassVar[TokenKind] = ...
    ExportKeyword: ClassVar[TokenKind] = ...
    ExtendsKeyword: ClassVar[TokenKind] = ...
    ExternKeyword: ClassVar[TokenKind] = ...
    FinalKeyword: ClassVar[TokenKind] = ...
    FirstMatchKeyword: ClassVar[TokenKind] = ...
    ForKeyword: ClassVar[TokenKind] = ...
    ForceKeyword: ClassVar[TokenKind] = ...
    ForeachKeyword: ClassVar[TokenKind] = ...
    ForeverKeyword: ClassVar[TokenKind] = ...
    ForkJoinKeyword: ClassVar[TokenKind] = ...
    ForkKeyword: ClassVar[TokenKind] = ...
    FunctionKeyword: ClassVar[TokenKind] = ...
    GenVarKeyword: ClassVar[TokenKind] = ...
    GenerateKeyword: ClassVar[TokenKind] = ...
    GlobalKeyword: ClassVar[TokenKind] = ...
    GreaterThan: ClassVar[TokenKind] = ...
    GreaterThanEquals: ClassVar[TokenKind] = ...
    Hash: ClassVar[TokenKind] = ...
    HashEqualsHash: ClassVar[TokenKind] = ...
    HashMinusHash: ClassVar[TokenKind] = ...
    HighZ0Keyword: ClassVar[TokenKind] = ...
    HighZ1Keyword: ClassVar[TokenKind] = ...
    Identifier: ClassVar[TokenKind] = ...
    IfKeyword: ClassVar[TokenKind] = ...
    IfNoneKeyword: ClassVar[TokenKind] = ...
    IffKeyword: ClassVar[TokenKind] = ...
    IgnoreBinsKeyword: ClassVar[TokenKind] = ...
    IllegalBinsKeyword: ClassVar[TokenKind] = ...
    ImplementsKeyword: ClassVar[TokenKind] = ...
    ImpliesKeyword: ClassVar[TokenKind] = ...
    ImportKeyword: ClassVar[TokenKind] = ...
    InOutKeyword: ClassVar[TokenKind] = ...
    IncDirKeyword: ClassVar[TokenKind] = ...
    IncludeFileName: ClassVar[TokenKind] = ...
    IncludeKeyword: ClassVar[TokenKind] = ...
    InitialKeyword: ClassVar[TokenKind] = ...
    InputKeyword: ClassVar[TokenKind] = ...
    InsideKeyword: ClassVar[TokenKind] = ...
    InstanceKeyword: ClassVar[TokenKind] = ...
    IntKeyword: ClassVar[TokenKind] = ...
    IntegerBase: ClassVar[TokenKind] = ...
    IntegerKeyword: ClassVar[TokenKind] = ...
    IntegerLiteral: ClassVar[TokenKind] = ...
    InterconnectKeyword: ClassVar[TokenKind] = ...
    InterfaceKeyword: ClassVar[TokenKind] = ...
    IntersectKeyword: ClassVar[TokenKind] = ...
    JoinAnyKeyword: ClassVar[TokenKind] = ...
    JoinKeyword: ClassVar[TokenKind] = ...
    JoinNoneKeyword: ClassVar[TokenKind] = ...
    LargeKeyword: ClassVar[TokenKind] = ...
    LeftShift: ClassVar[TokenKind] = ...
    LeftShiftEqual: ClassVar[TokenKind] = ...
    LessThan: ClassVar[TokenKind] = ...
    LessThanEquals: ClassVar[TokenKind] = ...
    LessThanMinusArrow: ClassVar[TokenKind] = ...
    LetKeyword: ClassVar[TokenKind] = ...
    LibListKeyword: ClassVar[TokenKind] = ...
    LibraryKeyword: ClassVar[TokenKind] = ...
    LineContinuation: ClassVar[TokenKind] = ...
    LocalKeyword: ClassVar[TokenKind] = ...
    LocalParamKeyword: ClassVar[TokenKind] = ...
    LogicKeyword: ClassVar[TokenKind] = ...
    LongIntKeyword: ClassVar[TokenKind] = ...
    MacroEscapedQuote: ClassVar[TokenKind] = ...
    MacroPaste: ClassVar[TokenKind] = ...
    MacroQuote: ClassVar[TokenKind] = ...
    MacroTripleQuote: ClassVar[TokenKind] = ...
    MacroUsage: ClassVar[TokenKind] = ...
    MacromoduleKeyword: ClassVar[TokenKind] = ...
    MatchesKeyword: ClassVar[TokenKind] = ...
    MediumKeyword: ClassVar[TokenKind] = ...
    Minus: ClassVar[TokenKind] = ...
    MinusArrow: ClassVar[TokenKind] = ...
    MinusColon: ClassVar[TokenKind] = ...
    MinusDoubleArrow: ClassVar[TokenKind] = ...
    MinusEqual: ClassVar[TokenKind] = ...
    ModPortKeyword: ClassVar[TokenKind] = ...
    ModuleKeyword: ClassVar[TokenKind] = ...
    NandKeyword: ClassVar[TokenKind] = ...
    NegEdgeKeyword: ClassVar[TokenKind] = ...
    NetTypeKeyword: ClassVar[TokenKind] = ...
    NewKeyword: ClassVar[TokenKind] = ...
    NextTimeKeyword: ClassVar[TokenKind] = ...
    NmosKeyword: ClassVar[TokenKind] = ...
    NoShowCancelledKeyword: ClassVar[TokenKind] = ...
    NorKeyword: ClassVar[TokenKind] = ...
    NotIf0Keyword: ClassVar[TokenKind] = ...
    NotIf1Keyword: ClassVar[TokenKind] = ...
    NotKeyword: ClassVar[TokenKind] = ...
    NullKeyword: ClassVar[TokenKind] = ...
    OneStep: ClassVar[TokenKind] = ...
    OpenBrace: ClassVar[TokenKind] = ...
    OpenBracket: ClassVar[TokenKind] = ...
    OpenParenthesis: ClassVar[TokenKind] = ...
    Or: ClassVar[TokenKind] = ...
    OrEqual: ClassVar[TokenKind] = ...
    OrEqualsArrow: ClassVar[TokenKind] = ...
    OrKeyword: ClassVar[TokenKind] = ...
    OrMinusArrow: ClassVar[TokenKind] = ...
    OutputKeyword: ClassVar[TokenKind] = ...
    PackageKeyword: ClassVar[TokenKind] = ...
    PackedKeyword: ClassVar[TokenKind] = ...
    ParameterKeyword: ClassVar[TokenKind] = ...
    Percent: ClassVar[TokenKind] = ...
    PercentEqual: ClassVar[TokenKind] = ...
    Placeholder: ClassVar[TokenKind] = ...
    Plus: ClassVar[TokenKind] = ...
    PlusColon: ClassVar[TokenKind] = ...
    PlusDivMinus: ClassVar[TokenKind] = ...
    PlusEqual: ClassVar[TokenKind] = ...
    PlusModMinus: ClassVar[TokenKind] = ...
    PmosKeyword: ClassVar[TokenKind] = ...
    PosEdgeKeyword: ClassVar[TokenKind] = ...
    PrimitiveKeyword: ClassVar[TokenKind] = ...
    PriorityKeyword: ClassVar[TokenKind] = ...
    ProgramKeyword: ClassVar[TokenKind] = ...
    PropertyKeyword: ClassVar[TokenKind] = ...
    ProtectedKeyword: ClassVar[TokenKind] = ...
    Pull0Keyword: ClassVar[TokenKind] = ...
    Pull1Keyword: ClassVar[TokenKind] = ...
    PullDownKeyword: ClassVar[TokenKind] = ...
    PullUpKeyword: ClassVar[TokenKind] = ...
    PulseStyleOnDetectKeyword: ClassVar[TokenKind] = ...
    PulseStyleOnEventKeyword: ClassVar[TokenKind] = ...
    PureKeyword: ClassVar[TokenKind] = ...
    Question: ClassVar[TokenKind] = ...
    RandCKeyword: ClassVar[TokenKind] = ...
    RandCaseKeyword: ClassVar[TokenKind] = ...
    RandKeyword: ClassVar[TokenKind] = ...
    RandSequenceKeyword: ClassVar[TokenKind] = ...
    RcmosKeyword: ClassVar[TokenKind] = ...
    RealKeyword: ClassVar[TokenKind] = ...
    RealLiteral: ClassVar[TokenKind] = ...
    RealTimeKeyword: ClassVar[TokenKind] = ...
    RefKeyword: ClassVar[TokenKind] = ...
    RegKeyword: ClassVar[TokenKind] = ...
    RejectOnKeyword: ClassVar[TokenKind] = ...
    ReleaseKeyword: ClassVar[TokenKind] = ...
    RepeatKeyword: ClassVar[TokenKind] = ...
    RestrictKeyword: ClassVar[TokenKind] = ...
    ReturnKeyword: ClassVar[TokenKind] = ...
    RightShift: ClassVar[TokenKind] = ...
    RightShiftEqual: ClassVar[TokenKind] = ...
    RnmosKeyword: ClassVar[TokenKind] = ...
    RootSystemName: ClassVar[TokenKind] = ...
    RpmosKeyword: ClassVar[TokenKind] = ...
    RtranIf0Keyword: ClassVar[TokenKind] = ...
    RtranIf1Keyword: ClassVar[TokenKind] = ...
    RtranKeyword: ClassVar[TokenKind] = ...
    SAlwaysKeyword: ClassVar[TokenKind] = ...
    SEventuallyKeyword: ClassVar[TokenKind] = ...
    SNextTimeKeyword: ClassVar[TokenKind] = ...
    SUntilKeyword: ClassVar[TokenKind] = ...
    SUntilWithKeyword: ClassVar[TokenKind] = ...
    ScalaredKeyword: ClassVar[TokenKind] = ...
    Semicolon: ClassVar[TokenKind] = ...
    SequenceKeyword: ClassVar[TokenKind] = ...
    ShortIntKeyword: ClassVar[TokenKind] = ...
    ShortRealKeyword: ClassVar[TokenKind] = ...
    ShowCancelledKeyword: ClassVar[TokenKind] = ...
    SignedKeyword: ClassVar[TokenKind] = ...
    Slash: ClassVar[TokenKind] = ...
    SlashEqual: ClassVar[TokenKind] = ...
    SmallKeyword: ClassVar[TokenKind] = ...
    SoftKeyword: ClassVar[TokenKind] = ...
    SolveKeyword: ClassVar[TokenKind] = ...
    SpecParamKeyword: ClassVar[TokenKind] = ...
    SpecifyKeyword: ClassVar[TokenKind] = ...
    Star: ClassVar[TokenKind] = ...
    StarArrow: ClassVar[TokenKind] = ...
    StarEqual: ClassVar[TokenKind] = ...
    StaticKeyword: ClassVar[TokenKind] = ...
    StringKeyword: ClassVar[TokenKind] = ...
    StringLiteral: ClassVar[TokenKind] = ...
    Strong0Keyword: ClassVar[TokenKind] = ...
    Strong1Keyword: ClassVar[TokenKind] = ...
    StrongKeyword: ClassVar[TokenKind] = ...
    StructKeyword: ClassVar[TokenKind] = ...
    SuperKeyword: ClassVar[TokenKind] = ...
    Supply0Keyword: ClassVar[TokenKind] = ...
    Supply1Keyword: ClassVar[TokenKind] = ...
    SyncAcceptOnKeyword: ClassVar[TokenKind] = ...
    SyncRejectOnKeyword: ClassVar[TokenKind] = ...
    SystemIdentifier: ClassVar[TokenKind] = ...
    TableKeyword: ClassVar[TokenKind] = ...
    TaggedKeyword: ClassVar[TokenKind] = ...
    TaskKeyword: ClassVar[TokenKind] = ...
    ThisKeyword: ClassVar[TokenKind] = ...
    ThroughoutKeyword: ClassVar[TokenKind] = ...
    Tilde: ClassVar[TokenKind] = ...
    TildeAnd: ClassVar[TokenKind] = ...
    TildeOr: ClassVar[TokenKind] = ...
    TildeXor: ClassVar[TokenKind] = ...
    TimeKeyword: ClassVar[TokenKind] = ...
    TimeLiteral: ClassVar[TokenKind] = ...
    TimePrecisionKeyword: ClassVar[TokenKind] = ...
    TimeUnitKeyword: ClassVar[TokenKind] = ...
    TranIf0Keyword: ClassVar[TokenKind] = ...
    TranIf1Keyword: ClassVar[TokenKind] = ...
    TranKeyword: ClassVar[TokenKind] = ...
    Tri0Keyword: ClassVar[TokenKind] = ...
    Tri1Keyword: ClassVar[TokenKind] = ...
    TriAndKeyword: ClassVar[TokenKind] = ...
    TriKeyword: ClassVar[TokenKind] = ...
    TriOrKeyword: ClassVar[TokenKind] = ...
    TriRegKeyword: ClassVar[TokenKind] = ...
    TripleAnd: ClassVar[TokenKind] = ...
    TripleEquals: ClassVar[TokenKind] = ...
    TripleLeftShift: ClassVar[TokenKind] = ...
    TripleLeftShiftEqual: ClassVar[TokenKind] = ...
    TripleRightShift: ClassVar[TokenKind] = ...
    TripleRightShiftEqual: ClassVar[TokenKind] = ...
    TypeKeyword: ClassVar[TokenKind] = ...
    TypedefKeyword: ClassVar[TokenKind] = ...
    UWireKeyword: ClassVar[TokenKind] = ...
    UnbasedUnsizedLiteral: ClassVar[TokenKind] = ...
    UnionKeyword: ClassVar[TokenKind] = ...
    Unique0Keyword: ClassVar[TokenKind] = ...
    UniqueKeyword: ClassVar[TokenKind] = ...
    UnitSystemName: ClassVar[TokenKind] = ...
    Unknown: ClassVar[TokenKind] = ...
    UnsignedKeyword: ClassVar[TokenKind] = ...
    UntilKeyword: ClassVar[TokenKind] = ...
    UntilWithKeyword: ClassVar[TokenKind] = ...
    UntypedKeyword: ClassVar[TokenKind] = ...
    UseKeyword: ClassVar[TokenKind] = ...
    VarKeyword: ClassVar[TokenKind] = ...
    VectoredKeyword: ClassVar[TokenKind] = ...
    VirtualKeyword: ClassVar[TokenKind] = ...
    VoidKeyword: ClassVar[TokenKind] = ...
    WAndKeyword: ClassVar[TokenKind] = ...
    WOrKeyword: ClassVar[TokenKind] = ...
    WaitKeyword: ClassVar[TokenKind] = ...
    WaitOrderKeyword: ClassVar[TokenKind] = ...
    Weak0Keyword: ClassVar[TokenKind] = ...
    Weak1Keyword: ClassVar[TokenKind] = ...
    WeakKeyword: ClassVar[TokenKind] = ...
    WhileKeyword: ClassVar[TokenKind] = ...
    WildcardKeyword: ClassVar[TokenKind] = ...
    WireKeyword: ClassVar[TokenKind] = ...
    WithKeyword: ClassVar[TokenKind] = ...
    WithinKeyword: ClassVar[TokenKind] = ...
    XnorKeyword: ClassVar[TokenKind] = ...
    Xor: ClassVar[TokenKind] = ...
    XorEqual: ClassVar[TokenKind] = ...
    XorKeyword: ClassVar[TokenKind] = ...
    XorTilde: ClassVar[TokenKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TransListCoverageBinInitializerSyntax(CoverageBinInitializerSyntax):
    sets: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class TransRangeSyntax(SyntaxNode):
    items: Incomplete
    repeat: TransRepeatRangeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class TransRepeatRangeSyntax(SyntaxNode):
    closeBracket: Token
    openBracket: Token
    selector: SelectorSyntax
    specifier: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TransSetSyntax(SyntaxNode):
    closeParen: Token
    openParen: Token
    ranges: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class TransparentMemberSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def wrapped(self) -> Symbol: ...

class Trivia:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, kind: TriviaKind, rawText: str) -> None: ...
    def getExplicitLocation(self) -> SourceLocation | None: ...
    def getRawText(self) -> str: ...
    def getSkippedTokens(self, *args, **kwargs): ...
    def syntax(self, *args, **kwargs): ...
    @property
    def kind(self) -> TriviaKind: ...

class TriviaKind:
    __members__: ClassVar[dict] = ...  # read-only
    BlockComment: ClassVar[TriviaKind] = ...
    Directive: ClassVar[TriviaKind] = ...
    DisabledText: ClassVar[TriviaKind] = ...
    EndOfLine: ClassVar[TriviaKind] = ...
    LineComment: ClassVar[TriviaKind] = ...
    SkippedSyntax: ClassVar[TriviaKind] = ...
    SkippedTokens: ClassVar[TriviaKind] = ...
    Unknown: ClassVar[TriviaKind] = ...
    Whitespace: ClassVar[TriviaKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Type(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    def coerceValue(self, value: ConstantValue) -> ConstantValue: ...
    @staticmethod
    def getCommonBase(left: Type, right: Type) -> Type: ...
    def implements(self, rhs: Type) -> bool: ...
    def isAssignmentCompatible(self, rhs: Type) -> bool: ...
    def isBitstreamCastable(self, rhs: Type) -> bool: ...
    def isBitstreamType(self, destination: bool = ...) -> bool: ...
    def isCastCompatible(self, rhs: Type) -> bool: ...
    def isDerivedFrom(self, rhs: Type) -> bool: ...
    def isEquivalent(self, rhs: Type) -> bool: ...
    def isMatching(self, rhs: Type) -> bool: ...
    def isValidForRand(self, mode: RandMode, languageVersion: LanguageVersion) -> bool: ...
    def makeSigned(self, compilation: Compilation) -> Type: ...
    def makeUnsigned(self, compilation: Compilation) -> Type: ...
    @property
    def arrayElementType(self) -> Type: ...
    @property
    def associativeIndexType(self) -> Type: ...
    @property
    def bitWidth(self) -> int: ...
    @property
    def bitstreamWidth(self) -> int: ...
    @property
    def canBeStringLike(self) -> bool: ...
    @property
    def canonicalType(self) -> Type: ...
    @property
    def defaultValue(self) -> ConstantValue: ...
    @property
    def fixedRange(self) -> ConstantRange: ...
    @property
    def hasFixedRange(self) -> bool: ...
    @property
    def integralFlags(self) -> IntegralFlags: ...
    @property
    def isAggregate(self) -> bool: ...
    @property
    def isAlias(self) -> bool: ...
    @property
    def isArray(self) -> bool: ...
    @property
    def isAssociativeArray(self) -> bool: ...
    @property
    def isBooleanConvertible(self) -> bool: ...
    @property
    def isByteArray(self) -> bool: ...
    @property
    def isCHandle(self) -> bool: ...
    @property
    def isClass(self) -> bool: ...
    @property
    def isCovergroup(self) -> bool: ...
    @property
    def isDynamicallySizedArray(self) -> bool: ...
    @property
    def isEnum(self) -> bool: ...
    @property
    def isError(self) -> bool: ...
    @property
    def isEvent(self) -> bool: ...
    @property
    def isFixedSize(self) -> bool: ...
    @property
    def isFloating(self) -> bool: ...
    @property
    def isFourState(self) -> bool: ...
    @property
    def isHandleType(self) -> bool: ...
    @property
    def isIntegral(self) -> bool: ...
    @property
    def isIterable(self) -> bool: ...
    @property
    def isNull(self) -> bool: ...
    @property
    def isNumeric(self) -> bool: ...
    @property
    def isPackedArray(self) -> bool: ...
    @property
    def isPackedUnion(self) -> bool: ...
    @property
    def isPredefinedInteger(self) -> bool: ...
    @property
    def isPropertyType(self) -> bool: ...
    @property
    def isQueue(self) -> bool: ...
    @property
    def isScalar(self) -> bool: ...
    @property
    def isSequenceType(self) -> bool: ...
    @property
    def isSigned(self) -> bool: ...
    @property
    def isSimpleBitVector(self) -> bool: ...
    @property
    def isSimpleType(self) -> bool: ...
    @property
    def isSingular(self) -> bool: ...
    @property
    def isString(self) -> bool: ...
    @property
    def isStruct(self) -> bool: ...
    @property
    def isTaggedUnion(self) -> bool: ...
    @property
    def isTypeRefType(self) -> bool: ...
    @property
    def isUnbounded(self) -> bool: ...
    @property
    def isUnpackedArray(self) -> bool: ...
    @property
    def isUnpackedStruct(self) -> bool: ...
    @property
    def isUnpackedUnion(self) -> bool: ...
    @property
    def isUntypedType(self) -> bool: ...
    @property
    def isValidForDPIArg(self) -> bool: ...
    @property
    def isValidForDPIReturn(self) -> bool: ...
    @property
    def isValidForSequence(self) -> bool: ...
    @property
    def isVirtualInterface(self) -> bool: ...
    @property
    def isVoid(self) -> bool: ...
    @property
    def selectableWidth(self) -> int: ...

class TypeAliasType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def firstForwardDecl(self) -> ForwardingTypedefSymbol: ...
    @property
    def targetType(self) -> DeclaredType: ...
    @property
    def visibility(self) -> Visibility: ...

class TypeAssignmentSyntax(SyntaxNode):
    assignment: EqualsTypeClauseSyntax
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TypeParameterDeclarationSyntax(ParameterDeclarationBaseSyntax):
    declarators: Incomplete
    typeKeyword: Token
    typeRestriction: ForwardTypeRestrictionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class TypeParameterSymbol(Symbol, ParameterSymbolBase):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isOverridden(self) -> bool: ...
    @property
    def targetType(self): ...
    @property
    def typeAlias(self): ...

class TypePrinter:
    options: TypePrintingOptions
    def __init__(self) -> None: ...
    def append(self, type: Type) -> None: ...
    def clear(self) -> None: ...
    def toString(self) -> str: ...

class TypePrintingOptions:
    class AnonymousTypeStyle:
        __members__: ClassVar[dict] = ...  # read-only
        FriendlyName: ClassVar[TypePrintingOptions.AnonymousTypeStyle] = ...
        SystemName: ClassVar[TypePrintingOptions.AnonymousTypeStyle] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    FriendlyName: ClassVar[TypePrintingOptions.AnonymousTypeStyle] = ...
    SystemName: ClassVar[TypePrintingOptions.AnonymousTypeStyle] = ...
    addSingleQuotes: bool
    anonymousTypeStyle: Incomplete
    elideScopeNames: bool
    fullEnumType: bool
    printAKA: bool
    skipScopedTypeNames: bool
    skipTypeDefs: bool
    def __init__(self, *args, **kwargs) -> None: ...

class TypeRefType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class TypeReferenceExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def targetType(self): ...

class TypeReferenceSyntax(DataTypeSyntax):
    closeParen: Token
    expr: ExpressionSyntax
    openParen: Token
    typeKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TypedefDeclarationSyntax(MemberSyntax):
    dimensions: Incomplete
    name: Token
    semi: Token
    type: DataTypeSyntax
    typedefKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UdpBodySyntax(SyntaxNode):
    endtable: Token
    entries: Incomplete
    initialStmt: UdpInitialStmtSyntax
    portDecls: Incomplete
    table: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UdpDeclarationSyntax(MemberSyntax):
    body: UdpBodySyntax
    endBlockName: NamedBlockClauseSyntax
    endprimitive: Token
    name: Token
    portList: UdpPortListSyntax
    primitive: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UdpEdgeFieldSyntax(UdpFieldBaseSyntax):
    closeParen: Token
    first: Token
    openParen: Token
    second: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UdpEntrySyntax(SyntaxNode):
    colon1: Token
    colon2: Token
    current: UdpFieldBaseSyntax
    inputs: Incomplete
    next: UdpFieldBaseSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UdpFieldBaseSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class UdpInitialStmtSyntax(SyntaxNode):
    equals: Token
    initial: Token
    name: Token
    semi: Token
    value: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class UdpInputPortDeclSyntax(UdpPortDeclSyntax):
    keyword: Token
    names: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class UdpOutputPortDeclSyntax(UdpPortDeclSyntax):
    initializer: EqualsValueClauseSyntax
    keyword: Token
    name: Token
    reg: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UdpPortDeclSyntax(SyntaxNode):
    attributes: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class UdpPortListSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class UdpSimpleFieldSyntax(UdpFieldBaseSyntax):
    field: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UnaryAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> AssertionExpr: ...
    @property
    def op(self) -> UnaryAssertionOperator: ...
    @property
    def range(self) -> SequenceRange | None: ...

class UnaryAssertionOperator:
    __members__: ClassVar[dict] = ...  # read-only
    Always: ClassVar[UnaryAssertionOperator] = ...
    Eventually: ClassVar[UnaryAssertionOperator] = ...
    NextTime: ClassVar[UnaryAssertionOperator] = ...
    Not: ClassVar[UnaryAssertionOperator] = ...
    SAlways: ClassVar[UnaryAssertionOperator] = ...
    SEventually: ClassVar[UnaryAssertionOperator] = ...
    SNextTime: ClassVar[UnaryAssertionOperator] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class UnaryBinsSelectExpr(BinsSelectExpr):
    class Op:
        __members__: ClassVar[dict] = ...  # read-only
        Negation: ClassVar[UnaryBinsSelectExpr.Op] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Negation: ClassVar[UnaryBinsSelectExpr.Op] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> BinsSelectExpr: ...
    @property
    def op(self): ...

class UnaryBinsSelectExprSyntax(BinsSelectExpressionSyntax):
    expr: BinsSelectConditionExprSyntax
    op: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UnaryConditionalDirectiveExpressionSyntax(ConditionalDirectiveExpressionSyntax):
    op: Token
    operand: ConditionalDirectiveExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class UnaryExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def op(self) -> UnaryOperator: ...
    @property
    def operand(self) -> Expression: ...

class UnaryOperator:
    __members__: ClassVar[dict] = ...  # read-only
    BitwiseAnd: ClassVar[UnaryOperator] = ...
    BitwiseNand: ClassVar[UnaryOperator] = ...
    BitwiseNor: ClassVar[UnaryOperator] = ...
    BitwiseNot: ClassVar[UnaryOperator] = ...
    BitwiseOr: ClassVar[UnaryOperator] = ...
    BitwiseXnor: ClassVar[UnaryOperator] = ...
    BitwiseXor: ClassVar[UnaryOperator] = ...
    LogicalNot: ClassVar[UnaryOperator] = ...
    Minus: ClassVar[UnaryOperator] = ...
    Plus: ClassVar[UnaryOperator] = ...
    Postdecrement: ClassVar[UnaryOperator] = ...
    Postincrement: ClassVar[UnaryOperator] = ...
    Predecrement: ClassVar[UnaryOperator] = ...
    Preincrement: ClassVar[UnaryOperator] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class UnaryPropertyExprSyntax(PropertyExprSyntax):
    expr: PropertyExprSyntax
    op: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UnarySelectPropertyExprSyntax(PropertyExprSyntax):
    closeBracket: Token
    expr: PropertyExprSyntax
    op: Token
    openBracket: Token
    selector: SelectorSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class UnbasedUnsizedIntegerLiteral(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def literalValue(self): ...
    @property
    def value(self): ...

class Unbounded:
    def __init__(self) -> None: ...

class UnboundedLiteral(Expression):
    def __init__(self, *args, **kwargs) -> None: ...

class UnboundedType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class UnconditionalBranchDirectiveSyntax(DirectiveSyntax):
    disabledTokens: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class UnconnectedDrive:
    __members__: ClassVar[dict] = ...  # read-only
    None_: ClassVar[UnconnectedDrive] = ...
    Pull0: ClassVar[UnconnectedDrive] = ...
    Pull1: ClassVar[UnconnectedDrive] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class UnconnectedDriveDirectiveSyntax(DirectiveSyntax):
    strength: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UndefDirectiveSyntax(DirectiveSyntax):
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UninstantiatedDefSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def definitionName(self) -> str: ...
    @property
    def isChecker(self) -> bool: ...
    @property
    def paramExpressions(self) -> span[Expression]: ...
    @property
    def portConnections(self) -> span[AssertionExpr]: ...
    @property
    def portNames(self) -> span[str]: ...

class UniquePriorityCheck:
    __members__: ClassVar[dict] = ...  # read-only
    None_: ClassVar[UniquePriorityCheck] = ...
    Priority: ClassVar[UniquePriorityCheck] = ...
    Unique: ClassVar[UniquePriorityCheck] = ...
    Unique0: ClassVar[UniquePriorityCheck] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class UniquenessConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def items(self): ...

class UniquenessConstraintSyntax(ConstraintItemSyntax):
    ranges: RangeListSyntax
    semi: Token
    unique: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UnpackedStructType(Type, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def systemId(self) -> int: ...

class UnpackedUnionType(Type, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isTagged(self) -> bool: ...
    @property
    def systemId(self) -> int: ...

class UntypedType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class UserDefinedNetDeclarationSyntax(MemberSyntax):
    declarators: Incomplete
    delay: TimingControlSyntax
    netType: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ValueDriver:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def containingSymbol(self): ...
    @property
    def flags(self): ...
    @property
    def isClockVar(self) -> bool: ...
    @property
    def isFromSideEffect(self) -> bool: ...
    @property
    def isInSingleDriverProcedure(self) -> bool: ...
    @property
    def isInputPort(self) -> bool: ...
    @property
    def isUnidirectionalPort(self) -> bool: ...
    @property
    def kind(self): ...
    @property
    def prefixExpression(self): ...
    @property
    def procCallExpression(self): ...
    @property
    def source(self): ...
    @property
    def sourceRange(self): ...

class ValueExpressionBase(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def symbol(self): ...

class ValueRangeExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def left(self) -> Expression: ...
    @property
    def right(self) -> Expression: ...

class ValueRangeExpressionSyntax(ExpressionSyntax):
    closeBracket: Token
    left: ExpressionSyntax
    op: Token
    openBracket: Token
    right: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ValueRangeKind:
    __members__: ClassVar[dict] = ...  # read-only
    AbsoluteTolerance: ClassVar[ValueRangeKind] = ...
    RelativeTolerance: ClassVar[ValueRangeKind] = ...
    Simple: ClassVar[ValueRangeKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ValueSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def initializer(self) -> Expression: ...
    @property
    def type(self): ...

class VariableDeclStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def symbol(self): ...

class VariableDimensionSyntax(SyntaxNode):
    closeBracket: Token
    openBracket: Token
    specifier: DimensionSpecifierSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class VariableFlags:
    __members__: ClassVar[dict] = ...  # read-only
    CheckerFreeVariable: ClassVar[VariableFlags] = ...
    CompilerGenerated: ClassVar[VariableFlags] = ...
    Const: ClassVar[VariableFlags] = ...
    CoverageSampleFormal: ClassVar[VariableFlags] = ...
    ImmutableCoverageOption: ClassVar[VariableFlags] = ...
    None_: ClassVar[VariableFlags] = ...
    RefStatic: ClassVar[VariableFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class VariableLifetime:
    __members__: ClassVar[dict] = ...  # read-only
    Automatic: ClassVar[VariableLifetime] = ...
    Static: ClassVar[VariableLifetime] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class VariablePattern(Pattern):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def variable(self): ...

class VariablePatternSyntax(PatternSyntax):
    dot: Token
    variableName: Token
    def __init__(self, *args, **kwargs) -> None: ...

class VariablePortHeaderSyntax(PortHeaderSyntax):
    constKeyword: Token
    dataType: DataTypeSyntax
    direction: Token
    varKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class VariableSymbol(ValueSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def flags(self) -> VariableFlags: ...
    @property
    def lifetime(self) -> VariableLifetime: ...

class VersionInfo:
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def getHash() -> str: ...
    @staticmethod
    def getMajor() -> int: ...
    @staticmethod
    def getMinor() -> int: ...
    @staticmethod
    def getPatch() -> int: ...

class VirtualInterfaceType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def iface(self) -> InstanceSymbol: ...
    @property
    def modport(self) -> ModportSymbol: ...

class VirtualInterfaceTypeSyntax(DataTypeSyntax):
    interfaceKeyword: Token
    modport: DotMemberClauseSyntax
    name: Token
    parameters: ParameterValueAssignmentSyntax
    virtualKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class Visibility:
    __members__: ClassVar[dict] = ...  # read-only
    Local: ClassVar[Visibility] = ...
    Protected: ClassVar[Visibility] = ...
    Public: ClassVar[Visibility] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class VisitAction:
    __members__: ClassVar[dict] = ...  # read-only
    Advance: ClassVar[VisitAction] = ...
    Interrupt: ClassVar[VisitAction] = ...
    Skip: ClassVar[VisitAction] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class VoidCastedCallStatementSyntax(StatementSyntax):
    apostrophe: Token
    closeParen: Token
    expr: ExpressionSyntax
    openParen: Token
    semi: Token
    voidKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class VoidType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class WaitForkStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...

class WaitForkStatementSyntax(StatementSyntax):
    fork: Token
    semi: Token
    wait: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WaitOrderStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def events(self) -> span[Expression]: ...
    @property
    def ifFalse(self) -> Statement: ...
    @property
    def ifTrue(self) -> Statement: ...

class WaitOrderStatementSyntax(StatementSyntax):
    action: ActionBlockSyntax
    closeParen: Token
    names: Incomplete
    openParen: Token
    wait_order: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WaitStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def cond(self) -> Expression: ...
    @property
    def stmt(self) -> Statement: ...

class WaitStatementSyntax(StatementSyntax):
    closeParen: Token
    expr: ExpressionSyntax
    openParen: Token
    statement: StatementSyntax
    wait: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WhileLoopStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self) -> Statement: ...
    @property
    def cond(self) -> Expression: ...

class WildcardDimensionSpecifierSyntax(DimensionSpecifierSyntax):
    star: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WildcardImportSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isFromExport(self) -> bool: ...
    @property
    def package(self) -> PackageSymbol: ...
    @property
    def packageName(self) -> str: ...

class WildcardPattern(Pattern):
    def __init__(self, *args, **kwargs) -> None: ...

class WildcardPatternSyntax(PatternSyntax):
    dot: Token
    star: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WildcardPortConnectionSyntax(PortConnectionSyntax):
    dot: Token
    star: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WildcardPortListSyntax(PortListSyntax):
    closeParen: Token
    dot: Token
    openParen: Token
    star: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WildcardUdpPortListSyntax(UdpPortListSyntax):
    closeParen: Token
    dot: Token
    openParen: Token
    semi: Token
    star: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WithClauseSyntax(SyntaxNode):
    closeParen: Token
    expr: ExpressionSyntax
    openParen: Token
    with_: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WithFunctionClauseSyntax(SyntaxNode):
    name: NameSyntax
    with_: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WithFunctionSampleSyntax(SyntaxNode):
    function: Token
    portList: FunctionPortListSyntax
    sample: Token
    with_: Token
    def __init__(self, *args, **kwargs) -> None: ...

class logic_t:
    x: ClassVar[logic_t] = ...  # read-only
    z: ClassVar[logic_t] = ...  # read-only
    value: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, value: int) -> None: ...
    def __and__(self, arg0: logic_t) -> logic_t: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, arg0: logic_t) -> logic_t: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> logic_t: ...
    def __ne__(self, arg0: logic_t) -> logic_t: ...
    def __or__(self, arg0: logic_t) -> logic_t: ...
    def __xor__(self, arg0: logic_t) -> logic_t: ...
    @property
    def isUnknown(self) -> bool: ...

def clog2(value) -> int: ...
def literalBaseFromChar(base: str, result: LiteralBase) -> bool: ...
def rewrite(tree: SyntaxTree, handler: Callable) -> SyntaxTree: ...
